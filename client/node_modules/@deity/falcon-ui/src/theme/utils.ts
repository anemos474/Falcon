import merge from 'deepmerge';
import isPlainObject from 'is-plain-object';
import { keyframes } from '@emotion/core';
import { themablePropsKeys } from './responsiveprops';
import { Theme } from './index';

export type RecursivePartial<T> = { [key in keyof T]?: RecursivePartial<T[key]> };

export function extractThemableProps(props: any) {
  const themableProps: any = {};
  const rest: any = {};

  // eslint-disable-next-line
  for (let key in props) {
    if (themablePropsKeys.indexOf(key as any) !== -1) {
      themableProps[key] = props[key];
    } else {
      rest[key] = props[key];
    }
  }

  return {
    themableProps,
    rest
  };
}

/**
 * Determines if object is `@emotion`'s keyframe definition,
 * they sets `anim=1` to keyframes processed by `@emotion/core/keyframes` function
 * @param {*} object
 */
function isEmotionKeyframe(object: any) {
  return object && object.anim === 1;
}

export function mergeThemes(theme: Theme, themeOverride: RecursivePartial<Theme>): Theme {
  const newTheme = merge(theme, themeOverride as Theme, {
    isMergeableObject: x => isPlainObject(x) && !isEmotionKeyframe(x)
  });

  // keyframes merging needs to be handled in very special way
  // each not yet processed keyframes definitions needs to be passed
  // to emotion's keyframes function in order to be consumed in styles
  if (newTheme.keyframes) {
    // eslint-disable-next-line
    for (let keyframeKey in newTheme.keyframes) {
      // only process keyframes not yet processed by emotion (anim property not et)
      if (!newTheme.keyframes[keyframeKey].anim) {
        // TODO remove casting to `any` when https://github.com/deity-io/falcon/issues/545 fixed
        newTheme.keyframes[keyframeKey] = keyframes(newTheme.keyframes[keyframeKey] as any) as any;
      }
    }
  }

  return newTheme;
}

export function gridSizes(columnAmount: number, theme: Theme) {
  function roundToMaxTwoDecimals(num: number) {
    return Math.round((num + Number.EPSILON) * 100) / 100;
  }

  const generatedSteps = {};
  for (let step = 1; step < columnAmount; step++) {
    const key = `${step}/${columnAmount}`;
    const unformattedValue = (step / columnAmount) * 100;
    const value = `${roundToMaxTwoDecimals(unformattedValue)}%`;

    generatedSteps[key] = value;
  }

  theme.sizes = { ...theme.sizes, ...generatedSteps };
}

export function mapNegativeSpacings(theme): Theme {
  const { spacing } = theme;

  if (!spacing || typeof spacing !== 'object' || Object.keys(spacing).length <= 0) return theme;
  const negativeSpacings = {};

  // Foreach value which is a number create a negative one with a key of '-key'
  Object.keys(spacing).forEach(key => {
    const value = spacing[key];

    if (typeof value !== 'number' || value <= 0) return;
    negativeSpacings[`-${key}`] = value * -1;
  });

  return { ...theme, spacing: { ...spacing, ...negativeSpacings } };
}
