import React from 'react';
import styled from '@emotion/styled-base';
import isPropValid from '@emotion/is-prop-valid';
import { extractThemableProps } from './utils';
import { baseTheme } from './baseTheme';
import { propsMappingKeys, mappings, PropsMappings, ResponsivePropMapping } from './responsiveprops';
import { getThemeBreakpointNames } from './getThemeBreakpoints';
import {
  extractBreakpointBlockThemingProps,
  filterOutNonBreakpointBlockThemingProps,
  mapBreakpointBlockThemingPropsToBaseThemmingProps
} from './formatBreakpointCssBlocks';
import {
  Theme,
  CSSObject,
  PropsWithTheme,
  ThemingProps,
  ComponentTheme,
  InlineCss,
  BaseThemingProps,
  BreakpointBlockThemingProps,
  DefaultTheme
} from './index';

const NESTED_CSS_OBJECT_SELECTORS = [':', '&', '*', '>', '@'];

const convertPropToCss = (
  mappingKey: string,
  propMapping: ResponsivePropMapping,
  matchingProp: string | number,
  theme: Theme
): CSSObject => {
  // if mapping does not have cssProp specified fallback to it's key as css property name
  const cssPropName = propMapping.cssProp || mappingKey;
  // if matching props is themable prop then get it's actual value from theme props otherwise
  // then just pass it as css prop value
  // TODO: typescript: is there a way to improve those typings?
  const cssPropValue = !propMapping.themeProp ? matchingProp : (theme[propMapping.themeProp] as any)[matchingProp];

  if (propMapping.transformToCss) {
    return propMapping.transformToCss(cssPropValue);
  }

  return {
    [cssPropName]: cssPropValue
  };
};

function convertThemedPropsToCss<TProps = any>(props: ThemingProps<TProps>, theme: Theme): CSSObject {
  //  if theme is not provided via theme provider do not map anything
  if (!theme) {
    return {};
  }

  // TODO: typescript: can typings be improved for that object?
  const targetCss = {} as any;

  // eslint-disable-next-line
  for (let mappingKey in props) {
    const propMapping = mappings[mappingKey as keyof PropsMappings];
    const matchingProp = (props as any)[mappingKey];

    // move along if there is no matching prop in mappings for given key found
    if (!propMapping) {
      continue;
    }
    // if matching prop is typeof string it means it's not responsive
    if (typeof matchingProp === 'string' || typeof matchingProp === 'number') {
      const cssObject = convertPropToCss(mappingKey, propMapping, matchingProp, theme);
      // eslint-disable-next-line
      for (let mappingKey in cssObject) {
        targetCss[mappingKey] = cssObject[mappingKey];
      }
    } else {
      // if it's not string it needs to be object that has responsive breakpoints keys
      // here we only translate all themed values to css values, we don't create media queries
      // eslint-disable-next-line
      for (let breakpointKey in matchingProp) {
        const breakpointValue = (theme.breakpoints as any)[breakpointKey];
        const matchingResponsiveProp = matchingProp[breakpointKey];
        if (breakpointValue === undefined) {
          continue;
        }

        const cssObject = convertPropToCss(mappingKey, propMapping, matchingResponsiveProp, theme);
        // eslint-disable-next-line
        for (let mappingKey in cssObject) {
          if (!targetCss[mappingKey]) {
            targetCss[mappingKey] = {};
          }

          targetCss[mappingKey][breakpointKey] = cssObject[mappingKey];
        }
      }
    }
  }

  return targetCss;
}

function convertResponsivePropsToMediaQueries(css: CSSObject, theme: Theme) {
  const target: any = {};
  const mediaQueries: any = {};

  // eslint-disable-next-line
  for (let cssProp in css) {
    const cssValue = css[cssProp];
    if (!cssValue || typeof cssValue !== 'object' || Array.isArray(cssValue)) {
      target[cssProp] = cssValue;
    }
    // we need to look for responsive props in nested css as well
    // for example in :hover object
    else if (NESTED_CSS_OBJECT_SELECTORS.indexOf(cssProp[0]) !== -1) {
      target[cssProp] = convertResponsivePropsToMediaQueries(cssValue as CSSObject, theme);
    } else {
      // eslint-disable-next-line
      for (let potentialBreakpointKey in cssValue) {
        const breakpointValue = (theme.breakpoints as any)[potentialBreakpointKey];
        const valueForBreakpoint = (cssValue as any)[potentialBreakpointKey];

        if (breakpointValue) {
          // add media query key to mediaQueries object if it hasn't already got one
          if (!mediaQueries[potentialBreakpointKey]) {
            mediaQueries[potentialBreakpointKey] = {};
          }
          mediaQueries[potentialBreakpointKey][cssProp] = valueForBreakpoint;
        } else if (breakpointValue === 0) {
          target[cssProp] = valueForBreakpoint;
        } else {
          if (!target[cssProp]) {
            target[cssProp] = {};
          }

          target[cssProp][potentialBreakpointKey] = valueForBreakpoint;
        }
      }
    }
  }

  // media queries need to be handled in very careful way as order matters
  // so media min-width with smaller px value always apper before media min-width with larger px value
  // in resulting style
  Object.keys(mediaQueries)
    .sort((first, second) => ((theme.breakpoints as any)[first] > (theme.breakpoints as any)[second] ? 1 : -1))
    .forEach(sortedMediaQueryKey => {
      const mediaQueryPxValue = (theme.breakpoints as any)[sortedMediaQueryKey];
      target[`@media screen and (min-width: ${mediaQueryPxValue}px)`] = mediaQueries[sortedMediaQueryKey];
    });

  return target;
}

function getCss<TProps>(
  css: InlineCss<PropsWithTheme<ThemingProps<TProps>>>,
  props: PropsWithTheme<ThemingProps<TProps>>
) {
  return typeof css === 'function' ? css(props) : css;
}

type DefaultThemePropDefinition<TProps> = {
  key: string;
  props?: ComponentTheme<TProps>;
};
/**
 * `<themedComponent>.defaultTheme` specifies it's `props` in nested object which key is used as `themeKey`
 *
 * TODO: write unit tests!
 * @param defaultTheme
 */
function extractDefaultThemeFromThemedComponent<TProps>(
  defaultTheme?: DefaultTheme<TProps>
): DefaultThemePropDefinition<TProps> | undefined {
  if (!defaultTheme) {
    return undefined;
  }

  // default theme should have only one key, so we try to take first one, we also expect an `object` under it
  const potentialKey = Object.keys(defaultTheme)[0];
  const themeKey = typeof (defaultTheme as any)[potentialKey] === 'object' ? potentialKey : undefined;

  if (!themeKey) {
    return undefined;
  }

  return {
    key: themeKey,
    props: (defaultTheme as any)[themeKey]
  };
}
/**
 * @private
 * exported only because of unit test !!!
 *
 * following diagram shows theme props order (values in brackets)
 *
 * | theme                                            | themed component                                     | inline                          |
 * | ------------------------------------------------ | ---------------------------------------------------- | ------------------------------- |
 * | `[theme].components[component-theme-name]`       | `themed({defaultTheme:{[component-theme-name]:{}}})` | `<Box bg="primary"`             |
 * | **(2)** `component.breakpointBlockProps`         | **(1)** `defaultTheme.breakpointBlockProps`          | **(13)** `breakpointBlockProps` |
 * | **(6)** `component.baseThemingProps`             | **(5)** `defaultTheme.baseThemingProps`              | **(14)** `baseThemingProps`     |
 * | **(10)** `component.cssProp`                     | **(9)** `defaultTheme.cssProp`                       | **(15)** `cssProp`              |
 * | **(4)** `component.variant.breakpointBlockProps` | **(3)** `defaultTheme.variant.breakpointBlockProps`  |                                 |
 * | **(8)** `component.variant.baseThemingProps`     | **(7)** `defaultTheme.variant.baseThemingProps`      |                                 |
 * | **(12)** `component.variant.cssProp`             | **(11)** `defaultTheme.variant.cssProp`              |                                 |
 * @param props
 */
export function mergeThemingProps<TProps>(props: PropsWithTheme<ThemingProps<TProps>>) {
  const { defaultTheme: defaultThemeProp, theme, variant, css: inlineCss, ...restProps } = props;

  const defaultTheme = extractDefaultThemeFromThemedComponent(defaultThemeProp);
  const breakpointNames = getThemeBreakpointNames(theme);
  const breakpointBlockThemingProps = extractBreakpointBlockThemingProps(breakpointNames, restProps);
  const remainingProps = filterOutNonBreakpointBlockThemingProps(breakpointNames, restProps);
  const { themableProps } = extractThemableProps(remainingProps);

  // first we need to check where themed props and css props are defined and merge them
  // // css props need to merged separately as those do not need to be processed to extract css
  // Merging order
  // 1 -  props defined in defaultTheme props  as those are defaults
  // 2 -  props defined in theme.components for given `defaultTheme.key` as those are defaults
  // 3 -  props defined in defaultTheme variant prop if props.variant is defined
  // 4 -  props defined in theme.components[]variants if props.variant is defined
  // 5 -  props defined directly on component
  const breakpointBlockThemingPropsToMerge: BreakpointBlockThemingProps[] = [];
  const baseThemingPropsToMerge: BaseThemingProps[] = [];
  const cssPropsToMerge: any[] = [];

  const addPropsToMerge = (propsToMerge: ThemingProps) => {
    const { css, ...rest } = propsToMerge;

    if (css) {
      cssPropsToMerge.push(getCss(css, props));
    }

    // Format breakpoint CSS blocks

    breakpointBlockThemingPropsToMerge.push(extractBreakpointBlockThemingProps(breakpointNames, rest));
    baseThemingPropsToMerge.push(filterOutNonBreakpointBlockThemingProps(breakpointNames, rest));
  };

  //  start with props defined in `defaultTheme` prop as base
  if (defaultTheme !== undefined) {
    addPropsToMerge(defaultTheme.props);

    // if props are defined in `theme.components` object for `defaultTheme.key` merge them with default ones
    const areComponentPropsDefinedInTheme = theme.components[defaultTheme.key] !== undefined;
    if (areComponentPropsDefinedInTheme) {
      addPropsToMerge(theme.components[defaultTheme.key]);
    }

    // themed props can also be defined for component variant
    if (variant) {
      // check for `variant` prop defined in themed component `defaultTheme`
      const defaultThemeVariants = defaultTheme.props && defaultTheme.props.variants;

      if (defaultThemeVariants && defaultThemeVariants[variant]) {
        addPropsToMerge(defaultThemeVariants[variant]);
      }
      // check for `variant` prop defined in `theme.components` object
      const themeVariants = areComponentPropsDefinedInTheme && theme.components[defaultTheme.key].variants;
      if (themeVariants && themeVariants[variant]) {
        addPropsToMerge(themeVariants[variant]);
      }
    }
  }

  const mergedBreakpointBlockThemingProps = Object.assign({}, ...breakpointBlockThemingPropsToMerge);
  const baseThemingPropsFromBreakpointBlockThemingProps = mapBreakpointBlockThemingPropsToBaseThemmingProps(
    breakpointNames,
    mergedBreakpointBlockThemingProps
  );
  const mergedBaseThemingProps = Object.assign(
    {},
    ...[baseThemingPropsFromBreakpointBlockThemingProps, ...baseThemingPropsToMerge]
  );
  // merged themable props need to be converted to css before returning
  const cssFromThemedProps = convertThemedPropsToCss(mergedBaseThemingProps, theme);

  cssPropsToMerge.push(
    convertThemedPropsToCss(
      mapBreakpointBlockThemingPropsToBaseThemmingProps(breakpointNames, breakpointBlockThemingProps),
      theme
    )
  );

  // out of all component props extract themable ones, convert to css and add to merge
  cssPropsToMerge.push(convertThemedPropsToCss(themableProps, theme));

  // as last step add for merging those `css` prop which defined directly on component
  if (inlineCss) {
    cssPropsToMerge.push(getCss(inlineCss, props));
  }

  const cssProps = Object.assign({}, ...cssPropsToMerge);
  // finally merge css from themed props with css from css props
  const mergedCss = { ...cssFromThemedProps, ...cssProps };

  return mergedCss;
}

/**
 * this function responsibility is to extract css object from
 * both themed props (that use props values from theme) and css object/function props
 * TODO: perhaps this function could be written in prettier way?
 *  @param props
 */
function getThemedCss<TProps>(props: PropsWithTheme<ThemingProps<TProps>>) {
  //  if theme is not provided via theme provider or inline theme prop
  // fall back to default theme
  if (!props.theme || !props.theme.components) {
    props = { ...props, theme: baseTheme };
  }

  const mergedCss = mergeThemingProps(props);

  // as a last step we need to check each css prop if it's value is responsive
  return convertResponsivePropsToMediaQueries(mergedCss, props.theme);
}

// filtering which props to forward to next component is tricky
// and behaves differently if next component is html element, custom component
// or custom component whihch is themed component
const customPropsBlacklist = ['as', 'tag', 'variant', 'defaultTheme', 'css'];

const filterPropsToForward = (baseComponent: any, props: any, ref: any) => {
  const filteredProps: any = {};
  const isHtmlTag = typeof baseComponent === 'string';
  // eslint-disable-next-line
  for (let key in props) {
    // when html tag is provided forward only valid html props to it
    if (isHtmlTag && !isPropValid(key)) continue;

    // if custom component is provided via `as` prop do not forward themable props to it (bg, color, m, p etc)
    // neighter forward any of the blacklisted props
    const themableProp = propsMappingKeys.indexOf(key as any) !== -1 || customPropsBlacklist.indexOf(key) !== -1;
    if (themableProp) continue;

    filteredProps[key] = props[key];
  }

  filteredProps.ref = ref;

  return filteredProps;
};

type Tag = string | {}; // TODO: it should be `keyof JSX.IntrinsicElements | React.ComponentType ;`

type DynamicHtmlTagProps = {
  tag: keyof JSX.IntrinsicElements | React.ComponentType;
  as?: keyof JSX.IntrinsicElements | React.ComponentType;
};
/**
 * Handles dynamic html tag rendering via and `as` prop as well as forwards `ref` and only allowed html props to DOM element
 */
const DynamicHtmlTag = React.forwardRef<{}, DynamicHtmlTagProps>((props, ref) => {
  const Base = props.as || props.tag;
  const nextProps = filterPropsToForward(Base, props, ref);

  return React.createElement(Base, nextProps);
});

type TagProps<TTag extends Tag> = (TTag extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[TTag] : {}) &
  (TTag extends React.ComponentType<infer TExtendProps> ? Partial<TExtendProps> : {});

type ThemedOptions<TTag extends Tag, TProps> = {
  tag: TTag;
  defaultTheme?: { [name: string]: ComponentTheme<TProps> };
  defaultProps?: TagProps<TTag> & TProps;
};

export function themed<TProps, TTag extends Tag = Tag>(options: ThemedOptions<TTag, TProps>) {
  let label = '';

  if (options.defaultTheme) {
    const componentKey = Object.keys(options.defaultTheme)[0];
    if (typeof (options.defaultTheme as any)[componentKey] === 'object') {
      label = `${componentKey}`;
    }
  }

  const styledComponentWithThemeProps = styled(DynamicHtmlTag, {
    label, // label is transformed for displayName of styled component,
    // target inserted as css class in resulting element so this could potentially be used as a fallback
    // to style components via traditional css
    target: `themed${
      label
        ? `-${label
            .replace(/([a-z])([A-Z])/g, '$1-$2')
            .replace(/\s+/g, '-')
            .toLowerCase()}`
        : ''
    }`
  })(getThemedCss);

  // default theme is also passed as part of default props
  styledComponentWithThemeProps.defaultProps = {
    ...(options.defaultProps as any),
    defaultTheme: options.defaultTheme,
    tag: options.tag
  };

  return React.memo(styledComponentWithThemeProps) as <TAsTag extends Tag = TTag>(
    props: React.PropsWithChildren<
      {
        as?: TAsTag;
        defaultTheme?: DefaultTheme<TProps>;
      } & Partial<typeof options['defaultProps']> &
        ThemingProps<TProps> &
        TagProps<TAsTag>
    >
  ) => JSX.Element;
}
