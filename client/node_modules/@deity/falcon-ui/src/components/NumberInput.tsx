import React, { useCallback, FC, useState, useEffect, createRef } from 'react';
import { themed, extractThemableProps } from '../theme';
import { Box } from './Box';
import { Icon } from './Icon';

// based on https://github.com/facebook/react/issues/10135#issuecomment-314441175
function triggerChange(element: any, value: any) {
  const valueSetter = Object.getOwnPropertyDescriptor(element, 'value')!.set;
  const prototype = Object.getPrototypeOf(element);
  const prototypeValueSetter = Object.getOwnPropertyDescriptor(prototype, 'value')!.set;

  if (valueSetter && prototypeValueSetter && valueSetter !== prototypeValueSetter) {
    prototypeValueSetter.call(element, value);
  } else if (valueSetter) {
    valueSetter.call(element, value);
  }

  element.dispatchEvent(new Event('change', { bubbles: true }));
}

type NumberInputInnerDOMProps = {
  invalid?: boolean;
  increaseText?: string;
  decreaseText?: string;
  step?: number;
  min?: number;
  max?: number;
} & React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;

class NumberInputInnerDOM extends React.Component<NumberInputInnerDOMProps> {
  inputRef: HTMLInputElement | undefined;

  onChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    this.setState({});
    if (this.props.onChange) {
      this.props.onChange(e);
    }
  };

  mountInputRef = (el: HTMLInputElement) => {
    this.inputRef = el;
    this.setState({});
  };

  stepUp = () => {
    if (!this.inputRef) {
      return;
    }

    const currentValue = +this.inputRef.value;

    let nextValue = currentValue + this.props.step;
    if (nextValue > this.props.max) {
      nextValue = this.props.max;
    }

    triggerChange(this.inputRef, nextValue);
  };

  stepDown = () => {
    if (!this.inputRef) {
      return;
    }

    const currentValue = +this.inputRef.value;

    let nextValue = currentValue - this.props.step;
    if (nextValue < this.props.min) {
      nextValue = this.props.min;
    }

    triggerChange(this.inputRef, nextValue);
  };

  canIncrease() {
    if (!this.inputRef) {
      return false;
    }

    const currentValue = +this.inputRef.value;
    return currentValue < this.props.max;
  }

  canDecrease() {
    if (!this.inputRef) {
      return false;
    }

    const currentValue = +this.inputRef.value;
    return currentValue > this.props.min;
  }

  render() {
    const { className, invalid, disabled, value, min, max, decreaseText, increaseText, ...remaining } = this.props;
    const { themableProps, rest } = extractThemableProps(remaining);
    return (
      <Box {...themableProps} className={className}>
        <button
          type="button"
          onClick={this.stepDown}
          aria-label={decreaseText}
          className="-inner-input-step-down-element"
          disabled={disabled || !this.canDecrease()}
        >
          <Icon src="numberInputDown" fallback="âˆ’" />
        </button>

        <input
          ref={this.mountInputRef}
          disabled={disabled}
          min={min}
          max={max}
          value={value}
          type="number"
          onChange={this.onChange}
          {...rest}
        />

        <button
          type="button"
          onClick={this.stepUp}
          aria-label={increaseText}
          className="-inner-input-step-up-element"
          disabled={disabled || !this.canIncrease()}
        >
          <Icon src="numberInputUp" fallback="+" />
        </button>
      </Box>
    );
  }
}

export const NumberInput = themed({
  tag: NumberInputInnerDOM,

  defaultProps: {
    invalid: false,
    min: Number.NEGATIVE_INFINITY,
    max: Number.POSITIVE_INFINITY,
    step: 1,
    increaseText: 'Increase Quantity',
    decreaseText: 'Decrease Quantity'
  },

  defaultTheme: {
    numberInput: {
      display: 'inline-flex',
      alignItems: 'center',
      height: 'lg',

      css: ({ theme, invalid }) => ({
        input: {
          flex: 'none',
          width: theme.spacing.lg,
          height: '100%',
          appearance: 'none',
          MozAppearance: 'textfield',
          fontStyle: 'inherit',
          textAlign: 'center',
          border: theme.borders.regular,
          borderRadius: theme.borderRadius.medium,
          borderColor: invalid ? theme.colors.error : theme.colors.secondaryDark,
          boxShadow: 'none',
          '::-webkit-outer-spin-button,::-webkit-inner-spin-button': {
            appearance: 'none'
          },
          ':focus': {
            outline: 'none',
            borderColor: invalid ? theme.colors.error : theme.colors.secondary
          }
        },

        '.-inner-input-step-down-element, .-inner-input-step-up-element': {
          height: '100%',
          flex: 'none',
          width: theme.spacing.lg,
          border: 'none',
          outline: 'none',
          appearance: 'none',
          transitionProperty: 'transform, background',
          transitionTimingFunction: theme.easingFunctions.easeIn,
          transitionDuration: theme.transitionDurations.short,
          background: theme.colors.secondaryDark,
          color: theme.colors.secondaryText,
          borderRadius: theme.borderRadius.round,
          fontWeight: theme.fontWeights.bold,
          fontSize: 'inherit',
          cursor: 'pointer',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          transform: 'scale(0.8)',
          lineHeight: 1,
          ':hover': {
            background: theme.colors.secondary
          },
          ':disabled': {
            opacity: '0.5'
          }
        },
        '.-inner-input-step-down-element': {
          marginRight: theme.spacing.xs,
          ':active': {
            transform: 'scale(0.6)'
          }
        },
        '.-inner-input-step-up-element': {
          marginLeft: theme.spacing.xs,
          ':active': {
            transform: 'scale(1)'
          }
        }
      })
    }
  }
});
