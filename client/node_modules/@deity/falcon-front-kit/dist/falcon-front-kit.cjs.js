'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var formik = require('formik');
var falconData = require('@deity/falcon-data');
var falconShopData = require('@deity/falcon-shop-data');
var PropTypes = _interopDefault(require('prop-types'));
var url = require('url');
var reactCookie = require('react-cookie');
var reactRouterDom = require('react-router-dom');
var qs = _interopDefault(require('qs'));
var falconI18n = require('@deity/falcon-i18n');
var reactHelmetAsync = require('react-helmet-async');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/**
 * React hook which returns previous value
 * @param value
 */

const usePrevious = value => {
  const ref = React.useRef();
  React.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
};

/**
 * React hook for keeping component state like `useState`,
 * additionally expose `callback` when state is changed
 * @param initialState
 * @param callback
 */

const useStateCallback = (initialState, callback) => {
  const [state, setState] = React.useState(initialState);
  const previousState = usePrevious(state);
  React.useLayoutEffect(() => {
    if (state !== previousState) {
      callback(state, previousState);
    }
  }, [state, callback, previousState]);
  return [state, setState];
};

const useMounted = () => {
  const isMounted = React.useRef(false); // Changing a ref like this doesn't cause rerenders

  React.useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
};

var _jsxFileName = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Account/SignInFormProvider.tsx";
const SignInFormProvider = props => {
  const {
    onSuccess,
    initialValues,
    mutationOptions
  } = props,
        formikProps = _objectWithoutPropertiesLoose(props, ["onSuccess", "initialValues", "mutationOptions"]);

  const defaultInitialValues = {
    email: '',
    password: ''
  };
  const [signIn] = falconShopData.useSignInMutation();
  const getUserError = falconData.useGetUserError();
  const isMounted = useMounted();
  return /*#__PURE__*/React__default.createElement(formik.Formik, _extends({
    initialStatus: {},
    initialValues: initialValues || defaultInitialValues,
    onSubmit: (values, {
      setSubmitting,
      setStatus
    }) => signIn(Object.assign({
      variables: {
        input: values
      }
    }, mutationOptions || {})).then(({
      data
    }) => {
      if (isMounted.current) {
        setSubmitting(false);
        setStatus({
          data
        });
        return onSuccess && onSuccess(data);
      }
    }).catch(e => {
      const error = getUserError(e);

      if (error.length && isMounted.current) {
        setStatus({
          error
        });
        setSubmitting(false);
      }
    })
  }, formikProps, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 25,
      columnNumber: 5
    }
  }));
};

var _jsxFileName$1 = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Account/SignOutProvider.tsx";
const SignOutProvider = ({
  children
}) => /*#__PURE__*/React__default.createElement(falconShopData.IsAuthenticatedQuery, {
  __source: {
    fileName: _jsxFileName$1,
    lineNumber: 15,
    columnNumber: 3
  }
}, ({
  data: {
    customer
  }
}) => /*#__PURE__*/React__default.createElement(falconShopData.SignOutMutation, {
  __source: {
    fileName: _jsxFileName$1,
    lineNumber: 17,
    columnNumber: 7
  }
}, (signOut, result) => children({
  isSignedIn: !!customer,
  signOut,
  result
})));

var _jsxFileName$2 = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Account/SignUpFormProvider.tsx";
const SignUpFormProvider = props => {
  const {
    onSuccess,
    initialValues,
    mutationOptions
  } = props,
        formikProps = _objectWithoutPropertiesLoose(props, ["onSuccess", "initialValues", "mutationOptions"]);

  const defaultInitialValues = {
    firstname: '',
    lastname: '',
    email: '',
    password: '',
    confirmPassword: '',
    autoSignIn: true
  };
  const [signUp] = falconShopData.useSignUpMutation();
  const getUserError = falconData.useGetUserError();
  const isMounted = useMounted();
  return /*#__PURE__*/React__default.createElement(formik.Formik, _extends({
    initialStatus: {},
    initialValues: initialValues || defaultInitialValues,
    onSubmit: (_ref, {
      setSubmitting,
      setStatus,
      setErrors
    }) => {
      let signUpValues = _objectWithoutPropertiesLoose(_ref, ["confirmPassword"]);

      return signUp(Object.assign({
        variables: {
          input: signUpValues
        }
      }, mutationOptions || {})).then(({
        data
      }) => {
        if (isMounted.current) {
          setSubmitting(false);
          setStatus({
            data
          });
          return onSuccess && onSuccess(data);
        }
      }).catch(e => {
        const error = getUserError(e);

        if (error.length && isMounted.current) {
          setErrors(error.getFieldErrors());
          setStatus({
            error: error.getFormErrors()
          });
          setSubmitting(false);
        }
      });
    }
  }, formikProps, {
    __source: {
      fileName: _jsxFileName$2,
      lineNumber: 33,
      columnNumber: 5
    }
  }));
};

var _jsxFileName$3 = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Account/ForgotPasswordFormProvider.tsx";
const ForgotPasswordFormProvider = props => {
  const {
    onSuccess,
    initialValues,
    mutationOptions
  } = props,
        formikProps = _objectWithoutPropertiesLoose(props, ["onSuccess", "initialValues", "mutationOptions"]);

  const defaultInitialValues = {
    email: ''
  };
  const [requestPasswordReset] = falconShopData.useRequestPasswordResetMutation();
  const getUserError = falconData.useGetUserError();
  const isMounted = useMounted();
  return /*#__PURE__*/React__default.createElement(formik.Formik, _extends({
    initialStatus: {},
    initialValues: initialValues || defaultInitialValues,
    onSubmit: (values, {
      setSubmitting,
      setStatus
    }) => requestPasswordReset(Object.assign({
      variables: {
        input: values
      }
    }, mutationOptions || {})).then(({
      data
    }) => {
      if (isMounted.current) {
        setSubmitting(false);
        setStatus({
          data
        });
        return onSuccess && onSuccess(data);
      }
    }).catch(e => {
      const error = getUserError(e);

      if (error.length && isMounted.current) {
        setStatus({
          error
        });
        setSubmitting(false);
      }
    })
  }, formikProps, {
    __source: {
      fileName: _jsxFileName$3,
      lineNumber: 24,
      columnNumber: 5
    }
  }));
};

var _jsxFileName$4 = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Account/ResetPasswordFormProvider.tsx";
const ResetPasswordFormProvider = props => {
  const {
    onSuccess,
    initialValues,
    mutationOptions
  } = props,
        formikProps = _objectWithoutPropertiesLoose(props, ["onSuccess", "initialValues", "mutationOptions"]);

  const defaultInitialValues = {
    resetToken: '',
    password: ''
  };
  const [resetPassword] = falconShopData.useResetPasswordMutation();
  const getUserError = falconData.useGetUserError();
  const isMounted = useMounted();
  return /*#__PURE__*/React__default.createElement(formik.Formik, _extends({
    initialStatus: {},
    initialValues: initialValues || defaultInitialValues,
    onSubmit: (values, {
      setSubmitting,
      setStatus
    }) => resetPassword(Object.assign({
      variables: {
        input: values
      }
    }, mutationOptions || {})).then(({
      data
    }) => {
      if (isMounted.current) {
        setSubmitting(false);
        setStatus({
          data
        });
        return onSuccess && onSuccess(data);
      }
    }).catch(e => {
      const error = getUserError(e);

      if (error.length && isMounted.current) {
        setStatus({
          error
        });
        setSubmitting(false);
      }
    })
  }, formikProps, {
    __source: {
      fileName: _jsxFileName$4,
      lineNumber: 22,
      columnNumber: 5
    }
  }));
};

var _jsxFileName$5 = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Account/ChangePasswordFormProvider.tsx";
const ChangePasswordFormProvider = props => {
  const {
    onSuccess,
    initialValues,
    mutationOptions
  } = props,
        formikProps = _objectWithoutPropertiesLoose(props, ["onSuccess", "initialValues", "mutationOptions"]);

  const defaultInitialValues = {
    currentPassword: '',
    password: ''
  };
  const [changePasswordMutation] = falconShopData.useChangePasswordMutation();
  const getUserError = falconData.useGetUserError();
  const isMounted = useMounted();
  return /*#__PURE__*/React__default.createElement(formik.Formik, _extends({
    initialStatus: {},
    initialValues: initialValues || defaultInitialValues,
    onSubmit: (values, {
      setSubmitting,
      setStatus
    }) => changePasswordMutation(Object.assign({
      variables: {
        input: values
      }
    }, mutationOptions || {})).then(({
      data
    }) => {
      if (isMounted.current) {
        setSubmitting(false);
        setStatus({
          data
        });
        return onSuccess && onSuccess(data);
      }
    }).catch(e => {
      const error = getUserError(e);

      if (error.length && isMounted.current) {
        setStatus({
          error
        });
        setSubmitting(false);
      }
    })
  }, formikProps, {
    __source: {
      fileName: _jsxFileName$5,
      lineNumber: 22,
      columnNumber: 5
    }
  }));
};

var _jsxFileName$6 = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Account/EditCustomerFormProvider.tsx";
const EditCustomerFormProvider = props => {
  const {
    onSuccess,
    initialValues,
    customer,
    mutationOptions
  } = props,
        formikProps = _objectWithoutPropertiesLoose(props, ["onSuccess", "initialValues", "customer", "mutationOptions"]);

  const defaultInitialValues = {
    websiteId: customer.websiteId,
    email: customer.email,
    firstname: customer.firstname,
    lastname: customer.lastname
  };
  const [editCustomerMutation] = falconShopData.useEditCustomerMutation();
  const getUserError = falconData.useGetUserError();
  const isMounted = useMounted();
  return /*#__PURE__*/React__default.createElement(formik.Formik, _extends({
    initialStatus: {},
    initialValues: initialValues || defaultInitialValues,
    onSubmit: (values, {
      setSubmitting,
      setStatus
    }) => editCustomerMutation(Object.assign({
      variables: {
        input: values
      }
    }, mutationOptions || {})).then(({
      data
    }) => {
      if (isMounted.current) {
        setSubmitting(false);
        setStatus({
          data
        });
        return onSuccess && onSuccess(data);
      }
    }).catch(e => {
      const error = getUserError(e);

      if (error.length && isMounted.current) {
        setStatus({
          error
        });
        setSubmitting(false);
      }
    })
  }, formikProps, {
    __source: {
      fileName: _jsxFileName$6,
      lineNumber: 25,
      columnNumber: 5
    }
  }));
};

var _jsxFileName$7 = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Address/AddAddressFormProvider.tsx";
const AddAddressFormProvider = props => {
  const {
    onSuccess,
    initialValues,
    mutationOptions
  } = props,
        formikProps = _objectWithoutPropertiesLoose(props, ["onSuccess", "initialValues", "mutationOptions"]);

  const defaultInitialValues = {
    firstname: '',
    lastname: '',
    street1: '',
    street2: '',
    postcode: '',
    city: '',
    country: undefined,
    region: undefined,
    company: '',
    telephone: '',
    defaultBilling: false,
    defaultShipping: false
  };
  const [addAddress] = falconShopData.useAddAddressMutation();
  const getUserError = falconData.useGetUserError();
  const isMounted = useMounted();
  return /*#__PURE__*/React__default.createElement(formik.Formik, _extends({
    initialStatus: {},
    initialValues: initialValues || defaultInitialValues,
    onSubmit: (_ref, {
      setSubmitting,
      setStatus
    }) => {
      let {
        street1,
        street2,
        country,
        region
      } = _ref,
          values = _objectWithoutPropertiesLoose(_ref, ["street1", "street2", "country", "region"]);

      return addAddress(Object.assign({
        variables: {
          input: Object.assign({}, values, {
            street: [street1, street2].filter(Boolean),
            countryId: country.id,
            regionId: region ? region.id : undefined
          })
        }
      }, mutationOptions || {})).then(({
        data
      }) => {
        if (isMounted.current) {
          setSubmitting(false);
          setStatus({
            data
          });
          return onSuccess && onSuccess(data);
        }
      }).catch(e => {
        const error = getUserError(e);

        if (error.length && isMounted.current) {
          setStatus({
            error
          });
          setSubmitting(false);
        }
      });
    }
  }, formikProps, {
    __source: {
      fileName: _jsxFileName$7,
      lineNumber: 47,
      columnNumber: 5
    }
  }));
};

var _jsxFileName$8 = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Address/EditAddressFormProvider.tsx";
const EditAddressFormProvider = props => {
  const {
    address,
    onSuccess,
    initialValues,
    mutationOptions
  } = props,
        formikProps = _objectWithoutPropertiesLoose(props, ["address", "onSuccess", "initialValues", "mutationOptions"]);

  const {
    street
  } = address,
        rest = _objectWithoutPropertiesLoose(address, ["__typename", "street"]);

  const defaultInitialValues = Object.assign({
    street1: street.length > 0 ? street[0] : undefined,
    street2: street.length > 1 ? street[1] : undefined
  }, rest);
  const [editAddress] = falconShopData.useEditAddressMutation();
  const getUserError = falconData.useGetUserError();
  const isMounted = useMounted();
  return /*#__PURE__*/React__default.createElement(formik.Formik, _extends({
    initialStatus: {},
    initialValues: initialValues || defaultInitialValues,
    onSubmit: (_ref, {
      setSubmitting,
      setStatus
    }) => {
      let {
        street1,
        street2,
        country,
        region
      } = _ref,
          values = _objectWithoutPropertiesLoose(_ref, ["street1", "street2", "country", "region"]);

      return editAddress(Object.assign({
        variables: {
          input: Object.assign({}, values, {
            id: address.id,
            street: [street1, street2].filter(Boolean),
            countryId: country.id,
            regionId: region ? region.id : undefined
          })
        }
      }, mutationOptions || {})).then(({
        data
      }) => {
        if (isMounted.current) {
          setSubmitting(false);
          setStatus({
            data
          });
          return onSuccess && onSuccess(data);
        }
      }).catch(e => {
        const error = getUserError(e);

        if (error.length && isMounted.current) {
          setStatus({
            error
          });
          setSubmitting(false);
        }
      });
    }
  }, formikProps, {
    __source: {
      fileName: _jsxFileName$8,
      lineNumber: 41,
      columnNumber: 5
    }
  }));
};

/**
 * Determines if the address is custom or already saved in the system
 * @param {Address} address
 */
const isCustomAddress = address => !address || address && !address.id;

/**
 * Returns basic string representation of `Address`
 * @param {Address} address
 */
const addressToString = address => [address.company, `${address.firstname} ${address.lastname}`, address.street && `${address.street.join(' ')}`, `${address.postcode} ${address.city}, ${address.country.code}`].filter(x => x).join(', ');

/**
 * This method expands flatten Apollo cache value into a nested object
 * @param {object} state Apollo state object
 * @param {string} stateKey Apollo state key
 * @returns {object} Expanded object
 */
function apolloStateToObject(state, stateKey) {
  const result = Object.assign({}, state[stateKey]);
  Object.keys(result).forEach(key => {
    const value = result[key];

    if (!value) {
      return;
    }

    if (Array.isArray(value)) {
      result[key] = value.filter(item => item && typeof item === 'object' && item.generated && item.id).map(item => apolloStateToObject(state, item.id));
    } else if (typeof value === 'object') {
      if (value.generated && value.id) {
        result[key] = apolloStateToObject(state, value.id);
      } else if (value.type === 'json') {
        result[key] = value.json;
      }
    }
  });
  return result;
}

/** Defines basic checkout steps */
const CheckoutStep = {
  email: 'email',
  shippingAddress: 'shippingAddress',
  billingAddress: 'billingAddress',
  shippingMethod: 'shippingMethod',
  paymentMethod: 'paymentMethod',
  placeOrder: 'placeOrder'
};
/** Defines default checkout steps order */

const CheckoutFlow = [CheckoutStep.email, CheckoutStep.shippingAddress, CheckoutStep.billingAddress, CheckoutStep.shippingMethod, CheckoutStep.paymentMethod, CheckoutStep.placeOrder];

const CheckoutContext = /*#__PURE__*/React__default.createContext({});

const calculateCheckoutStepFactory = stepsOrder => (values, step) => {
  const stepFromValues = stepsOrder.find(x => !values[x]) || stepsOrder[stepsOrder.length - 1];

  if (step && step in CheckoutStep) {
    const stepIndex = stepsOrder.findIndex(x => x === step);
    const stepIndexFromValues = stepsOrder.findIndex(x => x === stepFromValues);

    if (stepIndex < stepIndexFromValues) {
      return step;
    }
  }

  return stepFromValues;
};

var _jsxFileName$9 = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Checkout/CheckoutProvider.tsx";

const getNextPossibleCheckoutStepFactory = stepsOrder => step => {
  const currentStepIndex = stepsOrder.findIndex(x => x === step);
  return currentStepIndex < stepsOrder.length ? stepsOrder[currentStepIndex + 1] : undefined;
};

const isObject = value => {
  return Object.prototype.toString.call(value) === '[object Object]';
};
const browseAndCleanObject = (data, prop) => {
  return Object.keys(data).reduce((object, key) => {
    if (key !== prop) {
      if (isObject(data[key])) {
        object[key] = browseAndCleanObject(data[key], prop);
      } else {
        object[key] = data[key];
      }
    }

    return object;
  }, {});
};
/**
 * Strip `__typename` key from object keys
 * @param initialData
 * @returns {CheckoutValues}
 */

const stripTypenames = initialData => {
  return browseAndCleanObject(initialData, '__typename');
};
const CheckoutProvider = props => {
  const {
    initialValues = {},
    billingSameAsShipping,
    stepsOrder,
    autoStepForward,
    onValueChanged,
    onStepChanged
  } = props; // eslint-disable-next-line react-hooks/exhaustive-deps

  const calculateStep = React.useCallback(props.calculateStep(stepsOrder), [stepsOrder]);

  const canSetStep = (values, step) => calculateStep(values, step) === step;

  const [step, setStep] = useStateCallback(calculateStep(initialValues, props.step), (cStep, pStep) => {
    onStepChanged(cStep, pStep, {
      isForwardNavigation: stepsOrder.findIndex(x => x === cStep) > stepsOrder.findIndex(x => x === pStep)
    });
  }); // eslint-disable-next-line react-hooks/exhaustive-deps

  const getNextStep = React.useCallback(getNextPossibleCheckoutStepFactory(stepsOrder), [stepsOrder]);

  const stepForward = () => {
    const next = getNextStep(step);
    setStep(next);
    return next;
  };

  const isBoolean = val => typeof val === 'boolean';

  const initialState = stripTypenames(initialValues);
  let initialBillingSameAsShipping = false; // First we check the initial state

  if (isBoolean(initialValues.billingSameAsShipping)) {
    initialBillingSameAsShipping = initialValues.billingSameAsShipping;
  } else if (isBoolean(billingSameAsShipping)) {
    initialBillingSameAsShipping = billingSameAsShipping;
  }

  const [isLoading, setLoading] = React.useState(false);
  const [isBillingSameAsShipping, setBillingSameAsShipping] = React.useState(initialBillingSameAsShipping);
  const [result, setResult] = React.useState();
  const [forceStep, setForceStep] = React.useState();
  const [values, setValues] = useStateCallback(Object.assign({}, initialState), newValues => {
    onValueChanged();

    if (autoStepForward) {
      const newStep = forceStep || calculateStep(newValues);
      setStep(newStep);
    }
  });
  React.useLayoutEffect(() => {
    if (props.step && props.step !== step) {
      setStep(calculateStep(values, props.step));
    }
  }, [calculateStep, props.step, setStep, step, values, forceStep]);

  const setEmail = email => setValues(x => Object.assign({}, x, {
    email
  }));

  const setShippingAddress = shippingAddress => {
    if (!isBillingSameAsShipping) {
      // Force the customer to review their billing address
      setForceStep('billingAddress');
    }

    setValues(x => Object.assign({}, x, {
      shippingAddress,
      billingAddress: isBillingSameAsShipping ? shippingAddress : x.billingAddress,
      shippingMethod: undefined,
      paymentMethod: undefined
    }));
  };

  const setBillingAddress = billingAddress => {
    setForceStep(null);
    setValues(x => Object.assign({}, x, {
      shippingAddress: isBillingSameAsShipping ? billingAddress : x.shippingAddress,
      billingAddress,
      shippingMethod: undefined,
      paymentMethod: undefined
    }));
  };

  const setShippingMethod = shippingMethod => setValues(x => Object.assign({}, x, {
    shippingMethod,
    paymentMethod: undefined
  }));

  const setPaymentMethod = paymentMethod => setValues(x => Object.assign({}, x, {
    paymentMethod
  }));
  /**
   * Allows to override OrderData values, useful when order was placed with some overrides and state needs to be synchronized
   * @param order
   */


  const setOrderData = order => {
    if (order) {
      setValues(Object.assign({}, order));
    }
  };

  return /*#__PURE__*/React__default.createElement(CheckoutContext.Provider, {
    value: {
      stepsOrder,
      step,
      nextStep: getNextStep(step),
      calculateStep,
      stepForward,
      setStep,
      canSetStep,
      isLoading,
      setLoading,
      isBillingSameAsShipping,
      setBillingSameAsShipping,
      values,
      setEmail,
      setShippingAddress,
      setBillingAddress,
      setShippingMethod,
      setPaymentMethod,
      setOrderData,
      result,
      setResult
    },
    __source: {
      fileName: _jsxFileName$9,
      lineNumber: 173,
      columnNumber: 5
    }
  }, props.children);
};
CheckoutProvider.defaultProps = {
  stepsOrder: CheckoutFlow,
  autoStepForward: true,
  billingSameAsShipping: false,
  initialValues: {},
  onValueChanged: () => {},
  onStepChanged: () => {},
  calculateStep: calculateCheckoutStepFactory
};

const useCheckout = () => React.useContext(CheckoutContext);
const Checkout = ({
  children
}) => {
  const checkout = useCheckout();
  return children(Object.assign({}, checkout));
};

const addressToCheckoutAddressInput = checkoutAddress => {
  const {
    region,
    country
  } = checkoutAddress,
        rest = _objectWithoutPropertiesLoose(checkoutAddress, ["region", "country"]);

  return Object.assign({}, rest, {
    countryId: country.id,
    regionId: region ? region.id : undefined
  });
};

const useSetShippingAddress = () => {
  const [address, setAddress] = React.useState();
  const {
    isLoading,
    setLoading,
    setShippingAddress,
    isBillingSameAsShipping
  } = useCheckout();
  const [mutation, result] = falconShopData.useSetShippingAddressMutation({
    onCompleted: data => {
      if (data) {
        setShippingAddress(address);
        setLoading(false);
      }
    }
  });

  if (result.loading !== isLoading) {
    setLoading(result.loading);
  }

  return [React.useCallback(async (input, options = {}) => {
    setLoading(true);
    setAddress(input);
    return mutation(Object.assign({}, options, {
      variables: {
        input: {
          address: addressToCheckoutAddressInput(input),
          billingSameAsShipping: isBillingSameAsShipping
        }
      }
    }));
  }, [isBillingSameAsShipping, mutation, setLoading]), result];
};
const SetShippingAddress = ({
  children
}) => {
  return children(...useSetShippingAddress());
};

var _jsxFileName$a = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Checkout/SetCheckoutAddressFormProvider.tsx";
const INITIAL_VALUES = {
  email: '',
  firstname: '',
  lastname: '',
  street1: '',
  street2: '',
  postcode: '',
  city: '',
  country: undefined,
  region: undefined,
  company: '',
  telephone: '',
  saveInAddressBook: false
};
const SetCheckoutAddressFormProvider = props => {
  const {
    initialValues,
    setAddress,
    address,
    onSuccess,
    mutationOptions
  } = props,
        formikProps = _objectWithoutPropertiesLoose(props, ["initialValues", "setAddress", "address", "onSuccess", "mutationOptions"]);

  const isMounted = useMounted();
  const getUserError = falconData.useGetUserError();
  return /*#__PURE__*/React__default.createElement(formik.Formik, _extends({
    initialStatus: {},
    initialValues: address ? checkoutAddressToSetCheckoutAddressFormValues(address) : initialValues,
    enableReinitialize: true,
    onSubmit: (_ref, {
      setSubmitting,
      setStatus
    }) => {
      let {
        street1,
        street2
      } = _ref,
          values = _objectWithoutPropertiesLoose(_ref, ["street1", "street2"]);

      return setAddress(Object.assign({}, values, {
        street: [street1, street2].filter(Boolean)
      }), mutationOptions).then(() => {
        const successData = Object.assign({}, values, {
          street: [street1, street2].filter(Boolean)
        });

        if (isMounted.current) {
          setStatus({
            data: successData
          });
          setSubmitting(false);
        }

        return onSuccess && onSuccess(successData);
      }).catch(e => {
        const error = getUserError(e);

        if (error.length && isMounted.current) {
          setStatus({
            error
          });
          setSubmitting(false);
        }
      });
    }
  }, formikProps, {
    __source: {
      fileName: _jsxFileName$a,
      lineNumber: 52,
      columnNumber: 5
    }
  }));
};
SetCheckoutAddressFormProvider.defaultProps = {
  // eslint-disable-next-line react/default-props-match-prop-types
  initialValues: Object.assign({}, INITIAL_VALUES)
};
SetCheckoutAddressFormProvider.propTypes = {
  setAddress: PropTypes.func.isRequired
};
const checkoutAddressToSetCheckoutAddressFormValues = address => {
  if (!address) {
    return INITIAL_VALUES;
  }

  const _typename$address = Object.assign({
    __typename: undefined
  }, address),
        {
    street
  } = _typename$address,
        rest = _objectWithoutPropertiesLoose(_typename$address, ["__typename", "street"]);

  return Object.assign({
    street1: street.length > 0 ? street[0] : undefined,
    street2: street.length > 1 ? street[1] : undefined
  }, rest);
};

const useSetBillingAddress = () => {
  const [address, setAddress] = React.useState();
  const {
    isLoading,
    setLoading,
    setBillingAddress,
    isBillingSameAsShipping
  } = useCheckout();
  const [mutation, result] = falconShopData.useSetBillingAddressMutation({
    onCompleted: data => {
      if (data) {
        setBillingAddress(address);
        setLoading(false);
      }
    }
  });

  if (result.loading !== isLoading) {
    setLoading(result.loading);
  }

  return [React.useCallback(async (input, options) => {
    setLoading(true);
    setAddress(input);
    return mutation(Object.assign({}, options, {
      variables: {
        input: {
          address: addressToCheckoutAddressInput(input),
          billingSameAsShipping: isBillingSameAsShipping
        }
      }
    }));
  }, [isBillingSameAsShipping, setLoading, mutation]), result];
};
const SetBillingAddress = ({
  children
}) => {
  return children(...useSetBillingAddress());
};

/**
 * Map `ShippingMethod` to `CheckoutDetailsInput`
 * @param shipping
 */
const shippingMethodToCheckoutDetailsInput = shipping => {
  const {
    method,
    provider
  } = shipping,
        data = _objectWithoutPropertiesLoose(shipping, ["method", "provider", "title"]);

  return {
    provider,
    method,
    data
  };
};

const useSetShippingMethod = () => {
  const [state, setState] = React.useState();
  const {
    isLoading,
    setLoading,
    setShippingMethod
  } = useCheckout();
  const [mutation, result] = falconShopData.useSetShippingMethodMutation({
    onCompleted: data => {
      if (data) {
        setShippingMethod(state);
        setLoading(false);
      }
    }
  });

  if (result.loading !== isLoading) {
    setLoading(result.loading);
  }

  return [React.useCallback(async (input, options) => {
    setLoading(true);
    setState(input);
    return mutation(Object.assign({}, options, {
      variables: {
        input: shippingMethodToCheckoutDetailsInput(input)
      }
    }));
  }, [mutation, setLoading]), result];
};
const SetShippingMethod = ({
  children
}) => {
  return children(...useSetShippingMethod());
};

const useSetPaymentMethod = () => {
  const {
    isLoading,
    setLoading,
    setPaymentMethod
  } = useCheckout();
  const [mutation, result] = falconShopData.useSetPaymentMethodMutation();

  if (result.loading !== isLoading) {
    setLoading(result.loading);
  }

  return [React.useCallback(async (input, options) => {
    setLoading(true);
    const response = await mutation(Object.assign({}, options, {
      variables: {
        input: {
          provider: input.provider,
          method: input.method,
          data: input.data
        }
      }
    }));
    const {
      data
    } = response;
    setLoading(false);
    if (data && data.setPaymentMethod) setPaymentMethod(data.setPaymentMethod);
    return response;
  }, [mutation, setLoading, setPaymentMethod]), result];
};
const SetPaymentMethod = ({
  children
}) => {
  return children(...useSetPaymentMethod());
};

const paymentMethodToCheckoutDetailsInput = payment => {
  return {
    provider: payment.provider,
    method: payment.method,
    data: payment.data
  };
};

const usePlaceOrder = () => {
  const {
    isLoading,
    setLoading,
    setOrderData,
    setResult
  } = useCheckout();
  const [mutation, result] = falconShopData.usePlaceOrderMutation({
    onCompleted: data => {
      if (data) {
        setResult(data.placeOrder);
        setLoading(false);
      }
    }
  });

  if (result.loading !== isLoading) {
    setLoading(result.loading);
  }

  return [React.useCallback(async (input, options) => {
    setLoading(true);
    setOrderData(input);
    return mutation(Object.assign({}, options || {}, {
      variables: {
        input: {
          email: input.email,
          billingAddress: addressToCheckoutAddressInput(input.billingAddress),
          shippingAddress: addressToCheckoutAddressInput(input.shippingAddress),
          shippingMethod: shippingMethodToCheckoutDetailsInput(input.shippingMethod),
          paymentMethod: input.paymentMethod ? paymentMethodToCheckoutDetailsInput(input.paymentMethod) : null
        }
      }
    }));
  }, [setLoading, setOrderData, mutation]), result];
};
const PlaceOrder = ({
  children
}) => {
  return children(...usePlaceOrder());
};

const GET_CONFIG = {
  "kind": "Document",
  "definitions": [{
    "kind": "OperationDefinition",
    "operation": "query",
    "name": {
      "kind": "Name",
      "value": "Config"
    },
    "variableDefinitions": [],
    "directives": [],
    "selectionSet": {
      "kind": "SelectionSet",
      "selections": [{
        "kind": "Field",
        "name": {
          "kind": "Name",
          "value": "config"
        },
        "arguments": [],
        "directives": [{
          "kind": "Directive",
          "name": {
            "kind": "Name",
            "value": "client"
          },
          "arguments": []
        }]
      }]
    }
  }],
  "loc": {
    "start": 0,
    "end": 41,
    "source": {
      "body": "\n  query Config {\n    config @client\n  }\n",
      "name": "GraphQL request",
      "locationOffset": {
        "line": 1,
        "column": 1
      }
    }
  }
};
class ConfigQuery extends falconData.Query {}
ConfigQuery.defaultProps = {
  query: GET_CONFIG
};
const GET_CONFIG_KEY = {
  "kind": "Document",
  "definitions": [{
    "kind": "OperationDefinition",
    "operation": "query",
    "name": {
      "kind": "Name",
      "value": "GetConfigKey"
    },
    "variableDefinitions": [{
      "kind": "VariableDefinition",
      "variable": {
        "kind": "Variable",
        "name": {
          "kind": "Name",
          "value": "key"
        }
      },
      "type": {
        "kind": "NamedType",
        "name": {
          "kind": "Name",
          "value": "String"
        }
      },
      "directives": []
    }],
    "directives": [],
    "selectionSet": {
      "kind": "SelectionSet",
      "selections": [{
        "kind": "Field",
        "name": {
          "kind": "Name",
          "value": "configKey"
        },
        "arguments": [{
          "kind": "Argument",
          "name": {
            "kind": "Name",
            "value": "key"
          },
          "value": {
            "kind": "Variable",
            "name": {
              "kind": "Name",
              "value": "key"
            }
          }
        }],
        "directives": [{
          "kind": "Directive",
          "name": {
            "kind": "Name",
            "value": "client"
          },
          "arguments": []
        }]
      }]
    }
  }],
  "loc": {
    "start": 0,
    "end": 75,
    "source": {
      "body": "\n  query GetConfigKey($key: String) {\n    configKey(key: $key) @client\n  }\n",
      "name": "GraphQL request",
      "locationOffset": {
        "line": 1,
        "column": 1
      }
    }
  }
};
class ConfigKeyQuery extends falconData.Query {}
ConfigKeyQuery.defaultProps = {
  query: GET_CONFIG_KEY
};

const getClientConfig = (apolloState, key) => {
  return key ? apolloState.ROOT_QUERY.config[key] : apolloState.ROOT_QUERY.config;
};
const getClientConfigResolver = (_source, {
  key
}, context) => {
  return getClientConfig(context.cache.data.data, key);
};

/** @see import { useCookie } from 'react-cookie' */

/** Falcon Client side scope data - the selected scope based on current context (url, cookie, etc) */

/** Falcon Client side scopes configuration */

/**
 * TODO: instead of using `Cookies` and `CookieInterface` we should be able to provide single and consistent interface
 */

/** extracts Falcon Client side Scope configuration
 * @param falconScopeConfig
 * @param context
 */
const tryGetFalconScopeConfig = (config, context, getter) => {
  let defaultScopeId = config.defaultId;
  let selectedScope;

  if (!config.scopes.length) {
    throw new Error('Server returned empty list of scopes. Please configure the server to return at least one scope!');
  }

  try {
    selectedScope = getter(config, context);
  } catch (error) {
    console.warn(`Can not get FalconScope! Trying to get the default FalconScope instead.`);
    selectedScope = config.scopes.find(x => x.id === config.defaultId);

    if (!selectedScope) {
      console.warn(`The default scope with id="${config.defaultId}" was not returned from the server. Using the first scope from the list as default (id="${config.scopes[0].id}")`);
      selectedScope = config.scopes[0];
      defaultScopeId = selectedScope.id;
    }
  }

  return {
    available: config.scopes,
    defaultId: defaultScopeId,
    currentId: selectedScope.id,
    pathBasename: selectedScope.pathBasename
  };
};
/** sets Falcon Client side Scope configuration */

const GeoLocationContext = /*#__PURE__*/React__default.createContext({});

var _jsxFileName$b = "/home/vsts/work/1/s/packages/falcon-front-kit/src/GeoLocation/GeoLocationProvider.tsx";
const GeoLocationProvider = props => {
  const {
    country,
    region,
    city,
    postCode,
    children
  } = props;
  return /*#__PURE__*/React__default.createElement(GeoLocationContext.Provider, {
    value: {
      country,
      region,
      city,
      postCode
    },
    __source: {
      fileName: _jsxFileName$b,
      lineNumber: 10,
      columnNumber: 5
    }
  }, children);
};
const useGeoLocation = () => React.useContext(GeoLocationContext);
const GeoLocation = ({
  children
}) => children(Object.assign({}, useGeoLocation()));

const FalconScopeContext = /*#__PURE__*/React__default.createContext({});

var _jsxFileName$c = "/home/vsts/work/1/s/packages/falcon-front-kit/src/FalconScope/FalconScopeProvider.tsx";
const FalconScopeProvider = props => {
  const {
    available,
    currentId,
    defaultId,
    pathBasename: basename,
    set,
    children
  } = props;
  const isMounted = useMounted();
  const [allCookies, setCookie, removeCookie] = reactCookie.useCookies();

  const getById = id => available.find(x => x.id === id);

  const [current, setCurrent] = React.useState(getById(currentId));
  const [pathBasename, setPathBasename] = React.useState(basename);
  const geoLocation = useGeoLocation();

  const setNewScope = id => {
    const newFalconScope = available.find(x => x.id === id);

    if (newFalconScope === undefined || current.id === id) {
      return;
    }

    const location = url.parse(window.location.href);
    set(id, {
      scopes: available,
      defaultId
    }, {
      cookies: {
        all: allCookies,
        remove: removeCookie,
        set: setCookie
      },
      url: location,
      geoLocation
    });

    if (isMounted.current) {
      setCurrent(getById(id));
    }
  };

  return /*#__PURE__*/React__default.createElement(FalconScopeContext.Provider, {
    value: {
      available,
      current,
      default: getById(defaultId),
      pathBasename,
      set: setNewScope
    },
    __source: {
      fileName: _jsxFileName$c,
      lineNumber: 47,
      columnNumber: 5
    }
  }, children);
};
const useFalconScope = () => React.useContext(FalconScopeContext);
const FalconScope = ({
  children
}) => children(Object.assign({}, useFalconScope()));

/**
 * provide FalconClient side Scope configuration from URL
 * @param config
 * @param context
 */
const getFalconScopeFromURL = (config, context) => {
  const {
    scopes,
    defaultId
  } = config;
  const {
    url
  } = context;
  const scope = scopes.find(x => url.pathname.startsWith(`/${x.id}`));

  if (scope) {
    return {
      id: scope.id,
      pathBasename: scope.id === defaultId ? '' : scope.id
    };
  }

  return {
    id: scopes.find(x => x.id === defaultId).id
  };
};
const setFalconScopeToURL = (falconScopeId, config, context) => {
  const {
    defaultId
  } = config;

  if (defaultId === falconScopeId) {
    window.location.pathname = `/`;
  } else {
    window.location.pathname = `/${falconScopeId}`;
  }

  return undefined;
};

const FALCON_SCOPE_COOKIE_NAME = 'falcon-scope';
/**
 * provide FalconClient side Scope configuration from cookie
 * @param config
 * @param context
 */

const getFalconScopeFromCookie = (config, context) => {
  const {
    scopes,
    defaultId
  } = config;
  const {
    cookies
  } = context;
  const falconScopeId = cookies.get(FALCON_SCOPE_COOKIE_NAME);
  const id = falconScopeId || defaultId;
  return {
    id: scopes.find(x => x.id === id).id
  };
};
const setFalconScopeToCookie = (falconScopeId, config, context) => {
  const {
    defaultId
  } = config;
  const {
    cookies
  } = context;

  if (falconScopeId === defaultId) {
    cookies.remove(FALCON_SCOPE_COOKIE_NAME);
  } else {
    cookies.set(FALCON_SCOPE_COOKIE_NAME, falconScopeId);
  }

  if (typeof window !== 'undefined') {
    setTimeout(() => window.location.reload(), 1);
  }

  return {
    id: falconScopeId
  };
};

const getDateTimeFormatter = (locales, dateTimeFormatOptions) => new Intl.DateTimeFormat(locales.filter(x => x), Object.assign({}, dateTimeFormatOptions));

function dateTimeFormatFactory(localeCodes, options) {
  const memoizedFormatter = getDateTimeFormatter([options.locale, ...localeCodes], options);
  /**
   * DateTime Format (memoized)
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {number | string | Date} value value to format
   * @returns {string} formatted value
   */

  function dateTimeFormat(value, overrides) {
    return overrides ? getDateTimeFormatter([overrides.locale, options.locale, ...localeCodes], Object.assign({}, options, overrides)).format(new Date(value)) : memoizedFormatter.format(new Date(value));
  }

  return dateTimeFormat;
}

var _jsxFileName$d = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Locale/LocaleContext.tsx";
const LocaleContext = /*#__PURE__*/React__default.createContext({});
const LocaleProvider = props => {
  const {
    locale,
    localeFallback,
    dateTimeFormatOptions = {}
  } = props;
  const falconScope = useFalconScope();
  const value = locale || falconScope.current.languageTag;
  const valueFallback = localeFallback || falconScope.default.languageTag;
  const dateTimeFormat = dateTimeFormatFactory([dateTimeFormatOptions.locale, value, valueFallback], Object.assign({}, props.dateTimeFormatOptions));
  return /*#__PURE__*/React__default.createElement(LocaleContext.Provider, {
    value: {
      locale: value,
      localeFallback: valueFallback,
      dateTimeFormat
    },
    __source: {
      fileName: _jsxFileName$d,
      lineNumber: 29,
      columnNumber: 5
    }
  }, props.children);
};
const useLocale = () => React.useContext(LocaleContext);
const Locale = ({
  children
}) => children(Object.assign({}, useLocale()));

const getPriceFormatter = (locales, numberFormatOptions) => new Intl.NumberFormat(locales.filter(x => x), Object.assign({}, numberFormatOptions, {
  style: 'currency'
}));

/**
 * Price Format function factory based on Intl api
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat
 * @param {string[]} localeCodes localization codes
 * @param {PriceFormatOptions} options formatting options
 * @returns {ReturnType<typeof priceFormatFactory>} price formatter
 */
function priceFormatFactory(localeCodes, options) {
  const memoizedFormatter = getPriceFormatter([options.locale, ...localeCodes], options);
  /**
   * Price Format (memoized)
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat
   * @param {number} value value to format
   * @returns {string} formatted value
   */

  function priceFormat(value, overrides) {
    return overrides ? getPriceFormatter([overrides.locale, options.locale, ...localeCodes], Object.assign({}, options, overrides)).format(value) : memoizedFormatter.format(value);
  }

  return priceFormat;
}

var _jsxFileName$e = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Currency/CurrencyContext.tsx";
const CurrencyContext = /*#__PURE__*/React__default.createContext({});

/**
 * Depends on `FalconScopeProvider` and `LocaleProvider`
 * @internal
 */
const CurrencyProvider = (_ref) => {
  let {
    priceFormatOptions = {},
    children
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, ["priceFormatOptions", "children"]);

  const scope = useFalconScope();
  const {
    locale,
    localeFallback
  } = useLocale();
  const currency = rest.currency || scope.current.currency;
  return /*#__PURE__*/React__default.createElement(CurrencyContext.Provider, {
    value: {
      currency,
      priceFormat: priceFormatFactory([priceFormatOptions.locale, locale, localeFallback], Object.assign({
        currency
      }, priceFormatOptions))
    },
    __source: {
      fileName: _jsxFileName$e,
      lineNumber: 29,
      columnNumber: 5
    }
  }, children);
};
const useCurrency = () => React.useContext(CurrencyContext);
const Currency = ({
  children
}) => children(Object.assign({}, useCurrency()));

/**
 * Helper to get the currency label including symbol e.g. $ USD
 * @param {string} currency currency code e.g. USD
 * @param {string} locale lacel code e.g. en or en-GB
 * @returns {string} currency label
 */
function getCurrencyLabel(currency, locale) {
  const localeFormatter = new Intl.NumberFormat(locale, {
    currency,
    style: 'currency'
  });
  const localeData = localeFormatter.formatToParts();
  const currencyArray = localeData.filter(part => part.type === 'currency'); // For some locales the currency code is the same as the currency symbol. In this case we only return the code

  if (currencyArray.length && currencyArray[0].value !== currency) {
    return `${currencyArray[0].value} ${currency}`;
  }

  return currency;
}

const RenderRouterProps = props => {
  const {
    match,
    location,
    history,
    children
  } = props;
  return children({
    match,
    location,
    history
  });
};

const Router = reactRouterDom.withRouter(RenderRouterProps);

var _jsxFileName$f = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Router/Redirect.tsx";
const DynamicRedirect = ({
  match,
  location,
  staticContext
}) => {
  const {
    path,
    status = 301
  } = match.params;

  if (staticContext) {
    staticContext.status = status;
  }

  return /*#__PURE__*/React__default.createElement(reactRouterDom.Redirect, {
    from: location.pathname,
    to: path,
    __source: {
      fileName: _jsxFileName$f,
      lineNumber: 9,
      columnNumber: 10
    }
  });
};

var _jsxFileName$g = "/home/vsts/work/1/s/packages/falcon-front-kit/src/DynamicRoute/DynamicRoute.tsx";
const DynamicRoute = props => {
  const {
    components,
    notFound: NotFound
  } = props;
  return /*#__PURE__*/React__default.createElement(Router, {
    __source: {
      fileName: _jsxFileName$g,
      lineNumber: 19,
      columnNumber: 5
    }
  }, router => {
    const location = props.location || router.location;
    const {
      pathname: path
    } = location;
    return /*#__PURE__*/React__default.createElement(falconData.UrlQuery, {
      variables: {
        path
      },
      __source: {
        fileName: _jsxFileName$g,
        lineNumber: 25,
        columnNumber: 11
      }
    }, ({
      data: {
        url
      }
    }) => {
      if (!url) {
        return /*#__PURE__*/React__default.createElement(NotFound, {
          location: location,
          __source: {
            fileName: _jsxFileName$g,
            lineNumber: 28,
            columnNumber: 24
          }
        });
      }

      if (!('type' in url)) {
        return /*#__PURE__*/React__default.createElement(reactRouterDom.Redirect, {
          to: url.path,
          __source: {
            fileName: _jsxFileName$g,
            lineNumber: 32,
            columnNumber: 24
          }
        });
      }

      const Component = components[url.type];

      if (!Component) {
        throw new Error(`[DynamicRoute]: Please register component for '${url.type}' content type!`);
      }

      return /*#__PURE__*/React__default.createElement(Component, _extends({}, url, {
        __source: {
          fileName: _jsxFileName$g,
          lineNumber: 40,
          columnNumber: 22
        }
      }));
    });
  });
};
DynamicRoute.propTypes = {
  location: PropTypes.any,
  components: PropTypes.objectOf(PropTypes.oneOfType([PropTypes.object, PropTypes.func]).isRequired).isRequired,
  notFound: PropTypes.func.isRequired
};

const findRouteElement = (children, location, type) => {
  let element;
  let match; // We use React.Children.forEach instead of React.Children.toArray().find()
  // here because toArray adds keys to all child elements and we do not want
  // to trigger an unmount/remount for two <Route>s that render the same
  // component at different URLs.

  React__default.Children.forEach(children, child => {
    if (match == null && /*#__PURE__*/React__default.isValidElement(child)) {
      const path = child.props.path || child.props.from;

      if (path) {
        match = reactRouterDom.matchPath(location.pathname, Object.assign({}, child.props, {
          path
        }));
      } else {
        // eslint-disable-next-line
        if (child.props.type && type) {
          match = reactRouterDom.matchPath(type, Object.assign({}, child.props, {
            path: child.props.type
          }));
        }
      } // eslint-disable-next-line


      element = child;
    }
  });
  return [match, element];
};

/**
 * Determines if for provided location is handled via Route component which requires to fetch resource metadata first
 * @param children set of Route components to search for matching
 * @param location location to which Route component needs to be matched
 */
const isResourceMetaRequired = (children, location) => {
  let result = false;
  let match; // We use React.Children.forEach instead of React.Children.toArray().find()
  // here because toArray adds keys to all child elements and we do not want
  // to trigger an unmount/remount for two <Route>s that render the same
  // component at different URLs.

  React__default.Children.forEach(children, child => {
    if (!result && match == null && /*#__PURE__*/React__default.isValidElement(child)) {
      const path = child.props.path || child.props.from;

      if (path) {
        match = reactRouterDom.matchPath(location.pathname, Object.assign({}, child.props, {
          path
        }));
      } else {
        result = !!child.props.type;
      }
    }
  });
  return result;
};

var _jsxFileName$h = "/home/vsts/work/1/s/packages/falcon-front-kit/src/DynamicRoute/SwitchDynamicUrl.tsx";
const RouteElementRenderer = /*#__PURE__*/React__default.memo(({
  element,
  location,
  match,
  additionalParams = {}
}) => {
  if (!match) {
    return null;
  }

  match.params = Object.assign({}, match.params, additionalParams);
  return /*#__PURE__*/React__default.cloneElement(element, {
    location,
    computedMatch: match
  });
});

function getUrlType(urlResult) {
  // eslint-disable-next-line no-underscore-dangle
  return urlResult.__typename === 'ResourceMeta' ? urlResult.type : 'redirect';
}
/**
 * `react-router` `Switch` component which is able to handle dynamically resolved components.
 * It works with `Url` query.
 * @example
 * <SwitchDynamicURL>
    <Route exact path="/" component={Home} />
    <Route exact type="shop-product" component={Product} />
    <p>not Found</p>
  </SwitchDynamicURL>
 * @param {SwitchDynamicURLProps} props
 */


const SwitchDynamicURL = props => {
  const contextMatch = reactRouterDom.useRouteMatch();
  const contextLocation = reactRouterDom.useLocation();
  const location = props.location || contextLocation;
  const [previousLocation, setPreviousLocation] = React.useState(location);
  const [previousResourceMeta, setPreviousResourceMeta] = React.useState(undefined);

  if (isResourceMetaRequired(props.children, location) === false) {
    if (location !== previousLocation) {
      setPreviousLocation(location);
    }

    const [match, element] = findRouteElement(props.children, location);
    return /*#__PURE__*/React__default.createElement(RouteElementRenderer, {
      element: element,
      location: location,
      match: match || contextMatch,
      __source: {
        fileName: _jsxFileName$h,
        lineNumber: 67,
        columnNumber: 12
      }
    });
  }

  return /*#__PURE__*/React__default.createElement(falconData.UrlQuery, {
    variables: {
      path: location.pathname + location.search
    },
    passLoading: true,
    onCompleted: result => {
      if (result) setPreviousResourceMeta(result.url);
    },
    __source: {
      fileName: _jsxFileName$h,
      lineNumber: 71,
      columnNumber: 5
    }
  }, ({
    data,
    error,
    loading
  }) => {
    if (loading) {
      const [previousMatch, previousElement] = previousLocation ? findRouteElement(props.children, previousLocation, previousResourceMeta && getUrlType(previousResourceMeta)) : [undefined, undefined];

      if (previousMatch) {
        return /*#__PURE__*/React__default.createElement(RouteElementRenderer, {
          element: previousElement,
          location: previousLocation,
          match: previousMatch,
          additionalParams: previousResourceMeta,
          __source: {
            fileName: _jsxFileName$h,
            lineNumber: 92,
            columnNumber: 15
          }
        });
      } // looks like this is unreachable code actually


      return /*#__PURE__*/React__default.createElement(falconData.Loader, {
        variant: "overlay",
        __source: {
          fileName: _jsxFileName$h,
          lineNumber: 102,
          columnNumber: 18
        }
      });
    }

    if (error) {
      return /*#__PURE__*/React__default.createElement(falconData.OperationError, _extends({}, error, {
        __source: {
          fileName: _jsxFileName$h,
          lineNumber: 106,
          columnNumber: 18
        }
      }));
    }

    if (loading === false && data && previousLocation !== location) {
      setPreviousLocation(location);
    }

    const [match, element] = findRouteElement(props.children, location, (data == null ? void 0 : data.url) && getUrlType(data.url));
    return /*#__PURE__*/React__default.createElement(RouteElementRenderer, {
      element: element,
      location: location,
      match: match || contextMatch,
      additionalParams: data.url,
      __source: {
        fileName: _jsxFileName$h,
        lineNumber: 114,
        columnNumber: 11
      }
    });
  });
};

/**
 * TTI measures the time from Navigation Start until the page's resources are loaded and the main thread is idle for at least 5 seconds
 */
class EnsureTTI extends React__default.Component {
  constructor(props) {
    super(props);

    this.forceReady = () => {
      if (!this.state.isReady) {
        this.setState(x => Object.assign({}, x, {
          isReady: true
        }));
      }
    };

    this.state = {
      isReady: false,
      setTimeoutHandlerId: undefined,
      requestIdleHandlerId: undefined
    };
  }

  componentDidMount() {
    const {
      timeout
    } = this.props; // set isReady flag after timeout

    const setTimeoutHandlerId = window.setTimeout(() => {
      if (this.state.isReady) {
        return;
      }

      if ('requestIdleCallback' in window) {
        // @ts-ignore
        const requestIdleHandlerId = window.requestIdleCallback(this.forceReady);
        return this.setState(x => Object.assign({}, x, {
          requestIdleHandlerId
        }));
      }

      return this.forceReady();
    }, timeout); // eslint-disable-next-line

    this.setState(x => Object.assign({}, x, {
      setTimeoutHandlerId
    }));
  }

  componentDidUpdate() {
    if (this.props.forceReady) {
      this.forceReady();
    }
  }

  componentWillUnmount() {
    const {
      setTimeoutHandlerId,
      requestIdleHandlerId
    } = this.state;
    window.clearTimeout(setTimeoutHandlerId);

    if ('cancelIdleCallback' in window && requestIdleHandlerId !== undefined) {
      // @ts-ignore
      window.cancelIdleCallback(requestIdleHandlerId);
    }
  }
  /** Sets isReady even before `timeout` */


  render() {
    return this.props.children({
      isReady: this.state.isReady,
      forceReady: this.forceReady
    });
  }

}
EnsureTTI.propTypes = {
  timeout: PropTypes.number,
  children: PropTypes.func.isRequired
};
EnsureTTI.defaultProps = {
  timeout: 6000
};

const aggregationToFilterData = aggregation => ({
  field: aggregation.field,
  title: aggregation.title,
  type: aggregation.type,
  options: aggregation.buckets,
  value: []
});

function searchStateFromURL(url) {
  const parts = qs.parse(url.replace('?', ''));
  const searchState = {};

  if (parts.q) {
    searchState.term = parts.q;
  }

  if (parts.p) {
    searchState.pagination = {
      page: parseInt(parts.p, 10),
      perPage: parseInt(parts.pp, 10)
    };
  }

  if (parts.sort) {
    const [field, direction] = parts.sort.split(':');
    searchState.sort = {
      field,
      direction: direction
    };
  }

  if (parts.filters) {
    const names = Object.keys(parts.filters);
    searchState.filters = [];

    for (let i = 0; i < names.length; i++) {
      const [field, operator] = names[i].split(':');
      searchState.filters.push({
        field,
        operator: operator || falconShopData.FilterOperator.equals,
        value: parts.filters[names[i]].split(',')
      });
    }
  }

  return searchState;
}
function searchStateToURL(state) {
  const {
    term,
    filters,
    sort,
    pagination
  } = state;
  const parts = {};

  if (filters) {
    parts.filters = {};

    for (let i = 0; i < filters.length; i++) {
      const filter = filters[i];
      const name = filter.operator === falconShopData.FilterOperator.equals ? filter.field : `${filter.field}:${filter.operator}`;
      parts.filters[name] = filter.value.join(',');
    }
  }

  if (sort && sort.field && sort.direction) {
    parts.sort = `${sort.field}:${sort.direction}`;
  }

  if (pagination) {
    if (pagination.perPage) {
      parts.pp = pagination.perPage.toString();
    }

    if (pagination.page && pagination.page > 1) {
      parts.p = pagination.page.toString();
    }
  }

  if (term) {
    parts.q = term; // eslint-disable-line id-length
  }

  return qs.stringify(parts, {
    encode: false
  });
}

/**
 * Determines if two `SortOrderValue` are equal from a value perspective
 * @param item1
 * @param item2
 */
const areSortOrderInputsEqual = (item1, item2) => !!item1 && !!item2 && item1.field === item2.field && item1.direction === item2.direction;

const SearchContext = /*#__PURE__*/React__default.createContext({
  state: {
    filters: []
  },
  setTerm: () => {},
  setFilter: () => {},
  removeFilter: () => {},
  removeFilters: () => {},
  setSortOrder: () => {},
  setPagination: () => {}
});

var _jsxFileName$i = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Search/SearchProvider.tsx";
class SearchProviderInner extends React__default.Component {
  constructor(props) {
    super(props);

    this.setFilter = (field, value, operator = falconShopData.FilterOperator.equals) => {
      let filters = [...this.state.filters];

      if (value.length === 0) {
        filters = filters.filter(x => x.field !== field);
      } else {
        const filterIndex = filters.findIndex(x => x.field === field);

        if (filterIndex >= 0) {
          filters[filterIndex] = Object.assign({}, filters[filterIndex], {
            value,
            operator
          });
        } else {
          filters.push({
            field,
            value,
            operator
          });
        }
      }

      this.updateURL(Object.assign({}, this.state, {
        filters,
        // reset pagination on filters change - go back to the 1st page
        pagination: this.setPaginationToFirstPage()
      }));
    };

    this.setPaginationToFirstPage = () => {
      return Object.assign({}, this.state.pagination, {
        page: 1
      });
    };

    this.setSortOrder = sort => {
      this.updateURL(Object.assign({}, this.state, {
        sort: this.sortOrderExists(sort) ? sort : this.defaultSortOrder,
        pagination: this.setPaginationToFirstPage()
      }));
    };

    this.setPagination = pagination => this.updateURL(Object.assign({}, this.state, {
      pagination
    }));

    this.setTerm = term => this.updateURL(Object.assign({}, this.state, {
      term,
      // reset pagination on search term change - go back to the 1st page
      pagination: this.setPaginationToFirstPage()
    }));

    this.sortOrderExists = sort => this.props.sortOrders.some(x => !x && !sort || areSortOrderInputsEqual(x, sort));

    this.removeFilters = () => this.updateURL(Object.assign({}, this.state, {
      filters: [],
      pagination: this.setPaginationToFirstPage()
    }));

    this.stateToSerialize = state => {
      const stateToSerialize = Object.assign({}, state);
      return stateToSerialize;
    };

    this.restoreStateFromURL = location => {
      const state = this.getStateFromURL(location); // state created from URL might be empty so we have to make sure that all the items are correctly
      // removed from current state - setting undefined for non existing value will do the trick

      Object.keys(this.state).forEach(key => {
        if (!(key in state)) {
          state[key] = undefined;
        }
      });
      this.setState(state);
    };

    this.historyUnlisten = () => {};

    this.state = this.getStateFromURL(props.location);
  }

  componentDidMount() {
    this.historyUnlisten = this.props.history.listen(this.restoreStateFromURL);
  }

  componentWillUnmount() {
    this.historyUnlisten();
  }

  get defaultSortOrder() {
    const {
      defaultSortOrder,
      sortOrders
    } = this.props;

    if (defaultSortOrder) {
      return defaultSortOrder;
    }

    if (sortOrders.some(x => !x)) {
      return undefined;
    }

    return sortOrders[0];
  }

  getStateFromURL(location) {
    const _ref = this.props.searchStateFromURL(location.search),
          {
      sort,
      filters
    } = _ref,
          rest = _objectWithoutPropertiesLoose(_ref, ["sort", "filters"]);

    return Object.assign({}, rest, {
      filters: Array.isArray(filters) ? filters : [],
      sort: sort && this.sortOrderExists(sort) ? sort : undefined
    });
  }

  updateURL(state) {
    const queryString = this.props.searchStateToURL(state);
    this.props.history.push(`${this.props.location.pathname}?${queryString}`);
  }

  render() {
    return /*#__PURE__*/React__default.createElement(SearchContext.Provider, {
      value: {
        state: Object.assign({}, this.state),
        setFilter: this.setFilter,
        removeFilter: x => this.setFilter(x, []),
        removeFilters: this.removeFilters,
        setSortOrder: this.setSortOrder,
        setPagination: this.setPagination,
        setTerm: this.setTerm
      },
      __source: {
        fileName: _jsxFileName$i,
        lineNumber: 143,
        columnNumber: 7
      }
    }, this.props.children);
  }

}
SearchProviderInner.defaultProps = {
  searchStateFromURL,
  searchStateToURL,
  filters: []
};

const SearchProviderWithSortOrders = (_ref2) => {
  let rest = Object.assign({}, _ref2);
  return /*#__PURE__*/React__default.createElement(falconShopData.BackendConfigQuery, {
    __source: {
      fileName: _jsxFileName$i,
      lineNumber: 165,
      columnNumber: 3
    }
  }, ({
    data: {
      backendConfig
    }
  }) => /*#__PURE__*/React__default.createElement(SearchProviderInner, _extends({}, rest, {
    sortOrders: backendConfig.shop.sortOrderList.map(x => x.value),
    __source: {
      fileName: _jsxFileName$i,
      lineNumber: 167,
      columnNumber: 7
    }
  })));
}; // wrap everything in router so SearchProviderWithSortOrders has access to history and location


const SearchProvider = reactRouterDom.withRouter(SearchProviderWithSortOrders);

const SearchConsumer = SearchContext.Consumer;

const useSearchContext = () => React.useContext(SearchContext);

var _jsxFileName$j = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Filters/FiltersDataProvider.tsx";
const getFiltersData = (filters, aggregations = [], filterData = []) => [...[], ...aggregations.map(x => aggregationToFilterData(x)), ...filterData].map(x => {
  const selected = filters.find(filter => filter.field === x.field);
  return Object.assign({}, x, {
    value: selected ? selected.value : []
  });
});
const getSelectedFilterOptionsFor = (data, field) => {
  const filter = data.find(x => x.field === field);

  if (filter === undefined) {
    return [];
  }

  const {
    options,
    value
  } = filter;
  return options.filter(option => value.some(x => x === option.value));
};
const FiltersDataProvider = ({
  children,
  aggregations,
  data
}) => /*#__PURE__*/React__default.createElement(SearchConsumer, {
  __source: {
    fileName: _jsxFileName$j,
    lineNumber: 48,
    columnNumber: 3
  }
}, ({
  state: {
    filters
  },
  setFilter,
  removeFilter,
  removeFilters
}) => children({
  filters: getFiltersData(filters, aggregations || [], data || []),
  anySelected: filters.length > 0,
  getSelectedFilterOptionsFor,
  setFilter,
  removeFilter,
  removeFilters
}));

const FormContext = /*#__PURE__*/React__default.createContext({});
const useFormContext = () => React.useContext(FormContext);

const capitalize = x => x.charAt(0).toUpperCase() + x.slice(1);

function isI18nValidationError(error) {
  return typeof error === 'object' && error.errorI18nId !== undefined;
}
const getErrorI18nId = (error, name, formI18nId) => {
  if (formI18nId) {
    return [`${formI18nId}.${name}Field${capitalize(error)}`, `formError.${error}`];
  }

  return `formError.${error}`;
};
const fieldValidator = (validators = [], {
  name,
  label,
  formI18nId,
  t
}) => value => {
  for (let i = 0; i < validators.length; i++) {
    const result = validators[i]({
      name,
      label,
      value,
      formI18nId,
      t
    });

    if (isI18nValidationError(result)) {
      const {
        errorI18nId: error
      } = result,
            errorProps = _objectWithoutPropertiesLoose(result, ["errorI18nId"]);

      return t(getErrorI18nId(error, name, formI18nId), Object.assign({
        name,
        value
      }, errorProps, {
        label: label || capitalize(name)
      }));
    }

    if (result !== undefined) {
      return result;
    }
  }

  return undefined;
};

var _jsxFileName$k = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Forms/Field.tsx";

const translateIfExists = (t, key) => key ? t(key, {
  defaultValue: ''
}) : undefined;

const LABEL_SUFFIX = 'FieldLabel';
const PLACEHOLDER_SUFFIX = 'FieldPlaceholder';
const getLabelI18nId = (formI18nId, fieldName) => `${formI18nId}.${fieldName}${LABEL_SUFFIX}`;
const getPlaceholderI18nId = (formI18nId, fieldName) => `${formI18nId}.${fieldName}${PLACEHOLDER_SUFFIX}`;
const Field = /*#__PURE__*/React__default.memo(props => {
  const {
    name,
    label,
    placeholder,
    validate,
    children,
    fast
  } = props,
        restProps = _objectWithoutPropertiesLoose(props, ["name", "label", "placeholder", "validate", "children", "fast"]);

  const {
    t
  } = falconI18n.useI18n();
  const {
    id: formId,
    i18nId: formI18nId
  } = useFormContext();
  const i18nIds = formI18nId ? {
    label: getLabelI18nId(formI18nId, name),
    placeholder: getPlaceholderI18nId(formI18nId, name)
  } : {};
  const fieldLabel = label || translateIfExists(t, i18nIds.label);
  const fieldPlaceholder = placeholder || translateIfExists(t, i18nIds.placeholder);
  const validateCallback = React.useCallback(() => fieldValidator(validate, {
    name,
    label: fieldLabel,
    formI18nId,
    t
  }), [validate, name, fieldLabel, formI18nId, t]);

  if (!children) {
    return null;
  }

  const FieldComponent = fast ? formik.FastField : formik.Field;
  return /*#__PURE__*/React__default.createElement(FieldComponent, {
    name: name,
    validate: validateCallback(),
    __source: {
      fileName: _jsxFileName$k,
      lineNumber: 70,
      columnNumber: 5
    }
  }, ({
    form,
    field,
    meta: {
      touched,
      error
    }
  }) => children({
    form: Object.assign({}, form, {
      id: formId
    }),
    field: Object.assign({
      id: `${formId}-${name}`
    }, restProps, field, {
      placeholder: fieldPlaceholder,
      invalid: !!touched && !!error
    }),
    error,
    label: fieldLabel,
    i18nIds
  }));
});

var _jsxFileName$l = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Forms/Form.tsx";
const Form = (_ref) => {
  let {
    i18nId,
    autoSubmit
  } = _ref,
      restProps = _objectWithoutPropertiesLoose(_ref, ["i18nId", "autoSubmit"]);

  const {
    submitCount,
    isValid,
    submitForm,
    isSubmitting
  } = formik.useFormikContext();

  if (autoSubmit) {
    if (!isSubmitting && submitCount === 0 && isValid) {
      submitForm();
      return null;
    }

    if (isSubmitting && submitCount <= 1) {
      return null;
    }
  }

  return /*#__PURE__*/React__default.createElement(FormContext.Provider, {
    value: {
      id: restProps.id,
      name: restProps.name,
      i18nId
    },
    __source: {
      fileName: _jsxFileName$l,
      lineNumber: 25,
      columnNumber: 5
    }
  }, /*#__PURE__*/React__default.createElement(formik.Form, _extends({}, restProps, {
    __source: {
      fileName: _jsxFileName$l,
      lineNumber: 32,
      columnNumber: 7
    }
  })));
};
Form.propTypes = {
  id: PropTypes.string.isRequired
};

const VALID_EMAIL_REGEX = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
const VALID_PASSWORD_REGEX = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/;

const isValueProvided = x => x !== '' && x !== undefined && x !== null && x !== false && x !== 'placeholder' || Array.isArray(x) && x.length;

const requiredValidator = ({
  value
}) => {
  if (!isValueProvided(value)) {
    return {
      errorI18nId: 'required'
    };
  }

  return undefined;
};
function isCheckedValidator(checkedValue = true) {
  return ({
    value
  }) => {
    if (!isValueProvided(value) || value !== checkedValue) {
      return {
        errorI18nId: 'isNotChecked'
      };
    }

    return undefined;
  };
}
const emailValidator = ({
  value
}) => {
  if (isValueProvided(value) && !VALID_EMAIL_REGEX.test(value.toLowerCase())) {
    return {
      errorI18nId: 'invalid'
    };
  }

  return undefined;
};
const passwordValidator = ({
  value
}) => {
  if (isValueProvided(value) && !VALID_PASSWORD_REGEX.test(value)) {
    return {
      errorI18nId: 'uncomplexPassword'
    };
  }

  return undefined;
};
function confirmPasswordValidator(password = '') {
  return ({
    value
  }) => {
    if (password !== '' && isValueProvided(value)) {
      return password !== value ? {
        errorI18nId: 'differentPasswords'
      } : undefined;
    }

    return undefined;
  };
}
function lengthValidator(min = 0, max) {
  if (max && max < min) {
    throw new Error(`value of 'min' can not be greater than 'max'!`);
  }

  return ({
    value
  }) => {
    if (isValueProvided(value) && typeof value === 'string') {
      // Ignore newlines when counting characters
      const {
        length
      } = value.replace(/\n/g, '');

      if (length < min) {
        return Object.assign({
          errorI18nId: 'tooShort',
          min
        }, max ? {
          max
        } : {});
      }

      if (max && length > max) {
        return {
          errorI18nId: 'tooLong',
          min,
          max
        };
      }
    }

    return undefined;
  };
}
function numLinesValidator(min = 0, max) {
  if (max && max < min) {
    throw new Error(`value of 'min' can not be greater than 'max'!`);
  }

  return ({
    value
  }) => {
    if (isValueProvided(value) && typeof value === 'string') {
      const numLines = value.split('\n').length;

      if (numLines < min) {
        return {
          errorI18nId: 'tooLittleLines',
          min
        };
      }

      if (numLines > max) {
        return {
          errorI18nId: 'tooManyLines',
          max
        };
      }
    }

    return undefined;
  };
}
const numberValidator = ({
  value
}) => {
  if (isValueProvided(value)) {
    if (value.toString() !== parseFloat(value).toString()) {
      return {
        errorI18nId: 'notAnNumber'
      };
    }
  }

  return undefined;
};
const integerValidator = ({
  value
}) => {
  if (isValueProvided(value)) {
    if (value.toString() !== parseInt(value, 10).toString()) {
      return {
        errorI18nId: 'notInteger'
      };
    }
  }

  return undefined;
};
function rangeValidator(min, max) {
  if (max !== undefined && max < min) {
    throw new Error(`value of 'min' can not be greater than 'max'!`);
  }

  return ({
    value
  }) => {
    value = parseInt(value.toString(), 10);

    if (isValueProvided(value) && typeof value === 'number') {
      if (value < min) {
        return Object.assign({
          errorI18nId: 'belowRange',
          min
        }, max ? {
          max
        } : {});
      }

      if (max && value > max) {
        return {
          errorI18nId: 'aboveRange',
          min,
          max
        };
      }
    }

    return undefined;
  };
}
function dateRangeValidator(min, max, dateTimeFormat) {
  const minDate = min && new Date(min);
  const maxDate = max && new Date(max);
  const formattedMinDate = (dateTimeFormat == null ? void 0 : dateTimeFormat(minDate)) || minDate.toISOString().split('T')[0];
  const formattedMaxDate = (dateTimeFormat == null ? void 0 : dateTimeFormat(maxDate)) || maxDate.toISOString().split('T')[0];

  if (maxDate && maxDate < minDate) {
    throw new Error(`value of 'min' can not be earlier than 'max'!`);
  }

  return ({
    value
  }) => {
    if (isValueProvided(value)) {
      const valueDate = new Date(value);

      if (minDate && valueDate < minDate) {
        return {
          errorI18nId: 'belowDateRange',
          min: formattedMinDate
        };
      }

      if (maxDate && valueDate > maxDate) {
        return {
          errorI18nId: 'aboveDateRange',
          max: formattedMaxDate
        };
      }
    }

    return undefined;
  };
}

/**
 * Provides default value validators based on HTML input type
 * @see https://www.w3schools.com/html/html_form_input_types.asp
 * @param input
 */
function getDefaultInputValidators(input) {
  const {
    type,
    required,
    validate
  } = input;
  const anyValidatorsDefined = !!validate;
  const result = anyValidatorsDefined ? validate : [];

  if (required) {
    result.unshift(requiredValidator);
  }

  if (anyValidatorsDefined) {
    return result;
  }

  switch (type) {
    case 'password':
      result.push(lengthValidator(8), passwordValidator);
      break;

    case 'email':
      result.push(emailValidator);
      break;

    case 'text':
      {
        const {
          min = 0,
          max
        } = input;
        result.push(lengthValidator(parseInt(min.toString(), 10), max ? parseInt(max.toString(), 10) : undefined));
      }
      break;

    case 'number':
      {
        const {
          min = Number.MIN_SAFE_INTEGER,
          max = Number.MAX_SAFE_INTEGER
        } = input;
        result.push(rangeValidator(parseInt(min.toString(), 10), parseInt(max.toString(), 10)));
      }
      break;

    default:
      break;
  }

  return result;
}

var _jsxFileName$m = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Forms/Submit.tsx";
const Submit = (_ref) => {
  let {
    children
  } = _ref,
      restProps = _objectWithoutPropertiesLoose(_ref, ["children"]);

  const {
    t
  } = falconI18n.useI18n();
  const formik$1 = formik.useFormikContext();

  if (!children) {
    return null;
  }

  return /*#__PURE__*/React__default.createElement(FormContext.Consumer, {
    __source: {
      fileName: _jsxFileName$m,
      lineNumber: 31,
      columnNumber: 5
    }
  }, ({
    id: formId,
    i18nId: formI18nId
  }) => {
    const valueId = `${formI18nId}.submitButton`;
    return children({
      form: Object.assign({}, formik$1, {
        id: formId
      }),
      submit: Object.assign({
        value: t(valueId)
      }, restProps),
      i18nIds: {
        value: valueId
      }
    });
  });
};

const canUseIntesectionObserver = () => {
  var _window, _window$IntersectionO, _window2, _window2$Intersection;

  return typeof window !== 'undefined' && 'IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in ((_window = window) == null ? void 0 : (_window$IntersectionO = _window.IntersectionObserverEntry) == null ? void 0 : _window$IntersectionO.prototype) && 'isIntersecting' in ((_window2 = window) == null ? void 0 : (_window2$Intersection = _window2.IntersectionObserverEntry) == null ? void 0 : _window2$Intersection.prototype);
};

class NetworkStatus extends React__default.Component {
  constructor(props) {
    super(props);
    this.updateOnLineStatus = this.updateOnLineStatus.bind(this);
    this.state = {
      isOnline: true
    };
  }

  componentDidMount() {
    window.addEventListener('online', this.updateOnLineStatus);
    window.addEventListener('offline', this.updateOnLineStatus); // run detection logic when component mounts as React 16 optimizes too much and doesn't
    // re-render even when SSR html doesn't match client-side
    // @see https://github.com/facebook/react/issues/10591

    this.updateOnLineStatus();
  }

  componentWillUnmount() {
    window.removeEventListener('online', this.updateOnLineStatus);
    window.removeEventListener('offline', this.updateOnLineStatus);
  }

  updateOnLineStatus() {
    const {
      navigator
    } = window;
    const online = navigator && navigator.onLine;

    if (this.state.isOnline === online) {
      return;
    }

    this.setState({
      isOnline: online
    });
  }

  render() {
    const {
      children
    } = this.props;
    const {
      isOnline
    } = this.state;
    return children({
      isOnline
    });
  }

}

const productOptionsToForm = options => options.reduce((result, option) => {
  const values = Array.isArray(option.values) && option.values.length ? option.values : [];
  const defaultValue = values.find(x => x.isDefault);
  return Object.assign({}, result, {
    [option.id]: option.defaultValue || defaultValue && defaultValue.id || undefined
  });
}, {});
const formProductOptionsToInput = options => Object.entries(options).filter(x => x[1] !== undefined).map(item => ({
  id: parseInt(item[0], 10),
  value: item[1]
}));

var _jsxFileName$n = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Product/AddToCartFormProvider.tsx";
const AddToCartFormProvider = props => {
  const {
    onSuccess,
    initialValues,
    quantity,
    product,
    mutationOptions
  } = props,
        formikProps = _objectWithoutPropertiesLoose(props, ["onSuccess", "initialValues", "quantity", "product", "mutationOptions"]);

  const defaultInitialValues = {
    qty: quantity,
    options: productOptionsToForm(product.options || []),
    bundleOptions: product.bundleOptions || []
  };
  const [addToCart] = falconShopData.useAddToCartMutation();
  const getUserError = falconData.useGetUserError();
  const isMounted = useMounted();
  return /*#__PURE__*/React__default.createElement(formik.Formik, _extends({
    initialStatus: {},
    initialValues: initialValues || defaultInitialValues,
    onSubmit: (values, {
      setSubmitting,
      setStatus
    }) => addToCart(Object.assign({
      variables: {
        input: {
          sku: product.sku,
          qty: parseInt(values.qty.toString(), 10),
          options: formProductOptionsToInput(values.options),
          bundleOptions: undefined // values.bundleOptions as any - TODO: add appropriate mapper

        }
      }
    }, mutationOptions || {})).then(({
      data
    }) => {
      if (isMounted.current) {
        setSubmitting(false);
        setStatus({
          data
        });
        return onSuccess && onSuccess(data);
      }
    }).catch(e => {
      const error = getUserError(e);

      if (error.length && isMounted.current) {
        setStatus({
          error
        });
        setSubmitting(false);
      }
    })
  }, formikProps, {
    __source: {
      fileName: _jsxFileName$n,
      lineNumber: 35,
      columnNumber: 5
    }
  }));
};

var _jsxFileName$o = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Routes/OnlyUnauthenticatedRoute.tsx";
class OnlyUnauthenticatedRoute extends React__default.Component {
  render() {
    const _this$props = this.props,
          {
      component,
      redirectTo
    } = _this$props,
          rest = _objectWithoutPropertiesLoose(_this$props, ["component", "redirectTo"]);

    const Component = component;
    return /*#__PURE__*/React__default.createElement(reactRouterDom.Route, _extends({}, rest, {
      render: props => /*#__PURE__*/React__default.createElement(falconShopData.IsAuthenticatedQuery, {
        passLoading: true,
        __source: {
          fileName: _jsxFileName$o,
          lineNumber: 30,
          columnNumber: 11
        }
      }, ({
        data,
        loading
      }) => {
        if (loading) {
          // we can not render anything until we get know if the customer is authenticated or not
          return /*#__PURE__*/React__default.createElement(falconData.Loader, {
            __source: {
              fileName: _jsxFileName$o,
              lineNumber: 34,
              columnNumber: 24
            }
          });
        }

        if (data.customer) {
          return /*#__PURE__*/React__default.createElement(reactRouterDom.Redirect, {
            to: {
              pathname: redirectTo
            },
            __source: {
              fileName: _jsxFileName$o,
              lineNumber: 38,
              columnNumber: 24
            }
          });
        }

        return /*#__PURE__*/React__default.createElement(Component, _extends({}, props, {
          __source: {
            fileName: _jsxFileName$o,
            lineNumber: 41,
            columnNumber: 22
          }
        }));
      }),
      __source: {
        fileName: _jsxFileName$o,
        lineNumber: 27,
        columnNumber: 7
      }
    }));
  }

}
OnlyUnauthenticatedRoute.propTypes = Object.assign({}, reactRouterDom.Route.propTypes, {
  redirectTo: PropTypes.string
});
OnlyUnauthenticatedRoute.defaultProps = {
  redirectTo: '/'
};

var _jsxFileName$p = "/home/vsts/work/1/s/packages/falcon-front-kit/src/Routes/ProtectedRoute.tsx";
class ProtectedRoute extends React__default.Component {
  render() {
    const _this$props = this.props,
          {
      component,
      redirectTo
    } = _this$props,
          rest = _objectWithoutPropertiesLoose(_this$props, ["component", "redirectTo"]);

    const Component = component;
    return /*#__PURE__*/React__default.createElement(reactRouterDom.Route, _extends({}, rest, {
      render: props => /*#__PURE__*/React__default.createElement(falconShopData.IsAuthenticatedQuery, {
        passLoading: true,
        __source: {
          fileName: _jsxFileName$p,
          lineNumber: 30,
          columnNumber: 11
        }
      }, ({
        data,
        loading
      }) => {
        if (loading) {
          // we can not render anything until we get know if the customer is authenticated or not
          return /*#__PURE__*/React__default.createElement(falconData.Loader, {
            __source: {
              fileName: _jsxFileName$p,
              lineNumber: 34,
              columnNumber: 24
            }
          });
        }

        if (data.customer) {
          return /*#__PURE__*/React__default.createElement(Component, _extends({}, props, {
            __source: {
              fileName: _jsxFileName$p,
              lineNumber: 38,
              columnNumber: 24
            }
          }));
        }

        const {
          location
        } = props;
        const {
          pathname,
          search
        } = location;
        const hasRedirectToQueryPart = redirectTo.indexOf('?') > -1;
        const query = new URLSearchParams(hasRedirectToQueryPart ? redirectTo.substring(redirectTo.indexOf('?') + 1) : '');
        query.append('next', `${pathname}${search}`);
        return /*#__PURE__*/React__default.createElement(reactRouterDom.Redirect, {
          to: {
            pathname: hasRedirectToQueryPart ? redirectTo.substring(0, redirectTo.indexOf('?')) : redirectTo,
            search: `?${query}`,
            state: {
              nextLocation: location
            }
          },
          __source: {
            fileName: _jsxFileName$p,
            lineNumber: 51,
            columnNumber: 17
          }
        });
      }),
      __source: {
        fileName: _jsxFileName$p,
        lineNumber: 27,
        columnNumber: 7
      }
    }));
  }

}
ProtectedRoute.propTypes = Object.assign({}, reactRouterDom.Route.propTypes, {
  redirectTo: PropTypes.string
});
ProtectedRoute.defaultProps = {
  redirectTo: '/sign-in'
};

const SidebarContainerContext = /*#__PURE__*/React__default.createContext({});

var _jsxFileName$q = "/home/vsts/work/1/s/packages/falcon-front-kit/src/SidebarContainer/SidebarContainerProvider.tsx";
const SidebarContainerProvider = props => {
  const {
    children
  } = props;
  const [isOpen, setIsOpen] = React.useState(false);
  const [content, setContent] = React.useState(undefined);

  const open = (type, params, side) => {
    setContent({
      type,
      params,
      side
    });
    setIsOpen(true);
  };

  const close = () => {
    setIsOpen(false);
  };

  return /*#__PURE__*/React__default.createElement(SidebarContainerContext.Provider, {
    value: {
      isOpen,
      content,
      open,
      close
    },
    __source: {
      fileName: _jsxFileName$q,
      lineNumber: 21,
      columnNumber: 5
    }
  }, children);
};
const useSidebarContainer = () => React.useContext(SidebarContainerContext);
const SidebarContainer = ({
  children
}) => children(Object.assign({}, useSidebarContainer()));

class ScrollToTopInner extends React__default.Component {
  componentDidUpdate(prevProps) {
    const {
      ignoreHash,
      location
    } = this.props;
    const {
      pathname,
      hash
    } = location;
    const {
      pathname: prevPathname,
      hash: prevHash
    } = prevProps.location;

    if (pathname !== prevPathname || ignoreHash && hash !== prevHash) {
      window.scrollTo(0, 0);
    }
  }

  render() {
    const {
      children
    } = this.props;
    return children || null;
  }

}

ScrollToTopInner.defaultProps = {
  ignoreHash: false
};
const ScrollToTop = reactRouterDom.withRouter(ScrollToTopInner);

var _jsxFileName$r = "/home/vsts/work/1/s/packages/falcon-front-kit/src/SEO/SEO.tsx";
const SEO = ({
  title,
  meta
}) => {
  const {
    title: metaTitle,
    description,
    keywords
  } = meta;
  return /*#__PURE__*/React__default.createElement(reactHelmetAsync.Helmet, {
    __source: {
      fileName: _jsxFileName$r,
      lineNumber: 14,
      columnNumber: 5
    }
  }, /*#__PURE__*/React__default.createElement("title", {
    __source: {
      fileName: _jsxFileName$r,
      lineNumber: 15,
      columnNumber: 7
    }
  }, metaTitle || title), description && /*#__PURE__*/React__default.createElement("meta", {
    name: "description",
    content: description,
    __source: {
      fileName: _jsxFileName$r,
      lineNumber: 16,
      columnNumber: 23
    }
  }), keywords && /*#__PURE__*/React__default.createElement("meta", {
    name: "keywords",
    content: keywords,
    __source: {
      fileName: _jsxFileName$r,
      lineNumber: 17,
      columnNumber: 20
    }
  }));
};
SEO.propTypes = {
  title: PropTypes.string.isRequired,
  meta: PropTypes.shape({
    title: PropTypes.string,
    description: PropTypes.string,
    keywords: PropTypes.string
  })
};
SEO.defaultProps = {
  meta: {}
};

var _jsxFileName$s = "/home/vsts/work/1/s/packages/falcon-front-kit/src/SortOrder/SortOrderPickerProvider.tsx";
const SortOrderPickerProvider = ({
  children
}) => /*#__PURE__*/React__default.createElement(falconShopData.BackendConfigQuery, {
  __source: {
    fileName: _jsxFileName$s,
    lineNumber: 17,
    columnNumber: 3
  }
}, ({
  data: {
    backendConfig
  }
}) => {
  const {
    sortOrderList
  } = backendConfig.shop;
  return /*#__PURE__*/React__default.createElement(SearchConsumer, {
    __source: {
      fileName: _jsxFileName$s,
      lineNumber: 22,
      columnNumber: 9
    }
  }, ({
    state: {
      sort
    },
    setSortOrder
  }) => children({
    items: sortOrderList,
    value: sortOrderList.find(x => !x.value && !sort || areSortOrderInputsEqual(x.value, sort)),
    onChange: x => setSortOrder(x.value)
  }));
});

const InBrowserOnly = ({
  children,
  fallback
}) => {
  const [showChildren, setShowChildren] = React.useState(false);
  React.useEffect(() => {
    setShowChildren(true);
  }, []);
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, showChildren ? children : fallback || null);
};
InBrowserOnly.propTypes = {
  children: PropTypes.node.isRequired
};

/**
 * Two step wizard that can be used for any kind of "select and configure" process (like payments, shipping etc...)
 * @internal
 * @example
 * <TwoStepWizard>
 *   {({ selectedOption, selectOption }) => {
 *     // nothing selected - render picker
 *     if (!selectedOption) {
 *       return (
 *         <ul>
 *           <li>
 *             <label htmlFor="foo">
 *               <input id="foo" type="radio" name="wizard" value="foo" onChange={() => selectOption('foo')} />
 *               <span>Foo</span>
 *             </label>
 *           </li>
 *           <li>
 *             <label htmlFor="bar">
 *               <input id="bar" type="radio" name="wizard" value="bar" onChange={() => selectOption('bar')} />
 *               <span>Bar</span>
 *             </label>
 *           </li>
 *         </ul>
 *       );
 *     }
 *
 *     if (selectedOption === 'foo') {
 *       // render component for 'foo'
 *       return <div>configure Foo</div>;
 *     }
 *
 *     if (selectedOption === 'bar') {
 *       // render component for 'bar'
 *       return <div>configure Bar</div>;
 *     }
 *
 *     return null;
 *   }}
 * </TwoStepWizard>
 */
const TwoStepWizard = ({
  initialState,
  children
}) => {
  const [selectedOption, setOption] = React.useState(initialState);

  const selectOption = value => setOption(value);

  const resetOption = () => setOption(null);

  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, children({
    selectedOption,
    selectOption,
    resetOption
  }));
};

exports.AddAddressFormProvider = AddAddressFormProvider;
exports.AddToCartFormProvider = AddToCartFormProvider;
exports.ChangePasswordFormProvider = ChangePasswordFormProvider;
exports.Checkout = Checkout;
exports.CheckoutFlow = CheckoutFlow;
exports.CheckoutProvider = CheckoutProvider;
exports.CheckoutStep = CheckoutStep;
exports.ConfigKeyQuery = ConfigKeyQuery;
exports.ConfigQuery = ConfigQuery;
exports.Currency = Currency;
exports.CurrencyProvider = CurrencyProvider;
exports.DynamicRedirect = DynamicRedirect;
exports.DynamicRoute = DynamicRoute;
exports.EditAddressFormProvider = EditAddressFormProvider;
exports.EditCustomerFormProvider = EditCustomerFormProvider;
exports.EnsureTTI = EnsureTTI;
exports.FALCON_SCOPE_COOKIE_NAME = FALCON_SCOPE_COOKIE_NAME;
exports.FalconScope = FalconScope;
exports.FalconScopeProvider = FalconScopeProvider;
exports.Field = Field;
exports.FiltersDataProvider = FiltersDataProvider;
exports.ForgotPasswordFormProvider = ForgotPasswordFormProvider;
exports.Form = Form;
exports.FormContext = FormContext;
exports.GET_CONFIG = GET_CONFIG;
exports.GET_CONFIG_KEY = GET_CONFIG_KEY;
exports.GeoLocation = GeoLocation;
exports.GeoLocationContext = GeoLocationContext;
exports.GeoLocationProvider = GeoLocationProvider;
exports.InBrowserOnly = InBrowserOnly;
exports.Locale = Locale;
exports.LocaleProvider = LocaleProvider;
exports.NetworkStatus = NetworkStatus;
exports.OnlyUnauthenticatedRoute = OnlyUnauthenticatedRoute;
exports.PlaceOrder = PlaceOrder;
exports.ProtectedRoute = ProtectedRoute;
exports.ResetPasswordFormProvider = ResetPasswordFormProvider;
exports.Router = Router;
exports.SEO = SEO;
exports.ScrollToTop = ScrollToTop;
exports.SearchConsumer = SearchConsumer;
exports.SearchProvider = SearchProvider;
exports.SearchProviderInner = SearchProviderInner;
exports.SetBillingAddress = SetBillingAddress;
exports.SetCheckoutAddressFormProvider = SetCheckoutAddressFormProvider;
exports.SetPaymentMethod = SetPaymentMethod;
exports.SetShippingAddress = SetShippingAddress;
exports.SetShippingMethod = SetShippingMethod;
exports.SidebarContainer = SidebarContainer;
exports.SidebarContainerContext = SidebarContainerContext;
exports.SidebarContainerProvider = SidebarContainerProvider;
exports.SignInFormProvider = SignInFormProvider;
exports.SignOutProvider = SignOutProvider;
exports.SignUpFormProvider = SignUpFormProvider;
exports.SortOrderPickerProvider = SortOrderPickerProvider;
exports.Submit = Submit;
exports.SwitchDynamicURL = SwitchDynamicURL;
exports.TwoStepWizard = TwoStepWizard;
exports.addressToCheckoutAddressInput = addressToCheckoutAddressInput;
exports.addressToString = addressToString;
exports.aggregationToFilterData = aggregationToFilterData;
exports.apolloStateToObject = apolloStateToObject;
exports.areSortOrderInputsEqual = areSortOrderInputsEqual;
exports.browseAndCleanObject = browseAndCleanObject;
exports.calculateCheckoutStepFactory = calculateCheckoutStepFactory;
exports.canUseIntesectionObserver = canUseIntesectionObserver;
exports.checkoutAddressToSetCheckoutAddressFormValues = checkoutAddressToSetCheckoutAddressFormValues;
exports.confirmPasswordValidator = confirmPasswordValidator;
exports.dateRangeValidator = dateRangeValidator;
exports.dateTimeFormatFactory = dateTimeFormatFactory;
exports.emailValidator = emailValidator;
exports.fieldValidator = fieldValidator;
exports.formProductOptionsToInput = formProductOptionsToInput;
exports.getClientConfig = getClientConfig;
exports.getClientConfigResolver = getClientConfigResolver;
exports.getCurrencyLabel = getCurrencyLabel;
exports.getDefaultInputValidators = getDefaultInputValidators;
exports.getErrorI18nId = getErrorI18nId;
exports.getFalconScopeFromCookie = getFalconScopeFromCookie;
exports.getFalconScopeFromURL = getFalconScopeFromURL;
exports.getFiltersData = getFiltersData;
exports.getLabelI18nId = getLabelI18nId;
exports.getPlaceholderI18nId = getPlaceholderI18nId;
exports.getSelectedFilterOptionsFor = getSelectedFilterOptionsFor;
exports.integerValidator = integerValidator;
exports.isCheckedValidator = isCheckedValidator;
exports.isCustomAddress = isCustomAddress;
exports.isI18nValidationError = isI18nValidationError;
exports.isObject = isObject;
exports.lengthValidator = lengthValidator;
exports.numLinesValidator = numLinesValidator;
exports.numberValidator = numberValidator;
exports.passwordValidator = passwordValidator;
exports.paymentMethodToCheckoutDetailsInput = paymentMethodToCheckoutDetailsInput;
exports.priceFormatFactory = priceFormatFactory;
exports.productOptionsToForm = productOptionsToForm;
exports.rangeValidator = rangeValidator;
exports.requiredValidator = requiredValidator;
exports.searchStateFromURL = searchStateFromURL;
exports.searchStateToURL = searchStateToURL;
exports.setFalconScopeToCookie = setFalconScopeToCookie;
exports.setFalconScopeToURL = setFalconScopeToURL;
exports.shippingMethodToCheckoutDetailsInput = shippingMethodToCheckoutDetailsInput;
exports.stripTypenames = stripTypenames;
exports.tryGetFalconScopeConfig = tryGetFalconScopeConfig;
exports.useCheckout = useCheckout;
exports.useCurrency = useCurrency;
exports.useFalconScope = useFalconScope;
exports.useFormContext = useFormContext;
exports.useGeoLocation = useGeoLocation;
exports.useLocale = useLocale;
exports.useMounted = useMounted;
exports.usePlaceOrder = usePlaceOrder;
exports.usePrevious = usePrevious;
exports.useSearchContext = useSearchContext;
exports.useSetBillingAddress = useSetBillingAddress;
exports.useSetPaymentMethod = useSetPaymentMethod;
exports.useSetShippingAddress = useSetShippingAddress;
exports.useSetShippingMethod = useSetShippingMethod;
exports.useSidebarContainer = useSidebarContainer;
exports.useStateCallback = useStateCallback;
//# sourceMappingURL=falcon-front-kit.cjs.js.map
