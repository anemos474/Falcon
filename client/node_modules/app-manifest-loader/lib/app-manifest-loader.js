/*! app-manifest-loader v2.2.3 by Sebastian Software <s.werner@sebastian-software.de> */
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

require('core-js/modules/es6.array.reduce');
require('core-js/modules/es6.function.name');
require('core-js/modules/es6.array.filter');
require('core-js/modules/es6.array.map');
require('core-js/modules/web.dom.iterable');
require('core-js/modules/es6.array.iterator');
require('core-js/modules/es6.string.iterator');
require('core-js/modules/es6.array.is-array');
require('core-js/modules/es6.regexp.replace');
require('core-js/modules/es6.string.ends-with');
require('core-js/modules/es6.promise');
var path = require('path');
var loaderUtils = _interopDefault(require('loader-utils'));
var xmljs = _interopDefault(require('xml-js'));

var PUBLIC_MARKER = "__webpack_public_path__";

function resolveImageSrc(image, options, publicPath) {
  var _this = this,
      hasAttributes = !!image.attributes,
      src = hasAttributes ? image.attributes.src : image.src;

  if (typeof src != "string") {
    throw new Error('Missing image "src" property for manifest entry.');
  }

  return new Promise(function (resolve, reject) {
    var context = _this.context,
        request = loaderUtils.urlToRequest(src);

    _this.resolve(context, request, function (err, filename) {
      if (err) {
        return reject(err);
      }

      _this.addDependency(filename);

      return _this.loadModule(filename, function (error, source) {
        if (error) {
          return reject(error);
        }

        var url = loaderUtils.interpolateName(_this, source, {
          context: context,
          content: source,
          regExp: options.regExp
        });

        if (typeof publicPath == "function") {
          publicPath = publicPath(url);

          if (publicPath && publicPath.endsWith("/")) {
            publicPath += "/";
          }
        }

        var assignmentWithPublicPath = source.replace(PUBLIC_MARKER, JSON.stringify(publicPath)),
            getPublicSource = new Function("var module={};return " + assignmentWithPublicPath);

        if (hasAttributes) {
          image.attributes.src = getPublicSource();
        } else {
          image.src = getPublicSource();
        }

        return resolve();
      });
    });
  });
}

function resolveImages(entries, options, publicPath) {
  var _this2 = this;

  if (!Array.isArray(entries)) {
    return Promise.resolve();
  }

  return Promise.all(entries.map(function (entry) {
    return resolveImageSrc.call(_this2, entry, options, publicPath);
  }));
}

function findElements(xmlElement, expectedName) {
  return xmlElement.elements.filter(function (_ref) {
    var name = _ref.name;
    return name === expectedName;
  });
}

function index (content) {
  return new Promise(function ($return, $error) {
    var options, publicPath, callback, fileExt, manifest, formatted, browserconfig, tiles, _formatted;

    if (this.cacheable) {
      this.cacheable();
    }

    options = loaderUtils.getOptions(this) || {};
    options.context || this.rootContext || this.options && this.options.context;
    publicPath = options.publicPath || this._compiler.options.output.publicPath || "";

    if (typeof publicPath == "string" && publicPath.length !== 0 && !publicPath.endsWith("/")) {
      publicPath += "/";
    }

    callback = this.async();
    fileExt = path.extname(this.resourcePath);

    if (fileExt === ".json" || fileExt === ".webmanifest") {
      try {
        manifest = JSON.parse(content);
      } catch (parseError) {
        return $return(callback(new Error("Invalid JSON in Web App Manifest: " + this.resourcePath)));
      }

      var $Try_2_Post = function () {
        try {
          formatted = JSON.stringify(manifest, null, 2);
          callback(null, formatted);
          return $If_5.call(this);
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }.bind(this),
          $Try_2_Catch = function (resolveError) {
        try {
          return $return(callback(resolveError));
        } catch ($boundEx) {
          return $error($boundEx);
        }
      };

      try {
        return Promise.resolve(Promise.all([resolveImages.call(this, manifest.screenshots, options, publicPath), resolveImages.call(this, manifest.icons, options, publicPath)])).then(function () {
          try {
            return $Try_2_Post();
          } catch ($boundEx) {
            return $Try_2_Catch($boundEx);
          }
        }, $Try_2_Catch);
      } catch (resolveError) {
        $Try_2_Catch(resolveError);
      }
    } else {
      if (fileExt === ".xml") {
        try {
          browserconfig = xmljs.xml2js(content);
        } catch (parseError) {
          return $return(callback(new Error("Invalid XML in Browserconfig: " + this.resourcePath)));
        }

        tiles = findElements(browserconfig, "browserconfig").map(function (element) {
          return findElements(element, "msapplication");
        }).reduce(function (accumulator, value) {
          return [].concat(accumulator).concat(value);
        }, []).map(function (element) {
          return findElements(element, "tile");
        }).reduce(function (accumulator, value) {
          return [].concat(accumulator).concat(value);
        }, []).map(function (element) {
          return element.elements;
        }).reduce(function (accumulator, value) {
          return [].concat(accumulator).concat(value);
        }, []).filter(function (element) {
          return element.attributes && element.attributes.src;
        });

        var $Try_4_Post = function () {
          try {
            _formatted = xmljs.js2xml(browserconfig, {
              spaces: 2,
              indentAttributes: false
            });
            callback(null, _formatted);
            return $If_6.call(this);
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }.bind(this),
            $Try_4_Catch = function (resolveError) {
          try {
            return $return(callback(resolveError));
          } catch ($boundEx) {
            return $error($boundEx);
          }
        };

        try {
          return Promise.resolve(resolveImages.call(this, tiles, options, publicPath)).then(function () {
            try {
              return $Try_4_Post();
            } catch ($boundEx) {
              return $Try_4_Catch($boundEx);
            }
          }, $Try_4_Catch);
        } catch (resolveError) {
          $Try_4_Catch(resolveError);
        }
      } else {
        callback(new Error("Unsupported manifest file: " + this.resourcePath));
        return $If_6.call(this);
      }

      function $If_6() {
        return $If_5.call(this);
      }
    }

    function $If_5() {
      return $return(null);
    }
  }.bind(this));
}

module.exports = index;
//# sourceMappingURL=app-manifest-loader.js.map
