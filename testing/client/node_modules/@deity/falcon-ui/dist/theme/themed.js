import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import React from 'react';
import styled from '@emotion/styled-base';
import isPropValid from '@emotion/is-prop-valid';
import { extractThemableProps } from './utils';
import { baseTheme } from './baseTheme';
import { propsMappingKeys, mappings } from './responsiveprops';
import { getThemeBreakpointNames } from './getThemeBreakpoints';
import { extractBreakpointBlockThemingProps, filterOutNonBreakpointBlockThemingProps, mapBreakpointBlockThemingPropsToBaseThemmingProps } from './formatBreakpointCssBlocks';
var NESTED_CSS_OBJECT_SELECTORS = [':', '&', '*', '>', '@'];

var convertPropToCss = function convertPropToCss(mappingKey, propMapping, matchingProp, theme) {
  var _ref;

  // if mapping does not have cssProp specified fallback to it's key as css property name
  var cssPropName = propMapping.cssProp || mappingKey; // if matching props is themable prop then get it's actual value from theme props otherwise
  // then just pass it as css prop value
  // TODO: typescript: is there a way to improve those typings?

  var cssPropValue = !propMapping.themeProp ? matchingProp : theme[propMapping.themeProp][matchingProp];

  if (propMapping.transformToCss) {
    return propMapping.transformToCss(cssPropValue);
  }

  return _ref = {}, _ref[cssPropName] = cssPropValue, _ref;
};

function convertThemedPropsToCss(props, theme) {
  //  if theme is not provided via theme provider do not map anything
  if (!theme) {
    return {};
  } // TODO: typescript: can typings be improved for that object?


  var targetCss = {}; // eslint-disable-next-line

  for (var mappingKey in props) {
    var propMapping = mappings[mappingKey];
    var matchingProp = props[mappingKey]; // move along if there is no matching prop in mappings for given key found

    if (!propMapping) {
      continue;
    } // if matching prop is typeof string it means it's not responsive


    if (typeof matchingProp === 'string' || typeof matchingProp === 'number') {
      var cssObject = convertPropToCss(mappingKey, propMapping, matchingProp, theme); // eslint-disable-next-line

      for (var _mappingKey in cssObject) {
        targetCss[_mappingKey] = cssObject[_mappingKey];
      }
    } else {
      // if it's not string it needs to be object that has responsive breakpoints keys
      // here we only translate all themed values to css values, we don't create media queries
      // eslint-disable-next-line
      for (var breakpointKey in matchingProp) {
        var breakpointValue = theme.breakpoints[breakpointKey];
        var matchingResponsiveProp = matchingProp[breakpointKey];

        if (breakpointValue === undefined) {
          continue;
        }

        var _cssObject = convertPropToCss(mappingKey, propMapping, matchingResponsiveProp, theme); // eslint-disable-next-line


        for (var _mappingKey2 in _cssObject) {
          if (!targetCss[_mappingKey2]) {
            targetCss[_mappingKey2] = {};
          }

          targetCss[_mappingKey2][breakpointKey] = _cssObject[_mappingKey2];
        }
      }
    }
  }

  return targetCss;
}

function convertResponsivePropsToMediaQueries(css, theme) {
  var target = {};
  var mediaQueries = {}; // eslint-disable-next-line

  for (var cssProp in css) {
    var cssValue = css[cssProp];

    if (!cssValue || typeof cssValue !== 'object' || Array.isArray(cssValue)) {
      target[cssProp] = cssValue;
    } // we need to look for responsive props in nested css as well
    // for example in :hover object
    else if (NESTED_CSS_OBJECT_SELECTORS.indexOf(cssProp[0]) !== -1) {
        target[cssProp] = convertResponsivePropsToMediaQueries(cssValue, theme);
      } else {
        // eslint-disable-next-line
        for (var potentialBreakpointKey in cssValue) {
          var breakpointValue = theme.breakpoints[potentialBreakpointKey];
          var valueForBreakpoint = cssValue[potentialBreakpointKey];

          if (breakpointValue) {
            // add media query key to mediaQueries object if it hasn't already got one
            if (!mediaQueries[potentialBreakpointKey]) {
              mediaQueries[potentialBreakpointKey] = {};
            }

            mediaQueries[potentialBreakpointKey][cssProp] = valueForBreakpoint;
          } else if (breakpointValue === 0) {
            target[cssProp] = valueForBreakpoint;
          } else {
            if (!target[cssProp]) {
              target[cssProp] = {};
            }

            target[cssProp][potentialBreakpointKey] = valueForBreakpoint;
          }
        }
      }
  } // media queries need to be handled in very careful way as order matters
  // so media min-width with smaller px value always apper before media min-width with larger px value
  // in resulting style


  Object.keys(mediaQueries).sort(function (first, second) {
    return theme.breakpoints[first] > theme.breakpoints[second] ? 1 : -1;
  }).forEach(function (sortedMediaQueryKey) {
    var mediaQueryPxValue = theme.breakpoints[sortedMediaQueryKey];
    target["@media screen and (min-width: " + mediaQueryPxValue + "px)"] = mediaQueries[sortedMediaQueryKey];
  });
  return target;
}

function getCss(css, props) {
  return typeof css === 'function' ? css(props) : css;
}

/**
 * `<themedComponent>.defaultTheme` specifies it's `props` in nested object which key is used as `themeKey`
 *
 * TODO: write unit tests!
 * @param defaultTheme
 */
function extractDefaultThemeFromThemedComponent(defaultTheme) {
  if (!defaultTheme) {
    return undefined;
  } // default theme should have only one key, so we try to take first one, we also expect an `object` under it


  var potentialKey = Object.keys(defaultTheme)[0];
  var themeKey = typeof defaultTheme[potentialKey] === 'object' ? potentialKey : undefined;

  if (!themeKey) {
    return undefined;
  }

  return {
    key: themeKey,
    props: defaultTheme[themeKey]
  };
}
/**
 * @private
 * exported only because of unit test !!!
 *
 * following diagram shows theme props order (values in brackets)
 *
 * | theme                                            | themed component                                     | inline                          |
 * | ------------------------------------------------ | ---------------------------------------------------- | ------------------------------- |
 * | `[theme].components[component-theme-name]`       | `themed({defaultTheme:{[component-theme-name]:{}}})` | `<Box bg="primary"`             |
 * | **(2)** `component.breakpointBlockProps`         | **(1)** `defaultTheme.breakpointBlockProps`          | **(13)** `breakpointBlockProps` |
 * | **(6)** `component.baseThemingProps`             | **(5)** `defaultTheme.baseThemingProps`              | **(14)** `baseThemingProps`     |
 * | **(10)** `component.cssProp`                     | **(9)** `defaultTheme.cssProp`                       | **(15)** `cssProp`              |
 * | **(4)** `component.variant.breakpointBlockProps` | **(3)** `defaultTheme.variant.breakpointBlockProps`  |                                 |
 * | **(8)** `component.variant.baseThemingProps`     | **(7)** `defaultTheme.variant.baseThemingProps`      |                                 |
 * | **(12)** `component.variant.cssProp`             | **(11)** `defaultTheme.variant.cssProp`              |                                 |
 * @param props
 */


export function mergeThemingProps(props) {
  var defaultThemeProp = props.defaultTheme,
      theme = props.theme,
      variant = props.variant,
      inlineCss = props.css,
      restProps = _objectWithoutPropertiesLoose(props, ["defaultTheme", "theme", "variant", "css"]);

  var defaultTheme = extractDefaultThemeFromThemedComponent(defaultThemeProp);
  var breakpointNames = getThemeBreakpointNames(theme);
  var breakpointBlockThemingProps = extractBreakpointBlockThemingProps(breakpointNames, restProps);
  var remainingProps = filterOutNonBreakpointBlockThemingProps(breakpointNames, restProps);

  var _extractThemableProps = extractThemableProps(remainingProps),
      themableProps = _extractThemableProps.themableProps; // first we need to check where themed props and css props are defined and merge them
  // // css props need to merged separately as those do not need to be processed to extract css
  // Merging order
  // 1 -  props defined in defaultTheme props  as those are defaults
  // 2 -  props defined in theme.components for given `defaultTheme.key` as those are defaults
  // 3 -  props defined in defaultTheme variant prop if props.variant is defined
  // 4 -  props defined in theme.components[]variants if props.variant is defined
  // 5 -  props defined directly on component


  var breakpointBlockThemingPropsToMerge = [];
  var baseThemingPropsToMerge = [];
  var cssPropsToMerge = [];

  var addPropsToMerge = function addPropsToMerge(propsToMerge) {
    var css = propsToMerge.css,
        rest = _objectWithoutPropertiesLoose(propsToMerge, ["css"]);

    if (css) {
      cssPropsToMerge.push(getCss(css, props));
    } // Format breakpoint CSS blocks


    breakpointBlockThemingPropsToMerge.push(extractBreakpointBlockThemingProps(breakpointNames, rest));
    baseThemingPropsToMerge.push(filterOutNonBreakpointBlockThemingProps(breakpointNames, rest));
  }; //  start with props defined in `defaultTheme` prop as base


  if (defaultTheme !== undefined) {
    addPropsToMerge(defaultTheme.props); // if props are defined in `theme.components` object for `defaultTheme.key` merge them with default ones

    var areComponentPropsDefinedInTheme = theme.components[defaultTheme.key] !== undefined;

    if (areComponentPropsDefinedInTheme) {
      addPropsToMerge(theme.components[defaultTheme.key]);
    } // themed props can also be defined for component variant


    if (variant) {
      // check for `variant` prop defined in themed component `defaultTheme`
      var defaultThemeVariants = defaultTheme.props && defaultTheme.props.variants;

      if (defaultThemeVariants && defaultThemeVariants[variant]) {
        addPropsToMerge(defaultThemeVariants[variant]);
      } // check for `variant` prop defined in `theme.components` object


      var themeVariants = areComponentPropsDefinedInTheme && theme.components[defaultTheme.key].variants;

      if (themeVariants && themeVariants[variant]) {
        addPropsToMerge(themeVariants[variant]);
      }
    }
  }

  var mergedBreakpointBlockThemingProps = Object.assign.apply(Object, [{}].concat(breakpointBlockThemingPropsToMerge));
  var baseThemingPropsFromBreakpointBlockThemingProps = mapBreakpointBlockThemingPropsToBaseThemmingProps(breakpointNames, mergedBreakpointBlockThemingProps);
  var mergedBaseThemingProps = Object.assign.apply(Object, [{}].concat([baseThemingPropsFromBreakpointBlockThemingProps].concat(baseThemingPropsToMerge))); // merged themable props need to be converted to css before returning

  var cssFromThemedProps = convertThemedPropsToCss(mergedBaseThemingProps, theme);
  cssPropsToMerge.push(convertThemedPropsToCss(mapBreakpointBlockThemingPropsToBaseThemmingProps(breakpointNames, breakpointBlockThemingProps), theme)); // out of all component props extract themable ones, convert to css and add to merge

  cssPropsToMerge.push(convertThemedPropsToCss(themableProps, theme)); // as last step add for merging those `css` prop which defined directly on component

  if (inlineCss) {
    cssPropsToMerge.push(getCss(inlineCss, props));
  }

  var cssProps = Object.assign.apply(Object, [{}].concat(cssPropsToMerge)); // finally merge css from themed props with css from css props

  var mergedCss = Object.assign({}, cssFromThemedProps, cssProps);
  return mergedCss;
}
/**
 * this function responsibility is to extract css object from
 * both themed props (that use props values from theme) and css object/function props
 * TODO: perhaps this function could be written in prettier way?
 *  @param props
 */

function getThemedCss(props) {
  //  if theme is not provided via theme provider or inline theme prop
  // fall back to default theme
  if (!props.theme || !props.theme.components) {
    props = Object.assign({}, props, {
      theme: baseTheme
    });
  }

  var mergedCss = mergeThemingProps(props); // as a last step we need to check each css prop if it's value is responsive

  return convertResponsivePropsToMediaQueries(mergedCss, props.theme);
} // filtering which props to forward to next component is tricky
// and behaves differently if next component is html element, custom component
// or custom component whihch is themed component


var customPropsBlacklist = ['as', 'tag', 'variant', 'defaultTheme', 'css'];

var filterPropsToForward = function filterPropsToForward(baseComponent, props, ref) {
  var filteredProps = {};
  var isHtmlTag = typeof baseComponent === 'string'; // eslint-disable-next-line

  for (var key in props) {
    // when html tag is provided forward only valid html props to it
    if (isHtmlTag && !isPropValid(key)) continue; // if custom component is provided via `as` prop do not forward themable props to it (bg, color, m, p etc)
    // neighter forward any of the blacklisted props

    var themableProp = propsMappingKeys.indexOf(key) !== -1 || customPropsBlacklist.indexOf(key) !== -1;
    if (themableProp) continue;
    filteredProps[key] = props[key];
  }

  filteredProps.ref = ref;
  return filteredProps;
};

/**
 * Handles dynamic html tag rendering via and `as` prop as well as forwards `ref` and only allowed html props to DOM element
 */
var DynamicHtmlTag = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var Base = props.as || props.tag;
  var nextProps = filterPropsToForward(Base, props, ref);
  return /*#__PURE__*/React.createElement(Base, nextProps);
});
export function themed(options) {
  var label = '';

  if (options.defaultTheme) {
    var componentKey = Object.keys(options.defaultTheme)[0];

    if (typeof options.defaultTheme[componentKey] === 'object') {
      label = "" + componentKey;
    }
  }

  var styledComponentWithThemeProps = styled(DynamicHtmlTag, {
    label: label,
    // label is transformed for displayName of styled component,
    // target inserted as css class in resulting element so this could potentially be used as a fallback
    // to style components via traditional css
    target: "themed" + (label ? "-" + label.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/\s+/g, '-').toLowerCase() : '')
  })(getThemedCss); // default theme is also passed as part of default props

  styledComponentWithThemeProps.defaultProps = Object.assign({}, options.defaultProps, {
    defaultTheme: options.defaultTheme,
    tag: options.tag
  });
  return /*#__PURE__*/React.memo(styledComponentWithThemeProps);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90aGVtZS90aGVtZWQudHN4Il0sIm5hbWVzIjpbIlJlYWN0Iiwic3R5bGVkIiwiaXNQcm9wVmFsaWQiLCJleHRyYWN0VGhlbWFibGVQcm9wcyIsImJhc2VUaGVtZSIsInByb3BzTWFwcGluZ0tleXMiLCJtYXBwaW5ncyIsImdldFRoZW1lQnJlYWtwb2ludE5hbWVzIiwiZXh0cmFjdEJyZWFrcG9pbnRCbG9ja1RoZW1pbmdQcm9wcyIsImZpbHRlck91dE5vbkJyZWFrcG9pbnRCbG9ja1RoZW1pbmdQcm9wcyIsIm1hcEJyZWFrcG9pbnRCbG9ja1RoZW1pbmdQcm9wc1RvQmFzZVRoZW1taW5nUHJvcHMiLCJORVNURURfQ1NTX09CSkVDVF9TRUxFQ1RPUlMiLCJjb252ZXJ0UHJvcFRvQ3NzIiwibWFwcGluZ0tleSIsInByb3BNYXBwaW5nIiwibWF0Y2hpbmdQcm9wIiwidGhlbWUiLCJjc3NQcm9wTmFtZSIsImNzc1Byb3AiLCJjc3NQcm9wVmFsdWUiLCJ0aGVtZVByb3AiLCJ0cmFuc2Zvcm1Ub0NzcyIsImNvbnZlcnRUaGVtZWRQcm9wc1RvQ3NzIiwicHJvcHMiLCJ0YXJnZXRDc3MiLCJjc3NPYmplY3QiLCJicmVha3BvaW50S2V5IiwiYnJlYWtwb2ludFZhbHVlIiwiYnJlYWtwb2ludHMiLCJtYXRjaGluZ1Jlc3BvbnNpdmVQcm9wIiwidW5kZWZpbmVkIiwiY29udmVydFJlc3BvbnNpdmVQcm9wc1RvTWVkaWFRdWVyaWVzIiwiY3NzIiwidGFyZ2V0IiwibWVkaWFRdWVyaWVzIiwiY3NzVmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJpbmRleE9mIiwicG90ZW50aWFsQnJlYWtwb2ludEtleSIsInZhbHVlRm9yQnJlYWtwb2ludCIsIk9iamVjdCIsImtleXMiLCJzb3J0IiwiZmlyc3QiLCJzZWNvbmQiLCJmb3JFYWNoIiwic29ydGVkTWVkaWFRdWVyeUtleSIsIm1lZGlhUXVlcnlQeFZhbHVlIiwiZ2V0Q3NzIiwiZXh0cmFjdERlZmF1bHRUaGVtZUZyb21UaGVtZWRDb21wb25lbnQiLCJkZWZhdWx0VGhlbWUiLCJwb3RlbnRpYWxLZXkiLCJ0aGVtZUtleSIsImtleSIsIm1lcmdlVGhlbWluZ1Byb3BzIiwiZGVmYXVsdFRoZW1lUHJvcCIsInZhcmlhbnQiLCJpbmxpbmVDc3MiLCJyZXN0UHJvcHMiLCJicmVha3BvaW50TmFtZXMiLCJicmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHMiLCJyZW1haW5pbmdQcm9wcyIsInRoZW1hYmxlUHJvcHMiLCJicmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHNUb01lcmdlIiwiYmFzZVRoZW1pbmdQcm9wc1RvTWVyZ2UiLCJjc3NQcm9wc1RvTWVyZ2UiLCJhZGRQcm9wc1RvTWVyZ2UiLCJwcm9wc1RvTWVyZ2UiLCJyZXN0IiwicHVzaCIsImFyZUNvbXBvbmVudFByb3BzRGVmaW5lZEluVGhlbWUiLCJjb21wb25lbnRzIiwiZGVmYXVsdFRoZW1lVmFyaWFudHMiLCJ2YXJpYW50cyIsInRoZW1lVmFyaWFudHMiLCJtZXJnZWRCcmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHMiLCJhc3NpZ24iLCJiYXNlVGhlbWluZ1Byb3BzRnJvbUJyZWFrcG9pbnRCbG9ja1RoZW1pbmdQcm9wcyIsIm1lcmdlZEJhc2VUaGVtaW5nUHJvcHMiLCJjc3NGcm9tVGhlbWVkUHJvcHMiLCJjc3NQcm9wcyIsIm1lcmdlZENzcyIsImdldFRoZW1lZENzcyIsImN1c3RvbVByb3BzQmxhY2tsaXN0IiwiZmlsdGVyUHJvcHNUb0ZvcndhcmQiLCJiYXNlQ29tcG9uZW50IiwicmVmIiwiZmlsdGVyZWRQcm9wcyIsImlzSHRtbFRhZyIsInRoZW1hYmxlUHJvcCIsIkR5bmFtaWNIdG1sVGFnIiwiZm9yd2FyZFJlZiIsIkJhc2UiLCJhcyIsInRhZyIsIm5leHRQcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJ0aGVtZWQiLCJvcHRpb25zIiwibGFiZWwiLCJjb21wb25lbnRLZXkiLCJzdHlsZWRDb21wb25lbnRXaXRoVGhlbWVQcm9wcyIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsImRlZmF1bHRQcm9wcyIsIm1lbW8iXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPQSxLQUFQLE1BQWtCLE9BQWxCO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixzQkFBbkI7QUFDQSxPQUFPQyxXQUFQLE1BQXdCLHdCQUF4QjtBQUNBLFNBQVNDLG9CQUFULFFBQXFDLFNBQXJDO0FBQ0EsU0FBU0MsU0FBVCxRQUEwQixhQUExQjtBQUNBLFNBQVNDLGdCQUFULEVBQTJCQyxRQUEzQixRQUFpRixtQkFBakY7QUFDQSxTQUFTQyx1QkFBVCxRQUF3Qyx1QkFBeEM7QUFDQSxTQUNFQyxrQ0FERixFQUVFQyx1Q0FGRixFQUdFQyxpREFIRixRQUlPLDZCQUpQO0FBaUJBLElBQU1DLDJCQUEyQixHQUFHLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCLEVBQXFCLEdBQXJCLENBQXBDOztBQUVBLElBQU1DLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsQ0FDdkJDLFVBRHVCLEVBRXZCQyxXQUZ1QixFQUd2QkMsWUFIdUIsRUFJdkJDLEtBSnVCLEVBS1Q7QUFBQTs7QUFDZDtBQUNBLE1BQU1DLFdBQVcsR0FBR0gsV0FBVyxDQUFDSSxPQUFaLElBQXVCTCxVQUEzQyxDQUZjLENBR2Q7QUFDQTtBQUNBOztBQUNBLE1BQU1NLFlBQVksR0FBRyxDQUFDTCxXQUFXLENBQUNNLFNBQWIsR0FBeUJMLFlBQXpCLEdBQXlDQyxLQUFLLENBQUNGLFdBQVcsQ0FBQ00sU0FBYixDQUFOLENBQXNDTCxZQUF0QyxDQUE3RDs7QUFFQSxNQUFJRCxXQUFXLENBQUNPLGNBQWhCLEVBQWdDO0FBQzlCLFdBQU9QLFdBQVcsQ0FBQ08sY0FBWixDQUEyQkYsWUFBM0IsQ0FBUDtBQUNEOztBQUVELHlCQUNHRixXQURILElBQ2lCRSxZQURqQjtBQUdELENBcEJEOztBQXNCQSxTQUFTRyx1QkFBVCxDQUErQ0MsS0FBL0MsRUFBNEVQLEtBQTVFLEVBQXFHO0FBQ25HO0FBQ0EsTUFBSSxDQUFDQSxLQUFMLEVBQVk7QUFDVixXQUFPLEVBQVA7QUFDRCxHQUprRyxDQU1uRzs7O0FBQ0EsTUFBTVEsU0FBUyxHQUFHLEVBQWxCLENBUG1HLENBU25HOztBQUNBLE9BQUssSUFBSVgsVUFBVCxJQUF1QlUsS0FBdkIsRUFBOEI7QUFDNUIsUUFBTVQsV0FBVyxHQUFHUixRQUFRLENBQUNPLFVBQUQsQ0FBNUI7QUFDQSxRQUFNRSxZQUFZLEdBQUlRLEtBQUQsQ0FBZVYsVUFBZixDQUFyQixDQUY0QixDQUk1Qjs7QUFDQSxRQUFJLENBQUNDLFdBQUwsRUFBa0I7QUFDaEI7QUFDRCxLQVAyQixDQVE1Qjs7O0FBQ0EsUUFBSSxPQUFPQyxZQUFQLEtBQXdCLFFBQXhCLElBQW9DLE9BQU9BLFlBQVAsS0FBd0IsUUFBaEUsRUFBMEU7QUFDeEUsVUFBTVUsU0FBUyxHQUFHYixnQkFBZ0IsQ0FBQ0MsVUFBRCxFQUFhQyxXQUFiLEVBQTBCQyxZQUExQixFQUF3Q0MsS0FBeEMsQ0FBbEMsQ0FEd0UsQ0FFeEU7O0FBQ0EsV0FBSyxJQUFJSCxXQUFULElBQXVCWSxTQUF2QixFQUFrQztBQUNoQ0QsUUFBQUEsU0FBUyxDQUFDWCxXQUFELENBQVQsR0FBd0JZLFNBQVMsQ0FBQ1osV0FBRCxDQUFqQztBQUNEO0FBQ0YsS0FORCxNQU1PO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsV0FBSyxJQUFJYSxhQUFULElBQTBCWCxZQUExQixFQUF3QztBQUN0QyxZQUFNWSxlQUFlLEdBQUlYLEtBQUssQ0FBQ1ksV0FBUCxDQUEyQkYsYUFBM0IsQ0FBeEI7QUFDQSxZQUFNRyxzQkFBc0IsR0FBR2QsWUFBWSxDQUFDVyxhQUFELENBQTNDOztBQUNBLFlBQUlDLGVBQWUsS0FBS0csU0FBeEIsRUFBbUM7QUFDakM7QUFDRDs7QUFFRCxZQUFNTCxVQUFTLEdBQUdiLGdCQUFnQixDQUFDQyxVQUFELEVBQWFDLFdBQWIsRUFBMEJlLHNCQUExQixFQUFrRGIsS0FBbEQsQ0FBbEMsQ0FQc0MsQ0FRdEM7OztBQUNBLGFBQUssSUFBSUgsWUFBVCxJQUF1QlksVUFBdkIsRUFBa0M7QUFDaEMsY0FBSSxDQUFDRCxTQUFTLENBQUNYLFlBQUQsQ0FBZCxFQUE0QjtBQUMxQlcsWUFBQUEsU0FBUyxDQUFDWCxZQUFELENBQVQsR0FBd0IsRUFBeEI7QUFDRDs7QUFFRFcsVUFBQUEsU0FBUyxDQUFDWCxZQUFELENBQVQsQ0FBc0JhLGFBQXRCLElBQXVDRCxVQUFTLENBQUNaLFlBQUQsQ0FBaEQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPVyxTQUFQO0FBQ0Q7O0FBRUQsU0FBU08sb0NBQVQsQ0FBOENDLEdBQTlDLEVBQThEaEIsS0FBOUQsRUFBNEU7QUFDMUUsTUFBTWlCLE1BQVcsR0FBRyxFQUFwQjtBQUNBLE1BQU1DLFlBQWlCLEdBQUcsRUFBMUIsQ0FGMEUsQ0FJMUU7O0FBQ0EsT0FBSyxJQUFJaEIsT0FBVCxJQUFvQmMsR0FBcEIsRUFBeUI7QUFDdkIsUUFBTUcsUUFBUSxHQUFHSCxHQUFHLENBQUNkLE9BQUQsQ0FBcEI7O0FBQ0EsUUFBSSxDQUFDaUIsUUFBRCxJQUFhLE9BQU9BLFFBQVAsS0FBb0IsUUFBakMsSUFBNkNDLEtBQUssQ0FBQ0MsT0FBTixDQUFjRixRQUFkLENBQWpELEVBQTBFO0FBQ3hFRixNQUFBQSxNQUFNLENBQUNmLE9BQUQsQ0FBTixHQUFrQmlCLFFBQWxCO0FBQ0QsS0FGRCxDQUdBO0FBQ0E7QUFKQSxTQUtLLElBQUl4QiwyQkFBMkIsQ0FBQzJCLE9BQTVCLENBQW9DcEIsT0FBTyxDQUFDLENBQUQsQ0FBM0MsTUFBb0QsQ0FBQyxDQUF6RCxFQUE0RDtBQUMvRGUsUUFBQUEsTUFBTSxDQUFDZixPQUFELENBQU4sR0FBa0JhLG9DQUFvQyxDQUFDSSxRQUFELEVBQXdCbkIsS0FBeEIsQ0FBdEQ7QUFDRCxPQUZJLE1BRUU7QUFDTDtBQUNBLGFBQUssSUFBSXVCLHNCQUFULElBQW1DSixRQUFuQyxFQUE2QztBQUMzQyxjQUFNUixlQUFlLEdBQUlYLEtBQUssQ0FBQ1ksV0FBUCxDQUEyQlcsc0JBQTNCLENBQXhCO0FBQ0EsY0FBTUMsa0JBQWtCLEdBQUlMLFFBQUQsQ0FBa0JJLHNCQUFsQixDQUEzQjs7QUFFQSxjQUFJWixlQUFKLEVBQXFCO0FBQ25CO0FBQ0EsZ0JBQUksQ0FBQ08sWUFBWSxDQUFDSyxzQkFBRCxDQUFqQixFQUEyQztBQUN6Q0wsY0FBQUEsWUFBWSxDQUFDSyxzQkFBRCxDQUFaLEdBQXVDLEVBQXZDO0FBQ0Q7O0FBQ0RMLFlBQUFBLFlBQVksQ0FBQ0ssc0JBQUQsQ0FBWixDQUFxQ3JCLE9BQXJDLElBQWdEc0Isa0JBQWhEO0FBQ0QsV0FORCxNQU1PLElBQUliLGVBQWUsS0FBSyxDQUF4QixFQUEyQjtBQUNoQ00sWUFBQUEsTUFBTSxDQUFDZixPQUFELENBQU4sR0FBa0JzQixrQkFBbEI7QUFDRCxXQUZNLE1BRUE7QUFDTCxnQkFBSSxDQUFDUCxNQUFNLENBQUNmLE9BQUQsQ0FBWCxFQUFzQjtBQUNwQmUsY0FBQUEsTUFBTSxDQUFDZixPQUFELENBQU4sR0FBa0IsRUFBbEI7QUFDRDs7QUFFRGUsWUFBQUEsTUFBTSxDQUFDZixPQUFELENBQU4sQ0FBZ0JxQixzQkFBaEIsSUFBMENDLGtCQUExQztBQUNEO0FBQ0Y7QUFDRjtBQUNGLEdBckN5RSxDQXVDMUU7QUFDQTtBQUNBOzs7QUFDQUMsRUFBQUEsTUFBTSxDQUFDQyxJQUFQLENBQVlSLFlBQVosRUFDR1MsSUFESCxDQUNRLFVBQUNDLEtBQUQsRUFBUUMsTUFBUjtBQUFBLFdBQXFCN0IsS0FBSyxDQUFDWSxXQUFQLENBQTJCZ0IsS0FBM0IsSUFBcUM1QixLQUFLLENBQUNZLFdBQVAsQ0FBMkJpQixNQUEzQixDQUFwQyxHQUF5RSxDQUF6RSxHQUE2RSxDQUFDLENBQWxHO0FBQUEsR0FEUixFQUVHQyxPQUZILENBRVcsVUFBQUMsbUJBQW1CLEVBQUk7QUFDOUIsUUFBTUMsaUJBQWlCLEdBQUloQyxLQUFLLENBQUNZLFdBQVAsQ0FBMkJtQixtQkFBM0IsQ0FBMUI7QUFDQWQsSUFBQUEsTUFBTSxvQ0FBa0NlLGlCQUFsQyxTQUFOLEdBQWtFZCxZQUFZLENBQUNhLG1CQUFELENBQTlFO0FBQ0QsR0FMSDtBQU9BLFNBQU9kLE1BQVA7QUFDRDs7QUFFRCxTQUFTZ0IsTUFBVCxDQUNFakIsR0FERixFQUVFVCxLQUZGLEVBR0U7QUFDQSxTQUFPLE9BQU9TLEdBQVAsS0FBZSxVQUFmLEdBQTRCQSxHQUFHLENBQUNULEtBQUQsQ0FBL0IsR0FBeUNTLEdBQWhEO0FBQ0Q7O0FBTUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU2tCLHNDQUFULENBQ0VDLFlBREYsRUFFa0Q7QUFDaEQsTUFBSSxDQUFDQSxZQUFMLEVBQW1CO0FBQ2pCLFdBQU9yQixTQUFQO0FBQ0QsR0FIK0MsQ0FLaEQ7OztBQUNBLE1BQU1zQixZQUFZLEdBQUdYLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZUyxZQUFaLEVBQTBCLENBQTFCLENBQXJCO0FBQ0EsTUFBTUUsUUFBUSxHQUFHLE9BQVFGLFlBQUQsQ0FBc0JDLFlBQXRCLENBQVAsS0FBK0MsUUFBL0MsR0FBMERBLFlBQTFELEdBQXlFdEIsU0FBMUY7O0FBRUEsTUFBSSxDQUFDdUIsUUFBTCxFQUFlO0FBQ2IsV0FBT3ZCLFNBQVA7QUFDRDs7QUFFRCxTQUFPO0FBQ0x3QixJQUFBQSxHQUFHLEVBQUVELFFBREE7QUFFTDlCLElBQUFBLEtBQUssRUFBRzRCLFlBQUQsQ0FBc0JFLFFBQXRCO0FBRkYsR0FBUDtBQUlEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsT0FBTyxTQUFTRSxpQkFBVCxDQUFtQ2hDLEtBQW5DLEVBQWdGO0FBQUEsTUFDL0RpQyxnQkFEK0QsR0FDSWpDLEtBREosQ0FDN0U0QixZQUQ2RTtBQUFBLE1BQzdDbkMsS0FENkMsR0FDSU8sS0FESixDQUM3Q1AsS0FENkM7QUFBQSxNQUN0Q3lDLE9BRHNDLEdBQ0lsQyxLQURKLENBQ3RDa0MsT0FEc0M7QUFBQSxNQUN4QkMsU0FEd0IsR0FDSW5DLEtBREosQ0FDN0JTLEdBRDZCO0FBQUEsTUFDVjJCLFNBRFUsaUNBQ0lwQyxLQURKOztBQUdyRixNQUFNNEIsWUFBWSxHQUFHRCxzQ0FBc0MsQ0FBQ00sZ0JBQUQsQ0FBM0Q7QUFDQSxNQUFNSSxlQUFlLEdBQUdyRCx1QkFBdUIsQ0FBQ1MsS0FBRCxDQUEvQztBQUNBLE1BQU02QywyQkFBMkIsR0FBR3JELGtDQUFrQyxDQUFDb0QsZUFBRCxFQUFrQkQsU0FBbEIsQ0FBdEU7QUFDQSxNQUFNRyxjQUFjLEdBQUdyRCx1Q0FBdUMsQ0FBQ21ELGVBQUQsRUFBa0JELFNBQWxCLENBQTlEOztBQU5xRiw4QkFPM0R4RCxvQkFBb0IsQ0FBQzJELGNBQUQsQ0FQdUM7QUFBQSxNQU83RUMsYUFQNkUseUJBTzdFQSxhQVA2RSxFQVNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFNQyxrQ0FBaUUsR0FBRyxFQUExRTtBQUNBLE1BQU1DLHVCQUEyQyxHQUFHLEVBQXBEO0FBQ0EsTUFBTUMsZUFBc0IsR0FBRyxFQUEvQjs7QUFFQSxNQUFNQyxlQUFlLEdBQUcsU0FBbEJBLGVBQWtCLENBQUNDLFlBQUQsRUFBZ0M7QUFBQSxRQUM5Q3BDLEdBRDhDLEdBQzdCb0MsWUFENkIsQ0FDOUNwQyxHQUQ4QztBQUFBLFFBQ3RDcUMsSUFEc0MsaUNBQzdCRCxZQUQ2Qjs7QUFHdEQsUUFBSXBDLEdBQUosRUFBUztBQUNQa0MsTUFBQUEsZUFBZSxDQUFDSSxJQUFoQixDQUFxQnJCLE1BQU0sQ0FBQ2pCLEdBQUQsRUFBTVQsS0FBTixDQUEzQjtBQUNELEtBTHFELENBT3REOzs7QUFFQXlDLElBQUFBLGtDQUFrQyxDQUFDTSxJQUFuQyxDQUF3QzlELGtDQUFrQyxDQUFDb0QsZUFBRCxFQUFrQlMsSUFBbEIsQ0FBMUU7QUFDQUosSUFBQUEsdUJBQXVCLENBQUNLLElBQXhCLENBQTZCN0QsdUNBQXVDLENBQUNtRCxlQUFELEVBQWtCUyxJQUFsQixDQUFwRTtBQUNELEdBWEQsQ0FyQnFGLENBa0NyRjs7O0FBQ0EsTUFBSWxCLFlBQVksS0FBS3JCLFNBQXJCLEVBQWdDO0FBQzlCcUMsSUFBQUEsZUFBZSxDQUFDaEIsWUFBWSxDQUFDNUIsS0FBZCxDQUFmLENBRDhCLENBRzlCOztBQUNBLFFBQU1nRCwrQkFBK0IsR0FBR3ZELEtBQUssQ0FBQ3dELFVBQU4sQ0FBaUJyQixZQUFZLENBQUNHLEdBQTlCLE1BQXVDeEIsU0FBL0U7O0FBQ0EsUUFBSXlDLCtCQUFKLEVBQXFDO0FBQ25DSixNQUFBQSxlQUFlLENBQUNuRCxLQUFLLENBQUN3RCxVQUFOLENBQWlCckIsWUFBWSxDQUFDRyxHQUE5QixDQUFELENBQWY7QUFDRCxLQVA2QixDQVM5Qjs7O0FBQ0EsUUFBSUcsT0FBSixFQUFhO0FBQ1g7QUFDQSxVQUFNZ0Isb0JBQW9CLEdBQUd0QixZQUFZLENBQUM1QixLQUFiLElBQXNCNEIsWUFBWSxDQUFDNUIsS0FBYixDQUFtQm1ELFFBQXRFOztBQUVBLFVBQUlELG9CQUFvQixJQUFJQSxvQkFBb0IsQ0FBQ2hCLE9BQUQsQ0FBaEQsRUFBMkQ7QUFDekRVLFFBQUFBLGVBQWUsQ0FBQ00sb0JBQW9CLENBQUNoQixPQUFELENBQXJCLENBQWY7QUFDRCxPQU5VLENBT1g7OztBQUNBLFVBQU1rQixhQUFhLEdBQUdKLCtCQUErQixJQUFJdkQsS0FBSyxDQUFDd0QsVUFBTixDQUFpQnJCLFlBQVksQ0FBQ0csR0FBOUIsRUFBbUNvQixRQUE1Rjs7QUFDQSxVQUFJQyxhQUFhLElBQUlBLGFBQWEsQ0FBQ2xCLE9BQUQsQ0FBbEMsRUFBNkM7QUFDM0NVLFFBQUFBLGVBQWUsQ0FBQ1EsYUFBYSxDQUFDbEIsT0FBRCxDQUFkLENBQWY7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsTUFBTW1CLGlDQUFpQyxHQUFHbkMsTUFBTSxDQUFDb0MsTUFBUCxPQUFBcEMsTUFBTSxHQUFRLEVBQVIsU0FBZXVCLGtDQUFmLEVBQWhEO0FBQ0EsTUFBTWMsK0NBQStDLEdBQUdwRSxpREFBaUQsQ0FDdkdrRCxlQUR1RyxFQUV2R2dCLGlDQUZ1RyxDQUF6RztBQUlBLE1BQU1HLHNCQUFzQixHQUFHdEMsTUFBTSxDQUFDb0MsTUFBUCxPQUFBcEMsTUFBTSxHQUNuQyxFQURtQyxVQUUvQnFDLCtDQUYrQixTQUVxQmIsdUJBRnJCLEdBQXJDLENBakVxRixDQXFFckY7O0FBQ0EsTUFBTWUsa0JBQWtCLEdBQUcxRCx1QkFBdUIsQ0FBQ3lELHNCQUFELEVBQXlCL0QsS0FBekIsQ0FBbEQ7QUFFQWtELEVBQUFBLGVBQWUsQ0FBQ0ksSUFBaEIsQ0FDRWhELHVCQUF1QixDQUNyQlosaURBQWlELENBQUNrRCxlQUFELEVBQWtCQywyQkFBbEIsQ0FENUIsRUFFckI3QyxLQUZxQixDQUR6QixFQXhFcUYsQ0ErRXJGOztBQUNBa0QsRUFBQUEsZUFBZSxDQUFDSSxJQUFoQixDQUFxQmhELHVCQUF1QixDQUFDeUMsYUFBRCxFQUFnQi9DLEtBQWhCLENBQTVDLEVBaEZxRixDQWtGckY7O0FBQ0EsTUFBSTBDLFNBQUosRUFBZTtBQUNiUSxJQUFBQSxlQUFlLENBQUNJLElBQWhCLENBQXFCckIsTUFBTSxDQUFDUyxTQUFELEVBQVluQyxLQUFaLENBQTNCO0FBQ0Q7O0FBRUQsTUFBTTBELFFBQVEsR0FBR3hDLE1BQU0sQ0FBQ29DLE1BQVAsT0FBQXBDLE1BQU0sR0FBUSxFQUFSLFNBQWV5QixlQUFmLEVBQXZCLENBdkZxRixDQXdGckY7O0FBQ0EsTUFBTWdCLFNBQVMscUJBQVFGLGtCQUFSLEVBQStCQyxRQUEvQixDQUFmO0FBRUEsU0FBT0MsU0FBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVNDLFlBQVQsQ0FBOEI1RCxLQUE5QixFQUEyRTtBQUN6RTtBQUNBO0FBQ0EsTUFBSSxDQUFDQSxLQUFLLENBQUNQLEtBQVAsSUFBZ0IsQ0FBQ08sS0FBSyxDQUFDUCxLQUFOLENBQVl3RCxVQUFqQyxFQUE2QztBQUMzQ2pELElBQUFBLEtBQUsscUJBQVFBLEtBQVI7QUFBZVAsTUFBQUEsS0FBSyxFQUFFWjtBQUF0QixNQUFMO0FBQ0Q7O0FBRUQsTUFBTThFLFNBQVMsR0FBRzNCLGlCQUFpQixDQUFDaEMsS0FBRCxDQUFuQyxDQVB5RSxDQVN6RTs7QUFDQSxTQUFPUSxvQ0FBb0MsQ0FBQ21ELFNBQUQsRUFBWTNELEtBQUssQ0FBQ1AsS0FBbEIsQ0FBM0M7QUFDRCxDLENBRUQ7QUFDQTtBQUNBOzs7QUFDQSxJQUFNb0Usb0JBQW9CLEdBQUcsQ0FBQyxJQUFELEVBQU8sS0FBUCxFQUFjLFNBQWQsRUFBeUIsY0FBekIsRUFBeUMsS0FBekMsQ0FBN0I7O0FBRUEsSUFBTUMsb0JBQW9CLEdBQUcsU0FBdkJBLG9CQUF1QixDQUFDQyxhQUFELEVBQXFCL0QsS0FBckIsRUFBaUNnRSxHQUFqQyxFQUE4QztBQUN6RSxNQUFNQyxhQUFrQixHQUFHLEVBQTNCO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLE9BQU9ILGFBQVAsS0FBeUIsUUFBM0MsQ0FGeUUsQ0FHekU7O0FBQ0EsT0FBSyxJQUFJaEMsR0FBVCxJQUFnQi9CLEtBQWhCLEVBQXVCO0FBQ3JCO0FBQ0EsUUFBSWtFLFNBQVMsSUFBSSxDQUFDdkYsV0FBVyxDQUFDb0QsR0FBRCxDQUE3QixFQUFvQyxTQUZmLENBSXJCO0FBQ0E7O0FBQ0EsUUFBTW9DLFlBQVksR0FBR3JGLGdCQUFnQixDQUFDaUMsT0FBakIsQ0FBeUJnQixHQUF6QixNQUF5QyxDQUFDLENBQTFDLElBQStDOEIsb0JBQW9CLENBQUM5QyxPQUFyQixDQUE2QmdCLEdBQTdCLE1BQXNDLENBQUMsQ0FBM0c7QUFDQSxRQUFJb0MsWUFBSixFQUFrQjtBQUVsQkYsSUFBQUEsYUFBYSxDQUFDbEMsR0FBRCxDQUFiLEdBQXFCL0IsS0FBSyxDQUFDK0IsR0FBRCxDQUExQjtBQUNEOztBQUVEa0MsRUFBQUEsYUFBYSxDQUFDRCxHQUFkLEdBQW9CQSxHQUFwQjtBQUVBLFNBQU9DLGFBQVA7QUFDRCxDQW5CRDs7QUEyQkE7QUFDQTtBQUNBO0FBQ0EsSUFBTUcsY0FBYyxnQkFBRzNGLEtBQUssQ0FBQzRGLFVBQU4sQ0FBMEMsVUFBQ3JFLEtBQUQsRUFBUWdFLEdBQVIsRUFBZ0I7QUFDL0UsTUFBTU0sSUFBSSxHQUFHdEUsS0FBSyxDQUFDdUUsRUFBTixJQUFZdkUsS0FBSyxDQUFDd0UsR0FBL0I7QUFDQSxNQUFNQyxTQUFTLEdBQUdYLG9CQUFvQixDQUFDUSxJQUFELEVBQU90RSxLQUFQLEVBQWNnRSxHQUFkLENBQXRDO0FBRUEsc0JBQU92RixLQUFLLENBQUNpRyxhQUFOLENBQW9CSixJQUFwQixFQUEwQkcsU0FBMUIsQ0FBUDtBQUNELENBTHNCLENBQXZCO0FBZ0JBLE9BQU8sU0FBU0UsTUFBVCxDQUFnREMsT0FBaEQsRUFBc0Y7QUFDM0YsTUFBSUMsS0FBSyxHQUFHLEVBQVo7O0FBRUEsTUFBSUQsT0FBTyxDQUFDaEQsWUFBWixFQUEwQjtBQUN4QixRQUFNa0QsWUFBWSxHQUFHNUQsTUFBTSxDQUFDQyxJQUFQLENBQVl5RCxPQUFPLENBQUNoRCxZQUFwQixFQUFrQyxDQUFsQyxDQUFyQjs7QUFDQSxRQUFJLE9BQVFnRCxPQUFPLENBQUNoRCxZQUFULENBQThCa0QsWUFBOUIsQ0FBUCxLQUF1RCxRQUEzRCxFQUFxRTtBQUNuRUQsTUFBQUEsS0FBSyxRQUFNQyxZQUFYO0FBQ0Q7QUFDRjs7QUFFRCxNQUFNQyw2QkFBNkIsR0FBR3JHLE1BQU0sQ0FBQzBGLGNBQUQsRUFBaUI7QUFDM0RTLElBQUFBLEtBQUssRUFBTEEsS0FEMkQ7QUFDcEQ7QUFDUDtBQUNBO0FBQ0FuRSxJQUFBQSxNQUFNLGNBQ0ptRSxLQUFLLFNBQ0dBLEtBQUssQ0FDTkcsT0FEQyxDQUNPLGlCQURQLEVBQzBCLE9BRDFCLEVBRURBLE9BRkMsQ0FFTyxNQUZQLEVBRWUsR0FGZixFQUdEQyxXQUhDLEVBREgsR0FLRCxFQU5BO0FBSnFELEdBQWpCLENBQU4sQ0FZbkNyQixZQVptQyxDQUF0QyxDQVYyRixDQXdCM0Y7O0FBQ0FtQixFQUFBQSw2QkFBNkIsQ0FBQ0csWUFBOUIscUJBQ01OLE9BQU8sQ0FBQ00sWUFEZDtBQUVFdEQsSUFBQUEsWUFBWSxFQUFFZ0QsT0FBTyxDQUFDaEQsWUFGeEI7QUFHRTRDLElBQUFBLEdBQUcsRUFBRUksT0FBTyxDQUFDSjtBQUhmO0FBTUEsc0JBQU8vRixLQUFLLENBQUMwRyxJQUFOLENBQVdKLDZCQUFYLENBQVA7QUFVRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BlbW90aW9uL3N0eWxlZC1iYXNlJztcbmltcG9ydCBpc1Byb3BWYWxpZCBmcm9tICdAZW1vdGlvbi9pcy1wcm9wLXZhbGlkJztcbmltcG9ydCB7IGV4dHJhY3RUaGVtYWJsZVByb3BzIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBiYXNlVGhlbWUgfSBmcm9tICcuL2Jhc2VUaGVtZSc7XG5pbXBvcnQgeyBwcm9wc01hcHBpbmdLZXlzLCBtYXBwaW5ncywgUHJvcHNNYXBwaW5ncywgUmVzcG9uc2l2ZVByb3BNYXBwaW5nIH0gZnJvbSAnLi9yZXNwb25zaXZlcHJvcHMnO1xuaW1wb3J0IHsgZ2V0VGhlbWVCcmVha3BvaW50TmFtZXMgfSBmcm9tICcuL2dldFRoZW1lQnJlYWtwb2ludHMnO1xuaW1wb3J0IHtcbiAgZXh0cmFjdEJyZWFrcG9pbnRCbG9ja1RoZW1pbmdQcm9wcyxcbiAgZmlsdGVyT3V0Tm9uQnJlYWtwb2ludEJsb2NrVGhlbWluZ1Byb3BzLFxuICBtYXBCcmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHNUb0Jhc2VUaGVtbWluZ1Byb3BzXG59IGZyb20gJy4vZm9ybWF0QnJlYWtwb2ludENzc0Jsb2Nrcyc7XG5pbXBvcnQge1xuICBUaGVtZSxcbiAgQ1NTT2JqZWN0LFxuICBQcm9wc1dpdGhUaGVtZSxcbiAgVGhlbWluZ1Byb3BzLFxuICBDb21wb25lbnRUaGVtZSxcbiAgSW5saW5lQ3NzLFxuICBCYXNlVGhlbWluZ1Byb3BzLFxuICBCcmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHMsXG4gIERlZmF1bHRUaGVtZVxufSBmcm9tICcuL2luZGV4JztcblxuY29uc3QgTkVTVEVEX0NTU19PQkpFQ1RfU0VMRUNUT1JTID0gWyc6JywgJyYnLCAnKicsICc+JywgJ0AnXTtcblxuY29uc3QgY29udmVydFByb3BUb0NzcyA9IChcbiAgbWFwcGluZ0tleTogc3RyaW5nLFxuICBwcm9wTWFwcGluZzogUmVzcG9uc2l2ZVByb3BNYXBwaW5nLFxuICBtYXRjaGluZ1Byb3A6IHN0cmluZyB8IG51bWJlcixcbiAgdGhlbWU6IFRoZW1lXG4pOiBDU1NPYmplY3QgPT4ge1xuICAvLyBpZiBtYXBwaW5nIGRvZXMgbm90IGhhdmUgY3NzUHJvcCBzcGVjaWZpZWQgZmFsbGJhY2sgdG8gaXQncyBrZXkgYXMgY3NzIHByb3BlcnR5IG5hbWVcbiAgY29uc3QgY3NzUHJvcE5hbWUgPSBwcm9wTWFwcGluZy5jc3NQcm9wIHx8IG1hcHBpbmdLZXk7XG4gIC8vIGlmIG1hdGNoaW5nIHByb3BzIGlzIHRoZW1hYmxlIHByb3AgdGhlbiBnZXQgaXQncyBhY3R1YWwgdmFsdWUgZnJvbSB0aGVtZSBwcm9wcyBvdGhlcndpc2VcbiAgLy8gdGhlbiBqdXN0IHBhc3MgaXQgYXMgY3NzIHByb3AgdmFsdWVcbiAgLy8gVE9ETzogdHlwZXNjcmlwdDogaXMgdGhlcmUgYSB3YXkgdG8gaW1wcm92ZSB0aG9zZSB0eXBpbmdzP1xuICBjb25zdCBjc3NQcm9wVmFsdWUgPSAhcHJvcE1hcHBpbmcudGhlbWVQcm9wID8gbWF0Y2hpbmdQcm9wIDogKHRoZW1lW3Byb3BNYXBwaW5nLnRoZW1lUHJvcF0gYXMgYW55KVttYXRjaGluZ1Byb3BdO1xuXG4gIGlmIChwcm9wTWFwcGluZy50cmFuc2Zvcm1Ub0Nzcykge1xuICAgIHJldHVybiBwcm9wTWFwcGluZy50cmFuc2Zvcm1Ub0Nzcyhjc3NQcm9wVmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBbY3NzUHJvcE5hbWVdOiBjc3NQcm9wVmFsdWVcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGNvbnZlcnRUaGVtZWRQcm9wc1RvQ3NzPFRQcm9wcyA9IGFueT4ocHJvcHM6IFRoZW1pbmdQcm9wczxUUHJvcHM+LCB0aGVtZTogVGhlbWUpOiBDU1NPYmplY3Qge1xuICAvLyAgaWYgdGhlbWUgaXMgbm90IHByb3ZpZGVkIHZpYSB0aGVtZSBwcm92aWRlciBkbyBub3QgbWFwIGFueXRoaW5nXG4gIGlmICghdGhlbWUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvLyBUT0RPOiB0eXBlc2NyaXB0OiBjYW4gdHlwaW5ncyBiZSBpbXByb3ZlZCBmb3IgdGhhdCBvYmplY3Q/XG4gIGNvbnN0IHRhcmdldENzcyA9IHt9IGFzIGFueTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgZm9yIChsZXQgbWFwcGluZ0tleSBpbiBwcm9wcykge1xuICAgIGNvbnN0IHByb3BNYXBwaW5nID0gbWFwcGluZ3NbbWFwcGluZ0tleSBhcyBrZXlvZiBQcm9wc01hcHBpbmdzXTtcbiAgICBjb25zdCBtYXRjaGluZ1Byb3AgPSAocHJvcHMgYXMgYW55KVttYXBwaW5nS2V5XTtcblxuICAgIC8vIG1vdmUgYWxvbmcgaWYgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgcHJvcCBpbiBtYXBwaW5ncyBmb3IgZ2l2ZW4ga2V5IGZvdW5kXG4gICAgaWYgKCFwcm9wTWFwcGluZykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGlmIG1hdGNoaW5nIHByb3AgaXMgdHlwZW9mIHN0cmluZyBpdCBtZWFucyBpdCdzIG5vdCByZXNwb25zaXZlXG4gICAgaWYgKHR5cGVvZiBtYXRjaGluZ1Byb3AgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBtYXRjaGluZ1Byb3AgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25zdCBjc3NPYmplY3QgPSBjb252ZXJ0UHJvcFRvQ3NzKG1hcHBpbmdLZXksIHByb3BNYXBwaW5nLCBtYXRjaGluZ1Byb3AsIHRoZW1lKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZm9yIChsZXQgbWFwcGluZ0tleSBpbiBjc3NPYmplY3QpIHtcbiAgICAgICAgdGFyZ2V0Q3NzW21hcHBpbmdLZXldID0gY3NzT2JqZWN0W21hcHBpbmdLZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBpdCdzIG5vdCBzdHJpbmcgaXQgbmVlZHMgdG8gYmUgb2JqZWN0IHRoYXQgaGFzIHJlc3BvbnNpdmUgYnJlYWtwb2ludHMga2V5c1xuICAgICAgLy8gaGVyZSB3ZSBvbmx5IHRyYW5zbGF0ZSBhbGwgdGhlbWVkIHZhbHVlcyB0byBjc3MgdmFsdWVzLCB3ZSBkb24ndCBjcmVhdGUgbWVkaWEgcXVlcmllc1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBmb3IgKGxldCBicmVha3BvaW50S2V5IGluIG1hdGNoaW5nUHJvcCkge1xuICAgICAgICBjb25zdCBicmVha3BvaW50VmFsdWUgPSAodGhlbWUuYnJlYWtwb2ludHMgYXMgYW55KVticmVha3BvaW50S2V5XTtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdSZXNwb25zaXZlUHJvcCA9IG1hdGNoaW5nUHJvcFticmVha3BvaW50S2V5XTtcbiAgICAgICAgaWYgKGJyZWFrcG9pbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjc3NPYmplY3QgPSBjb252ZXJ0UHJvcFRvQ3NzKG1hcHBpbmdLZXksIHByb3BNYXBwaW5nLCBtYXRjaGluZ1Jlc3BvbnNpdmVQcm9wLCB0aGVtZSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBmb3IgKGxldCBtYXBwaW5nS2V5IGluIGNzc09iamVjdCkge1xuICAgICAgICAgIGlmICghdGFyZ2V0Q3NzW21hcHBpbmdLZXldKSB7XG4gICAgICAgICAgICB0YXJnZXRDc3NbbWFwcGluZ0tleV0gPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YXJnZXRDc3NbbWFwcGluZ0tleV1bYnJlYWtwb2ludEtleV0gPSBjc3NPYmplY3RbbWFwcGluZ0tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0Q3NzO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UmVzcG9uc2l2ZVByb3BzVG9NZWRpYVF1ZXJpZXMoY3NzOiBDU1NPYmplY3QsIHRoZW1lOiBUaGVtZSkge1xuICBjb25zdCB0YXJnZXQ6IGFueSA9IHt9O1xuICBjb25zdCBtZWRpYVF1ZXJpZXM6IGFueSA9IHt9O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBmb3IgKGxldCBjc3NQcm9wIGluIGNzcykge1xuICAgIGNvbnN0IGNzc1ZhbHVlID0gY3NzW2Nzc1Byb3BdO1xuICAgIGlmICghY3NzVmFsdWUgfHwgdHlwZW9mIGNzc1ZhbHVlICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGNzc1ZhbHVlKSkge1xuICAgICAgdGFyZ2V0W2Nzc1Byb3BdID0gY3NzVmFsdWU7XG4gICAgfVxuICAgIC8vIHdlIG5lZWQgdG8gbG9vayBmb3IgcmVzcG9uc2l2ZSBwcm9wcyBpbiBuZXN0ZWQgY3NzIGFzIHdlbGxcbiAgICAvLyBmb3IgZXhhbXBsZSBpbiA6aG92ZXIgb2JqZWN0XG4gICAgZWxzZSBpZiAoTkVTVEVEX0NTU19PQkpFQ1RfU0VMRUNUT1JTLmluZGV4T2YoY3NzUHJvcFswXSkgIT09IC0xKSB7XG4gICAgICB0YXJnZXRbY3NzUHJvcF0gPSBjb252ZXJ0UmVzcG9uc2l2ZVByb3BzVG9NZWRpYVF1ZXJpZXMoY3NzVmFsdWUgYXMgQ1NTT2JqZWN0LCB0aGVtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZm9yIChsZXQgcG90ZW50aWFsQnJlYWtwb2ludEtleSBpbiBjc3NWYWx1ZSkge1xuICAgICAgICBjb25zdCBicmVha3BvaW50VmFsdWUgPSAodGhlbWUuYnJlYWtwb2ludHMgYXMgYW55KVtwb3RlbnRpYWxCcmVha3BvaW50S2V5XTtcbiAgICAgICAgY29uc3QgdmFsdWVGb3JCcmVha3BvaW50ID0gKGNzc1ZhbHVlIGFzIGFueSlbcG90ZW50aWFsQnJlYWtwb2ludEtleV07XG5cbiAgICAgICAgaWYgKGJyZWFrcG9pbnRWYWx1ZSkge1xuICAgICAgICAgIC8vIGFkZCBtZWRpYSBxdWVyeSBrZXkgdG8gbWVkaWFRdWVyaWVzIG9iamVjdCBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBnb3Qgb25lXG4gICAgICAgICAgaWYgKCFtZWRpYVF1ZXJpZXNbcG90ZW50aWFsQnJlYWtwb2ludEtleV0pIHtcbiAgICAgICAgICAgIG1lZGlhUXVlcmllc1twb3RlbnRpYWxCcmVha3BvaW50S2V5XSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZWRpYVF1ZXJpZXNbcG90ZW50aWFsQnJlYWtwb2ludEtleV1bY3NzUHJvcF0gPSB2YWx1ZUZvckJyZWFrcG9pbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYnJlYWtwb2ludFZhbHVlID09PSAwKSB7XG4gICAgICAgICAgdGFyZ2V0W2Nzc1Byb3BdID0gdmFsdWVGb3JCcmVha3BvaW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGFyZ2V0W2Nzc1Byb3BdKSB7XG4gICAgICAgICAgICB0YXJnZXRbY3NzUHJvcF0gPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YXJnZXRbY3NzUHJvcF1bcG90ZW50aWFsQnJlYWtwb2ludEtleV0gPSB2YWx1ZUZvckJyZWFrcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBtZWRpYSBxdWVyaWVzIG5lZWQgdG8gYmUgaGFuZGxlZCBpbiB2ZXJ5IGNhcmVmdWwgd2F5IGFzIG9yZGVyIG1hdHRlcnNcbiAgLy8gc28gbWVkaWEgbWluLXdpZHRoIHdpdGggc21hbGxlciBweCB2YWx1ZSBhbHdheXMgYXBwZXIgYmVmb3JlIG1lZGlhIG1pbi13aWR0aCB3aXRoIGxhcmdlciBweCB2YWx1ZVxuICAvLyBpbiByZXN1bHRpbmcgc3R5bGVcbiAgT2JqZWN0LmtleXMobWVkaWFRdWVyaWVzKVxuICAgIC5zb3J0KChmaXJzdCwgc2Vjb25kKSA9PiAoKHRoZW1lLmJyZWFrcG9pbnRzIGFzIGFueSlbZmlyc3RdID4gKHRoZW1lLmJyZWFrcG9pbnRzIGFzIGFueSlbc2Vjb25kXSA/IDEgOiAtMSkpXG4gICAgLmZvckVhY2goc29ydGVkTWVkaWFRdWVyeUtleSA9PiB7XG4gICAgICBjb25zdCBtZWRpYVF1ZXJ5UHhWYWx1ZSA9ICh0aGVtZS5icmVha3BvaW50cyBhcyBhbnkpW3NvcnRlZE1lZGlhUXVlcnlLZXldO1xuICAgICAgdGFyZ2V0W2BAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAke21lZGlhUXVlcnlQeFZhbHVlfXB4KWBdID0gbWVkaWFRdWVyaWVzW3NvcnRlZE1lZGlhUXVlcnlLZXldO1xuICAgIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGdldENzczxUUHJvcHM+KFxuICBjc3M6IElubGluZUNzczxQcm9wc1dpdGhUaGVtZTxUaGVtaW5nUHJvcHM8VFByb3BzPj4+LFxuICBwcm9wczogUHJvcHNXaXRoVGhlbWU8VGhlbWluZ1Byb3BzPFRQcm9wcz4+XG4pIHtcbiAgcmV0dXJuIHR5cGVvZiBjc3MgPT09ICdmdW5jdGlvbicgPyBjc3MocHJvcHMpIDogY3NzO1xufVxuXG50eXBlIERlZmF1bHRUaGVtZVByb3BEZWZpbml0aW9uPFRQcm9wcz4gPSB7XG4gIGtleTogc3RyaW5nO1xuICBwcm9wcz86IENvbXBvbmVudFRoZW1lPFRQcm9wcz47XG59O1xuLyoqXG4gKiBgPHRoZW1lZENvbXBvbmVudD4uZGVmYXVsdFRoZW1lYCBzcGVjaWZpZXMgaXQncyBgcHJvcHNgIGluIG5lc3RlZCBvYmplY3Qgd2hpY2gga2V5IGlzIHVzZWQgYXMgYHRoZW1lS2V5YFxuICpcbiAqIFRPRE86IHdyaXRlIHVuaXQgdGVzdHMhXG4gKiBAcGFyYW0gZGVmYXVsdFRoZW1lXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3REZWZhdWx0VGhlbWVGcm9tVGhlbWVkQ29tcG9uZW50PFRQcm9wcz4oXG4gIGRlZmF1bHRUaGVtZT86IERlZmF1bHRUaGVtZTxUUHJvcHM+XG4pOiBEZWZhdWx0VGhlbWVQcm9wRGVmaW5pdGlvbjxUUHJvcHM+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKCFkZWZhdWx0VGhlbWUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0aGVtZSBzaG91bGQgaGF2ZSBvbmx5IG9uZSBrZXksIHNvIHdlIHRyeSB0byB0YWtlIGZpcnN0IG9uZSwgd2UgYWxzbyBleHBlY3QgYW4gYG9iamVjdGAgdW5kZXIgaXRcbiAgY29uc3QgcG90ZW50aWFsS2V5ID0gT2JqZWN0LmtleXMoZGVmYXVsdFRoZW1lKVswXTtcbiAgY29uc3QgdGhlbWVLZXkgPSB0eXBlb2YgKGRlZmF1bHRUaGVtZSBhcyBhbnkpW3BvdGVudGlhbEtleV0gPT09ICdvYmplY3QnID8gcG90ZW50aWFsS2V5IDogdW5kZWZpbmVkO1xuXG4gIGlmICghdGhlbWVLZXkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBrZXk6IHRoZW1lS2V5LFxuICAgIHByb3BzOiAoZGVmYXVsdFRoZW1lIGFzIGFueSlbdGhlbWVLZXldXG4gIH07XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBleHBvcnRlZCBvbmx5IGJlY2F1c2Ugb2YgdW5pdCB0ZXN0ICEhIVxuICpcbiAqIGZvbGxvd2luZyBkaWFncmFtIHNob3dzIHRoZW1lIHByb3BzIG9yZGVyICh2YWx1ZXMgaW4gYnJhY2tldHMpXG4gKlxuICogfCB0aGVtZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0aGVtZWQgY29tcG9uZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaW5saW5lICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqIHwgYFt0aGVtZV0uY29tcG9uZW50c1tjb21wb25lbnQtdGhlbWUtbmFtZV1gICAgICAgIHwgYHRoZW1lZCh7ZGVmYXVsdFRoZW1lOntbY29tcG9uZW50LXRoZW1lLW5hbWVdOnt9fX0pYCB8IGA8Qm94IGJnPVwicHJpbWFyeVwiYCAgICAgICAgICAgICB8XG4gKiB8ICoqKDIpKiogYGNvbXBvbmVudC5icmVha3BvaW50QmxvY2tQcm9wc2AgICAgICAgICB8ICoqKDEpKiogYGRlZmF1bHRUaGVtZS5icmVha3BvaW50QmxvY2tQcm9wc2AgICAgICAgICAgfCAqKigxMykqKiBgYnJlYWtwb2ludEJsb2NrUHJvcHNgIHxcbiAqIHwgKiooNikqKiBgY29tcG9uZW50LmJhc2VUaGVtaW5nUHJvcHNgICAgICAgICAgICAgIHwgKiooNSkqKiBgZGVmYXVsdFRoZW1lLmJhc2VUaGVtaW5nUHJvcHNgICAgICAgICAgICAgICB8ICoqKDE0KSoqIGBiYXNlVGhlbWluZ1Byb3BzYCAgICAgfFxuICogfCAqKigxMCkqKiBgY29tcG9uZW50LmNzc1Byb3BgICAgICAgICAgICAgICAgICAgICAgfCAqKig5KSoqIGBkZWZhdWx0VGhlbWUuY3NzUHJvcGAgICAgICAgICAgICAgICAgICAgICAgIHwgKiooMTUpKiogYGNzc1Byb3BgICAgICAgICAgICAgICB8XG4gKiB8ICoqKDQpKiogYGNvbXBvbmVudC52YXJpYW50LmJyZWFrcG9pbnRCbG9ja1Byb3BzYCB8ICoqKDMpKiogYGRlZmF1bHRUaGVtZS52YXJpYW50LmJyZWFrcG9pbnRCbG9ja1Byb3BzYCAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgKiooOCkqKiBgY29tcG9uZW50LnZhcmlhbnQuYmFzZVRoZW1pbmdQcm9wc2AgICAgIHwgKiooNykqKiBgZGVmYXVsdFRoZW1lLnZhcmlhbnQuYmFzZVRoZW1pbmdQcm9wc2AgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAqKigxMikqKiBgY29tcG9uZW50LnZhcmlhbnQuY3NzUHJvcGAgICAgICAgICAgICAgfCAqKigxMSkqKiBgZGVmYXVsdFRoZW1lLnZhcmlhbnQuY3NzUHJvcGAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiBAcGFyYW0gcHJvcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlVGhlbWluZ1Byb3BzPFRQcm9wcz4ocHJvcHM6IFByb3BzV2l0aFRoZW1lPFRoZW1pbmdQcm9wczxUUHJvcHM+Pikge1xuICBjb25zdCB7IGRlZmF1bHRUaGVtZTogZGVmYXVsdFRoZW1lUHJvcCwgdGhlbWUsIHZhcmlhbnQsIGNzczogaW5saW5lQ3NzLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzO1xuXG4gIGNvbnN0IGRlZmF1bHRUaGVtZSA9IGV4dHJhY3REZWZhdWx0VGhlbWVGcm9tVGhlbWVkQ29tcG9uZW50KGRlZmF1bHRUaGVtZVByb3ApO1xuICBjb25zdCBicmVha3BvaW50TmFtZXMgPSBnZXRUaGVtZUJyZWFrcG9pbnROYW1lcyh0aGVtZSk7XG4gIGNvbnN0IGJyZWFrcG9pbnRCbG9ja1RoZW1pbmdQcm9wcyA9IGV4dHJhY3RCcmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHMoYnJlYWtwb2ludE5hbWVzLCByZXN0UHJvcHMpO1xuICBjb25zdCByZW1haW5pbmdQcm9wcyA9IGZpbHRlck91dE5vbkJyZWFrcG9pbnRCbG9ja1RoZW1pbmdQcm9wcyhicmVha3BvaW50TmFtZXMsIHJlc3RQcm9wcyk7XG4gIGNvbnN0IHsgdGhlbWFibGVQcm9wcyB9ID0gZXh0cmFjdFRoZW1hYmxlUHJvcHMocmVtYWluaW5nUHJvcHMpO1xuXG4gIC8vIGZpcnN0IHdlIG5lZWQgdG8gY2hlY2sgd2hlcmUgdGhlbWVkIHByb3BzIGFuZCBjc3MgcHJvcHMgYXJlIGRlZmluZWQgYW5kIG1lcmdlIHRoZW1cbiAgLy8gLy8gY3NzIHByb3BzIG5lZWQgdG8gbWVyZ2VkIHNlcGFyYXRlbHkgYXMgdGhvc2UgZG8gbm90IG5lZWQgdG8gYmUgcHJvY2Vzc2VkIHRvIGV4dHJhY3QgY3NzXG4gIC8vIE1lcmdpbmcgb3JkZXJcbiAgLy8gMSAtICBwcm9wcyBkZWZpbmVkIGluIGRlZmF1bHRUaGVtZSBwcm9wcyAgYXMgdGhvc2UgYXJlIGRlZmF1bHRzXG4gIC8vIDIgLSAgcHJvcHMgZGVmaW5lZCBpbiB0aGVtZS5jb21wb25lbnRzIGZvciBnaXZlbiBgZGVmYXVsdFRoZW1lLmtleWAgYXMgdGhvc2UgYXJlIGRlZmF1bHRzXG4gIC8vIDMgLSAgcHJvcHMgZGVmaW5lZCBpbiBkZWZhdWx0VGhlbWUgdmFyaWFudCBwcm9wIGlmIHByb3BzLnZhcmlhbnQgaXMgZGVmaW5lZFxuICAvLyA0IC0gIHByb3BzIGRlZmluZWQgaW4gdGhlbWUuY29tcG9uZW50c1tddmFyaWFudHMgaWYgcHJvcHMudmFyaWFudCBpcyBkZWZpbmVkXG4gIC8vIDUgLSAgcHJvcHMgZGVmaW5lZCBkaXJlY3RseSBvbiBjb21wb25lbnRcbiAgY29uc3QgYnJlYWtwb2ludEJsb2NrVGhlbWluZ1Byb3BzVG9NZXJnZTogQnJlYWtwb2ludEJsb2NrVGhlbWluZ1Byb3BzW10gPSBbXTtcbiAgY29uc3QgYmFzZVRoZW1pbmdQcm9wc1RvTWVyZ2U6IEJhc2VUaGVtaW5nUHJvcHNbXSA9IFtdO1xuICBjb25zdCBjc3NQcm9wc1RvTWVyZ2U6IGFueVtdID0gW107XG5cbiAgY29uc3QgYWRkUHJvcHNUb01lcmdlID0gKHByb3BzVG9NZXJnZTogVGhlbWluZ1Byb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjc3MsIC4uLnJlc3QgfSA9IHByb3BzVG9NZXJnZTtcblxuICAgIGlmIChjc3MpIHtcbiAgICAgIGNzc1Byb3BzVG9NZXJnZS5wdXNoKGdldENzcyhjc3MsIHByb3BzKSk7XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IGJyZWFrcG9pbnQgQ1NTIGJsb2Nrc1xuXG4gICAgYnJlYWtwb2ludEJsb2NrVGhlbWluZ1Byb3BzVG9NZXJnZS5wdXNoKGV4dHJhY3RCcmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHMoYnJlYWtwb2ludE5hbWVzLCByZXN0KSk7XG4gICAgYmFzZVRoZW1pbmdQcm9wc1RvTWVyZ2UucHVzaChmaWx0ZXJPdXROb25CcmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHMoYnJlYWtwb2ludE5hbWVzLCByZXN0KSk7XG4gIH07XG5cbiAgLy8gIHN0YXJ0IHdpdGggcHJvcHMgZGVmaW5lZCBpbiBgZGVmYXVsdFRoZW1lYCBwcm9wIGFzIGJhc2VcbiAgaWYgKGRlZmF1bHRUaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYWRkUHJvcHNUb01lcmdlKGRlZmF1bHRUaGVtZS5wcm9wcyk7XG5cbiAgICAvLyBpZiBwcm9wcyBhcmUgZGVmaW5lZCBpbiBgdGhlbWUuY29tcG9uZW50c2Agb2JqZWN0IGZvciBgZGVmYXVsdFRoZW1lLmtleWAgbWVyZ2UgdGhlbSB3aXRoIGRlZmF1bHQgb25lc1xuICAgIGNvbnN0IGFyZUNvbXBvbmVudFByb3BzRGVmaW5lZEluVGhlbWUgPSB0aGVtZS5jb21wb25lbnRzW2RlZmF1bHRUaGVtZS5rZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKGFyZUNvbXBvbmVudFByb3BzRGVmaW5lZEluVGhlbWUpIHtcbiAgICAgIGFkZFByb3BzVG9NZXJnZSh0aGVtZS5jb21wb25lbnRzW2RlZmF1bHRUaGVtZS5rZXldKTtcbiAgICB9XG5cbiAgICAvLyB0aGVtZWQgcHJvcHMgY2FuIGFsc28gYmUgZGVmaW5lZCBmb3IgY29tcG9uZW50IHZhcmlhbnRcbiAgICBpZiAodmFyaWFudCkge1xuICAgICAgLy8gY2hlY2sgZm9yIGB2YXJpYW50YCBwcm9wIGRlZmluZWQgaW4gdGhlbWVkIGNvbXBvbmVudCBgZGVmYXVsdFRoZW1lYFxuICAgICAgY29uc3QgZGVmYXVsdFRoZW1lVmFyaWFudHMgPSBkZWZhdWx0VGhlbWUucHJvcHMgJiYgZGVmYXVsdFRoZW1lLnByb3BzLnZhcmlhbnRzO1xuXG4gICAgICBpZiAoZGVmYXVsdFRoZW1lVmFyaWFudHMgJiYgZGVmYXVsdFRoZW1lVmFyaWFudHNbdmFyaWFudF0pIHtcbiAgICAgICAgYWRkUHJvcHNUb01lcmdlKGRlZmF1bHRUaGVtZVZhcmlhbnRzW3ZhcmlhbnRdKTtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIGZvciBgdmFyaWFudGAgcHJvcCBkZWZpbmVkIGluIGB0aGVtZS5jb21wb25lbnRzYCBvYmplY3RcbiAgICAgIGNvbnN0IHRoZW1lVmFyaWFudHMgPSBhcmVDb21wb25lbnRQcm9wc0RlZmluZWRJblRoZW1lICYmIHRoZW1lLmNvbXBvbmVudHNbZGVmYXVsdFRoZW1lLmtleV0udmFyaWFudHM7XG4gICAgICBpZiAodGhlbWVWYXJpYW50cyAmJiB0aGVtZVZhcmlhbnRzW3ZhcmlhbnRdKSB7XG4gICAgICAgIGFkZFByb3BzVG9NZXJnZSh0aGVtZVZhcmlhbnRzW3ZhcmlhbnRdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBtZXJnZWRCcmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5icmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHNUb01lcmdlKTtcbiAgY29uc3QgYmFzZVRoZW1pbmdQcm9wc0Zyb21CcmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHMgPSBtYXBCcmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHNUb0Jhc2VUaGVtbWluZ1Byb3BzKFxuICAgIGJyZWFrcG9pbnROYW1lcyxcbiAgICBtZXJnZWRCcmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHNcbiAgKTtcbiAgY29uc3QgbWVyZ2VkQmFzZVRoZW1pbmdQcm9wcyA9IE9iamVjdC5hc3NpZ24oXG4gICAge30sXG4gICAgLi4uW2Jhc2VUaGVtaW5nUHJvcHNGcm9tQnJlYWtwb2ludEJsb2NrVGhlbWluZ1Byb3BzLCAuLi5iYXNlVGhlbWluZ1Byb3BzVG9NZXJnZV1cbiAgKTtcbiAgLy8gbWVyZ2VkIHRoZW1hYmxlIHByb3BzIG5lZWQgdG8gYmUgY29udmVydGVkIHRvIGNzcyBiZWZvcmUgcmV0dXJuaW5nXG4gIGNvbnN0IGNzc0Zyb21UaGVtZWRQcm9wcyA9IGNvbnZlcnRUaGVtZWRQcm9wc1RvQ3NzKG1lcmdlZEJhc2VUaGVtaW5nUHJvcHMsIHRoZW1lKTtcblxuICBjc3NQcm9wc1RvTWVyZ2UucHVzaChcbiAgICBjb252ZXJ0VGhlbWVkUHJvcHNUb0NzcyhcbiAgICAgIG1hcEJyZWFrcG9pbnRCbG9ja1RoZW1pbmdQcm9wc1RvQmFzZVRoZW1taW5nUHJvcHMoYnJlYWtwb2ludE5hbWVzLCBicmVha3BvaW50QmxvY2tUaGVtaW5nUHJvcHMpLFxuICAgICAgdGhlbWVcbiAgICApXG4gICk7XG5cbiAgLy8gb3V0IG9mIGFsbCBjb21wb25lbnQgcHJvcHMgZXh0cmFjdCB0aGVtYWJsZSBvbmVzLCBjb252ZXJ0IHRvIGNzcyBhbmQgYWRkIHRvIG1lcmdlXG4gIGNzc1Byb3BzVG9NZXJnZS5wdXNoKGNvbnZlcnRUaGVtZWRQcm9wc1RvQ3NzKHRoZW1hYmxlUHJvcHMsIHRoZW1lKSk7XG5cbiAgLy8gYXMgbGFzdCBzdGVwIGFkZCBmb3IgbWVyZ2luZyB0aG9zZSBgY3NzYCBwcm9wIHdoaWNoIGRlZmluZWQgZGlyZWN0bHkgb24gY29tcG9uZW50XG4gIGlmIChpbmxpbmVDc3MpIHtcbiAgICBjc3NQcm9wc1RvTWVyZ2UucHVzaChnZXRDc3MoaW5saW5lQ3NzLCBwcm9wcykpO1xuICB9XG5cbiAgY29uc3QgY3NzUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5jc3NQcm9wc1RvTWVyZ2UpO1xuICAvLyBmaW5hbGx5IG1lcmdlIGNzcyBmcm9tIHRoZW1lZCBwcm9wcyB3aXRoIGNzcyBmcm9tIGNzcyBwcm9wc1xuICBjb25zdCBtZXJnZWRDc3MgPSB7IC4uLmNzc0Zyb21UaGVtZWRQcm9wcywgLi4uY3NzUHJvcHMgfTtcblxuICByZXR1cm4gbWVyZ2VkQ3NzO1xufVxuXG4vKipcbiAqIHRoaXMgZnVuY3Rpb24gcmVzcG9uc2liaWxpdHkgaXMgdG8gZXh0cmFjdCBjc3Mgb2JqZWN0IGZyb21cbiAqIGJvdGggdGhlbWVkIHByb3BzICh0aGF0IHVzZSBwcm9wcyB2YWx1ZXMgZnJvbSB0aGVtZSkgYW5kIGNzcyBvYmplY3QvZnVuY3Rpb24gcHJvcHNcbiAqIFRPRE86IHBlcmhhcHMgdGhpcyBmdW5jdGlvbiBjb3VsZCBiZSB3cml0dGVuIGluIHByZXR0aWVyIHdheT9cbiAqICBAcGFyYW0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gZ2V0VGhlbWVkQ3NzPFRQcm9wcz4ocHJvcHM6IFByb3BzV2l0aFRoZW1lPFRoZW1pbmdQcm9wczxUUHJvcHM+Pikge1xuICAvLyAgaWYgdGhlbWUgaXMgbm90IHByb3ZpZGVkIHZpYSB0aGVtZSBwcm92aWRlciBvciBpbmxpbmUgdGhlbWUgcHJvcFxuICAvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCB0aGVtZVxuICBpZiAoIXByb3BzLnRoZW1lIHx8ICFwcm9wcy50aGVtZS5jb21wb25lbnRzKSB7XG4gICAgcHJvcHMgPSB7IC4uLnByb3BzLCB0aGVtZTogYmFzZVRoZW1lIH07XG4gIH1cblxuICBjb25zdCBtZXJnZWRDc3MgPSBtZXJnZVRoZW1pbmdQcm9wcyhwcm9wcyk7XG5cbiAgLy8gYXMgYSBsYXN0IHN0ZXAgd2UgbmVlZCB0byBjaGVjayBlYWNoIGNzcyBwcm9wIGlmIGl0J3MgdmFsdWUgaXMgcmVzcG9uc2l2ZVxuICByZXR1cm4gY29udmVydFJlc3BvbnNpdmVQcm9wc1RvTWVkaWFRdWVyaWVzKG1lcmdlZENzcywgcHJvcHMudGhlbWUpO1xufVxuXG4vLyBmaWx0ZXJpbmcgd2hpY2ggcHJvcHMgdG8gZm9yd2FyZCB0byBuZXh0IGNvbXBvbmVudCBpcyB0cmlja3lcbi8vIGFuZCBiZWhhdmVzIGRpZmZlcmVudGx5IGlmIG5leHQgY29tcG9uZW50IGlzIGh0bWwgZWxlbWVudCwgY3VzdG9tIGNvbXBvbmVudFxuLy8gb3IgY3VzdG9tIGNvbXBvbmVudCB3aGloY2ggaXMgdGhlbWVkIGNvbXBvbmVudFxuY29uc3QgY3VzdG9tUHJvcHNCbGFja2xpc3QgPSBbJ2FzJywgJ3RhZycsICd2YXJpYW50JywgJ2RlZmF1bHRUaGVtZScsICdjc3MnXTtcblxuY29uc3QgZmlsdGVyUHJvcHNUb0ZvcndhcmQgPSAoYmFzZUNvbXBvbmVudDogYW55LCBwcm9wczogYW55LCByZWY6IGFueSkgPT4ge1xuICBjb25zdCBmaWx0ZXJlZFByb3BzOiBhbnkgPSB7fTtcbiAgY29uc3QgaXNIdG1sVGFnID0gdHlwZW9mIGJhc2VDb21wb25lbnQgPT09ICdzdHJpbmcnO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgZm9yIChsZXQga2V5IGluIHByb3BzKSB7XG4gICAgLy8gd2hlbiBodG1sIHRhZyBpcyBwcm92aWRlZCBmb3J3YXJkIG9ubHkgdmFsaWQgaHRtbCBwcm9wcyB0byBpdFxuICAgIGlmIChpc0h0bWxUYWcgJiYgIWlzUHJvcFZhbGlkKGtleSkpIGNvbnRpbnVlO1xuXG4gICAgLy8gaWYgY3VzdG9tIGNvbXBvbmVudCBpcyBwcm92aWRlZCB2aWEgYGFzYCBwcm9wIGRvIG5vdCBmb3J3YXJkIHRoZW1hYmxlIHByb3BzIHRvIGl0IChiZywgY29sb3IsIG0sIHAgZXRjKVxuICAgIC8vIG5laWdodGVyIGZvcndhcmQgYW55IG9mIHRoZSBibGFja2xpc3RlZCBwcm9wc1xuICAgIGNvbnN0IHRoZW1hYmxlUHJvcCA9IHByb3BzTWFwcGluZ0tleXMuaW5kZXhPZihrZXkgYXMgYW55KSAhPT0gLTEgfHwgY3VzdG9tUHJvcHNCbGFja2xpc3QuaW5kZXhPZihrZXkpICE9PSAtMTtcbiAgICBpZiAodGhlbWFibGVQcm9wKSBjb250aW51ZTtcblxuICAgIGZpbHRlcmVkUHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gIH1cblxuICBmaWx0ZXJlZFByb3BzLnJlZiA9IHJlZjtcblxuICByZXR1cm4gZmlsdGVyZWRQcm9wcztcbn07XG5cbnR5cGUgVGFnID0gc3RyaW5nIHwge307IC8vIFRPRE86IGl0IHNob3VsZCBiZSBga2V5b2YgSlNYLkludHJpbnNpY0VsZW1lbnRzIHwgUmVhY3QuQ29tcG9uZW50VHlwZSA7YFxuXG50eXBlIER5bmFtaWNIdG1sVGFnUHJvcHMgPSB7XG4gIHRhZzoga2V5b2YgSlNYLkludHJpbnNpY0VsZW1lbnRzIHwgUmVhY3QuQ29tcG9uZW50VHlwZTtcbiAgYXM/OiBrZXlvZiBKU1guSW50cmluc2ljRWxlbWVudHMgfCBSZWFjdC5Db21wb25lbnRUeXBlO1xufTtcbi8qKlxuICogSGFuZGxlcyBkeW5hbWljIGh0bWwgdGFnIHJlbmRlcmluZyB2aWEgYW5kIGBhc2AgcHJvcCBhcyB3ZWxsIGFzIGZvcndhcmRzIGByZWZgIGFuZCBvbmx5IGFsbG93ZWQgaHRtbCBwcm9wcyB0byBET00gZWxlbWVudFxuICovXG5jb25zdCBEeW5hbWljSHRtbFRhZyA9IFJlYWN0LmZvcndhcmRSZWY8e30sIER5bmFtaWNIdG1sVGFnUHJvcHM+KChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IEJhc2UgPSBwcm9wcy5hcyB8fCBwcm9wcy50YWc7XG4gIGNvbnN0IG5leHRQcm9wcyA9IGZpbHRlclByb3BzVG9Gb3J3YXJkKEJhc2UsIHByb3BzLCByZWYpO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2UsIG5leHRQcm9wcyk7XG59KTtcblxudHlwZSBUYWdQcm9wczxUVGFnIGV4dGVuZHMgVGFnPiA9IChUVGFnIGV4dGVuZHMga2V5b2YgSlNYLkludHJpbnNpY0VsZW1lbnRzID8gSlNYLkludHJpbnNpY0VsZW1lbnRzW1RUYWddIDoge30pICZcbiAgKFRUYWcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRUeXBlPGluZmVyIFRFeHRlbmRQcm9wcz4gPyBQYXJ0aWFsPFRFeHRlbmRQcm9wcz4gOiB7fSk7XG5cbnR5cGUgVGhlbWVkT3B0aW9uczxUVGFnIGV4dGVuZHMgVGFnLCBUUHJvcHM+ID0ge1xuICB0YWc6IFRUYWc7XG4gIGRlZmF1bHRUaGVtZT86IHsgW25hbWU6IHN0cmluZ106IENvbXBvbmVudFRoZW1lPFRQcm9wcz4gfTtcbiAgZGVmYXVsdFByb3BzPzogVGFnUHJvcHM8VFRhZz4gJiBUUHJvcHM7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGhlbWVkPFRQcm9wcywgVFRhZyBleHRlbmRzIFRhZyA9IFRhZz4ob3B0aW9uczogVGhlbWVkT3B0aW9uczxUVGFnLCBUUHJvcHM+KSB7XG4gIGxldCBsYWJlbCA9ICcnO1xuXG4gIGlmIChvcHRpb25zLmRlZmF1bHRUaGVtZSkge1xuICAgIGNvbnN0IGNvbXBvbmVudEtleSA9IE9iamVjdC5rZXlzKG9wdGlvbnMuZGVmYXVsdFRoZW1lKVswXTtcbiAgICBpZiAodHlwZW9mIChvcHRpb25zLmRlZmF1bHRUaGVtZSBhcyBhbnkpW2NvbXBvbmVudEtleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBsYWJlbCA9IGAke2NvbXBvbmVudEtleX1gO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0eWxlZENvbXBvbmVudFdpdGhUaGVtZVByb3BzID0gc3R5bGVkKER5bmFtaWNIdG1sVGFnLCB7XG4gICAgbGFiZWwsIC8vIGxhYmVsIGlzIHRyYW5zZm9ybWVkIGZvciBkaXNwbGF5TmFtZSBvZiBzdHlsZWQgY29tcG9uZW50LFxuICAgIC8vIHRhcmdldCBpbnNlcnRlZCBhcyBjc3MgY2xhc3MgaW4gcmVzdWx0aW5nIGVsZW1lbnQgc28gdGhpcyBjb3VsZCBwb3RlbnRpYWxseSBiZSB1c2VkIGFzIGEgZmFsbGJhY2tcbiAgICAvLyB0byBzdHlsZSBjb21wb25lbnRzIHZpYSB0cmFkaXRpb25hbCBjc3NcbiAgICB0YXJnZXQ6IGB0aGVtZWQke1xuICAgICAgbGFiZWxcbiAgICAgICAgPyBgLSR7bGFiZWxcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJy0nKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9YFxuICAgICAgICA6ICcnXG4gICAgfWBcbiAgfSkoZ2V0VGhlbWVkQ3NzKTtcblxuICAvLyBkZWZhdWx0IHRoZW1lIGlzIGFsc28gcGFzc2VkIGFzIHBhcnQgb2YgZGVmYXVsdCBwcm9wc1xuICBzdHlsZWRDb21wb25lbnRXaXRoVGhlbWVQcm9wcy5kZWZhdWx0UHJvcHMgPSB7XG4gICAgLi4uKG9wdGlvbnMuZGVmYXVsdFByb3BzIGFzIGFueSksXG4gICAgZGVmYXVsdFRoZW1lOiBvcHRpb25zLmRlZmF1bHRUaGVtZSxcbiAgICB0YWc6IG9wdGlvbnMudGFnXG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0Lm1lbW8oc3R5bGVkQ29tcG9uZW50V2l0aFRoZW1lUHJvcHMpIGFzIDxUQXNUYWcgZXh0ZW5kcyBUYWcgPSBUVGFnPihcbiAgICBwcm9wczogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48XG4gICAgICB7XG4gICAgICAgIGFzPzogVEFzVGFnO1xuICAgICAgICBkZWZhdWx0VGhlbWU/OiBEZWZhdWx0VGhlbWU8VFByb3BzPjtcbiAgICAgIH0gJiBQYXJ0aWFsPHR5cGVvZiBvcHRpb25zWydkZWZhdWx0UHJvcHMnXT4gJlxuICAgICAgICBUaGVtaW5nUHJvcHM8VFByb3BzPiAmXG4gICAgICAgIFRhZ1Byb3BzPFRBc1RhZz5cbiAgICA+XG4gICkgPT4gSlNYLkVsZW1lbnQ7XG59XG4iXX0=