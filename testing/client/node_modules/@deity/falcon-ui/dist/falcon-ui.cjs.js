'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var merge = _interopDefault(require('deepmerge'));
var isPlainObject = _interopDefault(require('is-plain-object'));
var core = require('@emotion/core');
var React = require('react');
var React__default = _interopDefault(React);
var styled = _interopDefault(require('@emotion/styled-base'));
var isPropValid = _interopDefault(require('@emotion/is-prop-valid'));
var ReactDOM = _interopDefault(require('react-dom'));
var emotionTheming = require('emotion-theming');
var createCache = _interopDefault(require('@emotion/cache'));
var PropTypes = _interopDefault(require('prop-types'));

const baseTheme = {
  colors: {
    primary: '#A9CF38',
    primaryLight: '#CBDE6E',
    primaryDark: '#95B82C',
    primaryText: '#FFFFFF',
    secondary: '#EEF0F2',
    secondaryLight: '#F8F8F8',
    secondaryDark: '#E8E8E8',
    secondaryText: '#5F6367',
    error: '#E74C3C',
    errorText: '#000000',
    black: '#5f6367',
    white: '#FFFFFF',
    transparent: 'transparent',
    focus: '#005fcc'
  },
  breakpoints: {
    xs: 0,
    sm: 640,
    md: 860,
    lg: 1280,
    xl: 1920
  },
  spacing: {
    auto: 'auto',
    none: 0,
    xs: 8,
    sm: 16,
    md: 24,
    lg: 32,
    xl: 40,
    xxl: 48,
    xxxl: 64,
    full: '100%'
  },
  sizes: {
    auto: 'auto',
    none: 0,
    xs: 8,
    sm: 16,
    md: 24,
    lg: 32,
    xl: 40,
    xxl: 48,
    xxxl: 64,

    /** 12.5% */
    XXS: `${100 / 8}%`,

    /** 25.0% */
    XS: `${200 / 8}%`,

    /** 37.5% */
    SM: `${300 / 8}%`,

    /** 50.0% */
    MD: `${400 / 8}%`,

    /** 62.5% */
    LG: `${500 / 8}%`,

    /** 75.0% */
    XL: `${600 / 8}%`,

    /** 87.5% */
    XXL: `${700 / 8}%`,
    full: '100%'
  },
  fonts: {
    sans: '"Segoe UI", system-ui, sans-serif',
    mono: '"SF Mono", monospace'
  },
  fontSizes: {
    xxs: 12,
    xs: 14,
    sm: 16,
    md: 20,
    lg: 26,
    xl: 39,
    xxl: 48,
    xxxl: 96
  },
  fontWeights: {
    light: 300,
    regular: 400,
    bold: 700
  },
  lineHeights: {
    small: 1,
    default: 1.5,
    large: 2
  },
  letterSpacings: {
    normal: 'normal',
    caps: '0.025em'
  },
  borders: {
    none: 'none',
    regular: '1px solid',
    bold: '2px solid'
  },
  borderRadius: {
    none: 0,
    small: 2,
    medium: 4,
    large: 8,
    round: 333
  },
  boxShadows: {
    none: 'none',
    subtle: '0 5px 5px rgba(0,0,0,.1)',
    pronounced: '0 0 2px 0 rgba(0,0,0,.08),0 2px 8px 0 rgba(0,0,0,.16)',
    strong: '0 0 2px 0 rgba(0,0,0,.08),0 4px 16px 0 rgba(0,0,0,.16)',
    distant: '0 0 2px 0 rgba(0,0,0,.08),0 8px 32px 0 rgba(0,0,0,.16)'
  },
  easingFunctions: {
    easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
    easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
    easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
    sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
  },
  transitionDurations: {
    short: '150ms',
    standard: '250ms',
    long: '375ms'
  },
  keyframes: {},
  zIndex: {
    dropDownMenu: 600,
    backdrop: 800,
    sidebar: 1000,
    auto: 'auto'
  },
  opacities: {
    none: 0,
    sm: 0.25,
    md: 0.5,
    lg: 0.75,
    full: 1
  },
  textDecorations: {
    none: 'none',
    underline: 'underline',
    old: 'solid line-through'
  },
  components: {},
  icons: {}
};

function propsMapping(param) {
  return param;
}

const mappings = propsMapping({
  m: {
    cssProp: 'margin',
    themeProp: 'spacing'
  },
  mt: {
    cssProp: 'marginTop',
    themeProp: 'spacing'
  },
  ml: {
    cssProp: 'marginLeft',
    themeProp: 'spacing'
  },
  mr: {
    cssProp: 'marginRight',
    themeProp: 'spacing'
  },
  mb: {
    cssProp: 'marginBottom',
    themeProp: 'spacing'
  },
  mx: {
    themeProp: 'spacing',
    transformToCss: value => ({
      marginLeft: value,
      marginRight: value
    })
  },
  my: {
    themeProp: 'spacing',
    transformToCss: value => ({
      marginTop: value,
      marginBottom: value
    })
  },
  p: {
    cssProp: 'padding',
    themeProp: 'spacing'
  },
  pt: {
    cssProp: 'paddingTop',
    themeProp: 'spacing'
  },
  pl: {
    cssProp: 'paddingLeft',
    themeProp: 'spacing'
  },
  pr: {
    cssProp: 'paddingRight',
    themeProp: 'spacing'
  },
  pb: {
    cssProp: 'paddingBottom',
    themeProp: 'spacing'
  },
  px: {
    themeProp: 'spacing',
    transformToCss: value => ({
      paddingLeft: value,
      paddingRight: value
    })
  },
  py: {
    themeProp: 'spacing',
    transformToCss: value => ({
      paddingTop: value,
      paddingBottom: value
    })
  },
  height: {
    themeProp: 'sizes'
  },
  minHeight: {
    themeProp: 'sizes'
  },
  maxHeight: {
    themeProp: 'sizes'
  },
  width: {
    themeProp: 'sizes'
  },
  minWidth: {
    themeProp: 'sizes'
  },
  maxWidth: {
    themeProp: 'sizes'
  },
  size: {
    themeProp: 'sizes',
    transformToCss: value => ({
      height: value,
      width: value
    })
  },
  minSize: {
    themeProp: 'sizes',
    transformToCss: value => ({
      minHeight: value,
      minWidth: value
    })
  },
  maxSize: {
    themeProp: 'sizes',
    transformToCss: value => ({
      maxHeight: value,
      maxWidth: value
    })
  },
  gridGap: {
    themeProp: 'spacing'
  },
  gridRowGap: {
    themeProp: 'spacing'
  },
  gridColumnGap: {
    themeProp: 'spacing'
  },
  color: {
    cssProp: 'color',
    themeProp: 'colors'
  },
  bg: {
    cssProp: 'backgroundColor',
    themeProp: 'colors'
  },
  fill: {
    themeProp: 'colors'
  },
  stroke: {
    themeProp: 'colors'
  },
  borderColor: {
    themeProp: 'colors'
  },
  bgFullWidth: {
    themeProp: 'colors',
    transformToCss: value => ({
      position: 'relative',
      zIndex: 1,
      ':before': {
        content: '""',
        width: '200vw',
        height: '100%',
        background: value,
        position: 'absolute',
        left: '-50vw',
        right: '50vw',
        top: 0,
        zIndex: -1
      }
    })
  },
  fontSize: {
    themeProp: 'fontSizes'
  },
  fontFamily: {
    themeProp: 'fonts'
  },
  lineHeight: {
    themeProp: 'lineHeights'
  },
  fontWeight: {
    themeProp: 'fontWeights'
  },
  letterSpacing: {
    themeProp: 'letterSpacings'
  },
  border: {
    themeProp: 'borders'
  },
  borderTop: {
    themeProp: 'borders'
  },
  borderRight: {
    themeProp: 'borders'
  },
  borderBottom: {
    themeProp: 'borders'
  },
  borderLeft: {
    themeProp: 'borders'
  },
  borderRadius: {
    themeProp: 'borderRadius'
  },
  boxShadow: {
    themeProp: 'boxShadows'
  },
  position: {},
  transitionTimingFunction: {
    themeProp: 'easingFunctions'
  },
  transitionDuration: {
    themeProp: 'transitionDurations'
  },
  opacity: {
    themeProp: 'opacities'
  },
  textDecoration: {
    themeProp: 'textDecorations'
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  display: {},
  visibility: {},
  alignItems: {},
  justifyContent: {},
  flexWrap: {},
  flexDirection: {},
  flex: {},
  alignContent: {},
  justifySelf: {},
  justifyItems: {},
  textAlign: {},
  alignSelf: {},
  order: {},
  flexBasis: {},
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoRows: {},
  gridAutoColumns: {},
  gridTemplateRows: {},
  gridTemplateColumns: {},
  gridTemplateAreas: {},
  gridArea: {},
  gridTemplate: {},
  overflow: {},
  overflowX: {},
  overflowY: {},
  cursor: {}
});
const themablePropsKeys = [...Object.keys(mappings), 'css'];
const propsMappingKeys = Object.keys(mappings);

function extractThemableProps(props) {
  const themableProps = {};
  const rest = {}; // eslint-disable-next-line

  for (let key in props) {
    if (themablePropsKeys.indexOf(key) !== -1) {
      themableProps[key] = props[key];
    } else {
      rest[key] = props[key];
    }
  }

  return {
    themableProps,
    rest
  };
}
/**
 * Determines if object is `@emotion`'s keyframe definition,
 * they sets `anim=1` to keyframes processed by `@emotion/core/keyframes` function
 * @param {*} object
 */

function isEmotionKeyframe(object) {
  return object && object.anim === 1;
}

function mergeThemes(theme, themeOverride) {
  const newTheme = merge(theme, themeOverride, {
    isMergeableObject: x => isPlainObject(x) && !isEmotionKeyframe(x)
  }); // keyframes merging needs to be handled in very special way
  // each not yet processed keyframes definitions needs to be passed
  // to emotion's keyframes function in order to be consumed in styles

  if (newTheme.keyframes) {
    // eslint-disable-next-line
    for (let keyframeKey in newTheme.keyframes) {
      // only process keyframes not yet processed by emotion (anim property not et)
      if (!newTheme.keyframes[keyframeKey].anim) {
        // TODO remove casting to `any` when https://github.com/deity-io/falcon/issues/545 fixed
        newTheme.keyframes[keyframeKey] = core.keyframes(newTheme.keyframes[keyframeKey]);
      }
    }
  }

  return newTheme;
}
function gridSizes(columnAmount, theme) {
  function roundToMaxTwoDecimals(num) {
    return Math.round((num + Number.EPSILON) * 100) / 100;
  }

  const generatedSteps = {};

  for (let step = 1; step < columnAmount; step++) {
    const key = `${step}/${columnAmount}`;
    const unformattedValue = step / columnAmount * 100;
    const value = `${roundToMaxTwoDecimals(unformattedValue)}%`;
    generatedSteps[key] = value;
  }

  theme.sizes = Object.assign({}, theme.sizes, generatedSteps);
}
function mapNegativeSpacings(theme) {
  const {
    spacing
  } = theme;
  if (!spacing || typeof spacing !== 'object' || Object.keys(spacing).length <= 0) return theme;
  const negativeSpacings = {}; // Foreach value which is a number create a negative one with a key of '-key'

  Object.keys(spacing).forEach(key => {
    const value = spacing[key];
    if (typeof value !== 'number' || value <= 0) return;
    negativeSpacings[`-${key}`] = value * -1;
  });
  return Object.assign({}, theme, {
    spacing: Object.assign({}, spacing, negativeSpacings)
  });
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/**
 * extracts theme breakpoints names
 * @param theme
 */
function getThemeBreakpointNames(theme) {
  return Object.keys(theme.breakpoints);
}

function filterOutNonBreakpointBlockThemingProps(breakpointNames, props) {
  const result = Object.assign({}, props);
  breakpointNames.forEach(x => {
    delete result[x];
  });
  return result;
}
function extractBreakpointBlockThemingProps(breakpointNames, props) {
  return breakpointNames.reduce((result, key) => Object.assign({}, result, props[key] ? {
    [key]: props[key]
  } : {}), {});
}
function mapBreakpointBlockThemingPropsToBaseThemmingProps(breakpointNames, props) {
  const result = {}; // eslint-disable-next-line

  for (const breakpointKey of breakpointNames) {
    if (!props[breakpointKey]) {
      continue;
    }

    const breakpointBlock = props[breakpointKey]; // eslint-disable-next-line

    for (const breakpointBlockProp in breakpointBlock) {
      if (themablePropsKeys.indexOf(breakpointBlockProp) === -1) {
        continue;
      }

      const value = props[breakpointKey][breakpointBlockProp];

      if (!value) {
        continue;
      }

      if (!result[breakpointBlockProp]) {
        result[breakpointBlockProp] = {};
      }

      result[breakpointBlockProp][breakpointKey] = value;
    }
  }

  return result;
}

const NESTED_CSS_OBJECT_SELECTORS = [':', '&', '*', '>', '@'];

const convertPropToCss = (mappingKey, propMapping, matchingProp, theme) => {
  // if mapping does not have cssProp specified fallback to it's key as css property name
  const cssPropName = propMapping.cssProp || mappingKey; // if matching props is themable prop then get it's actual value from theme props otherwise
  // then just pass it as css prop value
  // TODO: typescript: is there a way to improve those typings?

  const cssPropValue = !propMapping.themeProp ? matchingProp : theme[propMapping.themeProp][matchingProp];

  if (propMapping.transformToCss) {
    return propMapping.transformToCss(cssPropValue);
  }

  return {
    [cssPropName]: cssPropValue
  };
};

function convertThemedPropsToCss(props, theme) {
  //  if theme is not provided via theme provider do not map anything
  if (!theme) {
    return {};
  } // TODO: typescript: can typings be improved for that object?


  const targetCss = {}; // eslint-disable-next-line

  for (let mappingKey in props) {
    const propMapping = mappings[mappingKey];
    const matchingProp = props[mappingKey]; // move along if there is no matching prop in mappings for given key found

    if (!propMapping) {
      continue;
    } // if matching prop is typeof string it means it's not responsive


    if (typeof matchingProp === 'string' || typeof matchingProp === 'number') {
      const cssObject = convertPropToCss(mappingKey, propMapping, matchingProp, theme); // eslint-disable-next-line

      for (let mappingKey in cssObject) {
        targetCss[mappingKey] = cssObject[mappingKey];
      }
    } else {
      // if it's not string it needs to be object that has responsive breakpoints keys
      // here we only translate all themed values to css values, we don't create media queries
      // eslint-disable-next-line
      for (let breakpointKey in matchingProp) {
        const breakpointValue = theme.breakpoints[breakpointKey];
        const matchingResponsiveProp = matchingProp[breakpointKey];

        if (breakpointValue === undefined) {
          continue;
        }

        const cssObject = convertPropToCss(mappingKey, propMapping, matchingResponsiveProp, theme); // eslint-disable-next-line

        for (let mappingKey in cssObject) {
          if (!targetCss[mappingKey]) {
            targetCss[mappingKey] = {};
          }

          targetCss[mappingKey][breakpointKey] = cssObject[mappingKey];
        }
      }
    }
  }

  return targetCss;
}

function convertResponsivePropsToMediaQueries(css, theme) {
  const target = {};
  const mediaQueries = {}; // eslint-disable-next-line

  for (let cssProp in css) {
    const cssValue = css[cssProp];

    if (!cssValue || typeof cssValue !== 'object' || Array.isArray(cssValue)) {
      target[cssProp] = cssValue;
    } // we need to look for responsive props in nested css as well
    // for example in :hover object
    else if (NESTED_CSS_OBJECT_SELECTORS.indexOf(cssProp[0]) !== -1) {
        target[cssProp] = convertResponsivePropsToMediaQueries(cssValue, theme);
      } else {
        // eslint-disable-next-line
        for (let potentialBreakpointKey in cssValue) {
          const breakpointValue = theme.breakpoints[potentialBreakpointKey];
          const valueForBreakpoint = cssValue[potentialBreakpointKey];

          if (breakpointValue) {
            // add media query key to mediaQueries object if it hasn't already got one
            if (!mediaQueries[potentialBreakpointKey]) {
              mediaQueries[potentialBreakpointKey] = {};
            }

            mediaQueries[potentialBreakpointKey][cssProp] = valueForBreakpoint;
          } else if (breakpointValue === 0) {
            target[cssProp] = valueForBreakpoint;
          } else {
            if (!target[cssProp]) {
              target[cssProp] = {};
            }

            target[cssProp][potentialBreakpointKey] = valueForBreakpoint;
          }
        }
      }
  } // media queries need to be handled in very careful way as order matters
  // so media min-width with smaller px value always apper before media min-width with larger px value
  // in resulting style


  Object.keys(mediaQueries).sort((first, second) => theme.breakpoints[first] > theme.breakpoints[second] ? 1 : -1).forEach(sortedMediaQueryKey => {
    const mediaQueryPxValue = theme.breakpoints[sortedMediaQueryKey];
    target[`@media screen and (min-width: ${mediaQueryPxValue}px)`] = mediaQueries[sortedMediaQueryKey];
  });
  return target;
}

function getCss(css, props) {
  return typeof css === 'function' ? css(props) : css;
}

/**
 * `<themedComponent>.defaultTheme` specifies it's `props` in nested object which key is used as `themeKey`
 *
 * TODO: write unit tests!
 * @param defaultTheme
 */
function extractDefaultThemeFromThemedComponent(defaultTheme) {
  if (!defaultTheme) {
    return undefined;
  } // default theme should have only one key, so we try to take first one, we also expect an `object` under it


  const potentialKey = Object.keys(defaultTheme)[0];
  const themeKey = typeof defaultTheme[potentialKey] === 'object' ? potentialKey : undefined;

  if (!themeKey) {
    return undefined;
  }

  return {
    key: themeKey,
    props: defaultTheme[themeKey]
  };
}
/**
 * @private
 * exported only because of unit test !!!
 *
 * following diagram shows theme props order (values in brackets)
 *
 * | theme                                            | themed component                                     | inline                          |
 * | ------------------------------------------------ | ---------------------------------------------------- | ------------------------------- |
 * | `[theme].components[component-theme-name]`       | `themed({defaultTheme:{[component-theme-name]:{}}})` | `<Box bg="primary"`             |
 * | **(2)** `component.breakpointBlockProps`         | **(1)** `defaultTheme.breakpointBlockProps`          | **(13)** `breakpointBlockProps` |
 * | **(6)** `component.baseThemingProps`             | **(5)** `defaultTheme.baseThemingProps`              | **(14)** `baseThemingProps`     |
 * | **(10)** `component.cssProp`                     | **(9)** `defaultTheme.cssProp`                       | **(15)** `cssProp`              |
 * | **(4)** `component.variant.breakpointBlockProps` | **(3)** `defaultTheme.variant.breakpointBlockProps`  |                                 |
 * | **(8)** `component.variant.baseThemingProps`     | **(7)** `defaultTheme.variant.baseThemingProps`      |                                 |
 * | **(12)** `component.variant.cssProp`             | **(11)** `defaultTheme.variant.cssProp`              |                                 |
 * @param props
 */


function mergeThemingProps(props) {
  const {
    defaultTheme: defaultThemeProp,
    theme,
    variant,
    css: inlineCss
  } = props,
        restProps = _objectWithoutPropertiesLoose(props, ["defaultTheme", "theme", "variant", "css"]);

  const defaultTheme = extractDefaultThemeFromThemedComponent(defaultThemeProp);
  const breakpointNames = getThemeBreakpointNames(theme);
  const breakpointBlockThemingProps = extractBreakpointBlockThemingProps(breakpointNames, restProps);
  const remainingProps = filterOutNonBreakpointBlockThemingProps(breakpointNames, restProps);
  const {
    themableProps
  } = extractThemableProps(remainingProps); // first we need to check where themed props and css props are defined and merge them
  // // css props need to merged separately as those do not need to be processed to extract css
  // Merging order
  // 1 -  props defined in defaultTheme props  as those are defaults
  // 2 -  props defined in theme.components for given `defaultTheme.key` as those are defaults
  // 3 -  props defined in defaultTheme variant prop if props.variant is defined
  // 4 -  props defined in theme.components[]variants if props.variant is defined
  // 5 -  props defined directly on component

  const breakpointBlockThemingPropsToMerge = [];
  const baseThemingPropsToMerge = [];
  const cssPropsToMerge = [];

  const addPropsToMerge = propsToMerge => {
    const {
      css
    } = propsToMerge,
          rest = _objectWithoutPropertiesLoose(propsToMerge, ["css"]);

    if (css) {
      cssPropsToMerge.push(getCss(css, props));
    } // Format breakpoint CSS blocks


    breakpointBlockThemingPropsToMerge.push(extractBreakpointBlockThemingProps(breakpointNames, rest));
    baseThemingPropsToMerge.push(filterOutNonBreakpointBlockThemingProps(breakpointNames, rest));
  }; //  start with props defined in `defaultTheme` prop as base


  if (defaultTheme !== undefined) {
    addPropsToMerge(defaultTheme.props); // if props are defined in `theme.components` object for `defaultTheme.key` merge them with default ones

    const areComponentPropsDefinedInTheme = theme.components[defaultTheme.key] !== undefined;

    if (areComponentPropsDefinedInTheme) {
      addPropsToMerge(theme.components[defaultTheme.key]);
    } // themed props can also be defined for component variant


    if (variant) {
      // check for `variant` prop defined in themed component `defaultTheme`
      const defaultThemeVariants = defaultTheme.props && defaultTheme.props.variants;

      if (defaultThemeVariants && defaultThemeVariants[variant]) {
        addPropsToMerge(defaultThemeVariants[variant]);
      } // check for `variant` prop defined in `theme.components` object


      const themeVariants = areComponentPropsDefinedInTheme && theme.components[defaultTheme.key].variants;

      if (themeVariants && themeVariants[variant]) {
        addPropsToMerge(themeVariants[variant]);
      }
    }
  }

  const mergedBreakpointBlockThemingProps = Object.assign({}, ...breakpointBlockThemingPropsToMerge);
  const baseThemingPropsFromBreakpointBlockThemingProps = mapBreakpointBlockThemingPropsToBaseThemmingProps(breakpointNames, mergedBreakpointBlockThemingProps);
  const mergedBaseThemingProps = Object.assign({}, ...[baseThemingPropsFromBreakpointBlockThemingProps, ...baseThemingPropsToMerge]); // merged themable props need to be converted to css before returning

  const cssFromThemedProps = convertThemedPropsToCss(mergedBaseThemingProps, theme);
  cssPropsToMerge.push(convertThemedPropsToCss(mapBreakpointBlockThemingPropsToBaseThemmingProps(breakpointNames, breakpointBlockThemingProps), theme)); // out of all component props extract themable ones, convert to css and add to merge

  cssPropsToMerge.push(convertThemedPropsToCss(themableProps, theme)); // as last step add for merging those `css` prop which defined directly on component

  if (inlineCss) {
    cssPropsToMerge.push(getCss(inlineCss, props));
  }

  const cssProps = Object.assign({}, ...cssPropsToMerge); // finally merge css from themed props with css from css props

  const mergedCss = Object.assign({}, cssFromThemedProps, cssProps);
  return mergedCss;
}
/**
 * this function responsibility is to extract css object from
 * both themed props (that use props values from theme) and css object/function props
 * TODO: perhaps this function could be written in prettier way?
 *  @param props
 */

function getThemedCss(props) {
  //  if theme is not provided via theme provider or inline theme prop
  // fall back to default theme
  if (!props.theme || !props.theme.components) {
    props = Object.assign({}, props, {
      theme: baseTheme
    });
  }

  const mergedCss = mergeThemingProps(props); // as a last step we need to check each css prop if it's value is responsive

  return convertResponsivePropsToMediaQueries(mergedCss, props.theme);
} // filtering which props to forward to next component is tricky
// and behaves differently if next component is html element, custom component
// or custom component whihch is themed component


const customPropsBlacklist = ['as', 'tag', 'variant', 'defaultTheme', 'css'];

const filterPropsToForward = (baseComponent, props, ref) => {
  const filteredProps = {};
  const isHtmlTag = typeof baseComponent === 'string'; // eslint-disable-next-line

  for (let key in props) {
    // when html tag is provided forward only valid html props to it
    if (isHtmlTag && !isPropValid(key)) continue; // if custom component is provided via `as` prop do not forward themable props to it (bg, color, m, p etc)
    // neighter forward any of the blacklisted props

    const themableProp = propsMappingKeys.indexOf(key) !== -1 || customPropsBlacklist.indexOf(key) !== -1;
    if (themableProp) continue;
    filteredProps[key] = props[key];
  }

  filteredProps.ref = ref;
  return filteredProps;
};

/**
 * Handles dynamic html tag rendering via and `as` prop as well as forwards `ref` and only allowed html props to DOM element
 */
const DynamicHtmlTag = /*#__PURE__*/React__default.forwardRef((props, ref) => {
  const Base = props.as || props.tag;
  const nextProps = filterPropsToForward(Base, props, ref);
  return /*#__PURE__*/React__default.createElement(Base, nextProps);
});
function themed(options) {
  let label = '';

  if (options.defaultTheme) {
    const componentKey = Object.keys(options.defaultTheme)[0];

    if (typeof options.defaultTheme[componentKey] === 'object') {
      label = `${componentKey}`;
    }
  }

  const styledComponentWithThemeProps = styled(DynamicHtmlTag, {
    label,
    // label is transformed for displayName of styled component,
    // target inserted as css class in resulting element so this could potentially be used as a fallback
    // to style components via traditional css
    target: `themed${label ? `-${label.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/\s+/g, '-').toLowerCase()}` : ''}`
  })(getThemedCss); // default theme is also passed as part of default props

  styledComponentWithThemeProps.defaultProps = Object.assign({}, options.defaultProps, {
    defaultTheme: options.defaultTheme,
    tag: options.tag
  });
  return /*#__PURE__*/React__default.memo(styledComponentWithThemeProps);
}

function createTheme(themeOverride = {}) {
  const mergedThemes = mergeThemes(baseTheme, themeOverride);
  return mapNegativeSpacings(mergedThemes);
} // --- exported type definitions for theme  ----

const Button = themed({
  tag: 'button',
  defaultTheme: {
    button: {
      color: 'primaryText',
      bg: 'primary',
      borderRadius: 'medium',
      fontSize: 'sm',
      lineHeight: 'small',
      height: 'lg',
      px: 'sm',
      transitionTimingFunction: 'easeIn',
      transitionDuration: 'short',
      border: 'none',
      css: ({
        theme
      }) => ({
        // basic reset styles
        fontFamily: 'inherit',
        WebkitFontSmoothing: 'antialiased',
        display: 'inline-flex',
        justifyContent: 'center',
        alignItems: 'center',
        textAlign: 'center',
        textDecoration: 'none',
        appearance: 'none',
        cursor: 'pointer',
        // define transform that scales on active
        transitionProperty: 'transform',
        ':active': {
          transform: 'scale(0.95)'
        },
        ':hover:enabled': {
          backgroundColor: theme.colors.primaryLight
        },
        ':disabled': {
          opacity: 0.6,
          cursor: 'default'
        }
      }),
      variants: {
        secondary: {
          bg: 'secondary',
          color: 'secondaryText',
          css: ({
            theme
          }) => ({
            ':hover': {
              backgroundColor: theme.colors.secondaryLight
            }
          })
        }
      }
    }
  }
});

const GridLayout = themed({
  tag: 'div',
  defaultTheme: {
    gridLayout: {
      display: 'grid',
      gridGap: 'sm'
    }
  }
});

const FlexLayout = themed({
  tag: 'div',
  defaultTheme: {
    flexLayout: {
      display: 'flex',
      flexWrap: 'wrap'
    }
  }
});

const Root = themed({
  tag: 'div',
  defaultTheme: {
    root: {
      fontFamily: 'sans',
      fontSize: 'sm',
      lineHeight: 'default',
      color: 'black',
      css: {
        overflowX: 'hidden',
        '*': {
          boxSizing: 'border-box'
        }
      }
    }
  }
});

const Image = themed({
  tag: 'img',
  defaultTheme: {
    image: {
      css: {
        objectFit: 'contain',
        maxWidth: '100%'
      }
    }
  }
});

const rangeInputTrack = styles => ({
  '::-webkit-slider-runnable-track': styles,
  '::-moz-range-track': styles,
  '::-ms-track': styles
});

const rangeInputThumb = styles => ({
  '::-webkit-slider-thumb ': styles,
  '::-moz-range-thumb': styles,
  '::-ms-thumb': styles
});

const RangeInput = themed({
  tag: 'input',
  defaultProps: {
    type: 'range'
  },
  defaultTheme: {
    rangeInput: {
      height: 'xs',
      css: ({
        theme
      }) => Object.assign({
        background: 'transparent',
        width: '100%',
        WebkitAppearance: 'none',
        ':focus': {
          outline: 'none'
        }
      }, rangeInputTrack({
        width: '100%',
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        border: 'none',
        borderRadius: theme.borderRadius.medium,
        height: '50%',
        background: theme.colors.secondary
      }), rangeInputThumb({
        WebkitAppearance: 'none',
        cursor: 'pointer',
        border: 'none',
        borderRadius: theme.borderRadius.round,
        background: theme.colors.primary,
        height: theme.spacing.sm,
        width: theme.spacing.sm,
        transition: 'transform',
        transitionTimingFunction: theme.easingFunctions.easeIn,
        transitionDuration: theme.transitionDurations.short
      }), {
        ':active': Object.assign({}, rangeInputThumb({
          transform: 'scale(1.1)'
        }))
      })
    }
  }
});

const Table = themed({
  tag: 'table',
  defaultTheme: {
    table: {
      borderRadius: 'medium',
      fontSize: 'sm',
      display: {
        xs: 'block',
        sm: 'table'
      },
      css: {
        width: '100%',
        overflowY: {
          xs: 'hidden',
          md: 'initial'
        },
        tableLayout: 'auto',
        borderSpacing: 0,
        borderCollapse: 'collapse',
        borderStyle: 'hidden'
      }
    }
  }
});
const Thead = themed({
  tag: 'thead',
  defaultTheme: {
    thead: {
      bg: 'secondary'
    }
  }
});
const Th = themed({
  tag: 'th',
  defaultTheme: {
    th: {
      py: 'xs',
      px: 'sm',
      fontWeight: 'regular',
      css: {
        textAlign: 'left'
      }
    }
  }
});
const Td = themed({
  tag: 'td',
  defaultTheme: {
    td: {
      p: 'sm',
      fontWeight: 'light',
      lineHeight: 'large',
      css: {
        textAlign: 'left'
      }
    }
  }
});
const Tr = themed({
  tag: 'tr',
  defaultTheme: {
    tr: {
      display: 'table-row',
      borderTop: 'regular',
      borderColor: 'secondary'
    }
  }
});
const Tbody = themed({
  tag: 'tbody',
  defaultTheme: {
    tbody: {
      fontSize: 'sm'
    }
  }
});

const H1 = themed({
  tag: 'h1',
  defaultTheme: {
    h1: {
      fontSize: 'xxl',
      fontWeight: 'light',
      m: 'none'
    }
  }
});
const H2 = themed({
  tag: 'h2',
  defaultTheme: {
    h2: {
      fontSize: 'xl',
      fontWeight: 'regular',
      m: 'none'
    }
  }
});
const H3 = themed({
  tag: 'h3',
  defaultTheme: {
    h3: {
      fontSize: 'lg',
      fontWeight: 'regular',
      m: 'none'
    }
  }
});
const H4 = themed({
  tag: 'h4',
  defaultTheme: {
    h4: {
      fontSize: 'md',
      fontWeight: 'regular',
      m: 'none'
    }
  }
});

function placeholder(styles) {
  return {
    '::-webkit-input-placeholder': styles,
    '::-moz-placeholder': styles,
    ':-ms-input-placeholder`': styles,
    '::-ms-input-placeholder`': styles
  };
}

const Input = themed({
  tag: 'input',
  defaultProps: {
    type: 'text',
    invalid: false
  },
  defaultTheme: {
    input: {
      py: 'xs',
      px: 'sm',
      border: 'regular',
      borderRadius: 'medium',
      css: ({
        invalid,
        theme
      }) => Object.assign({}, placeholder({
        color: theme.colors.secondaryText
      }), {
        borderColor: invalid ? theme.colors.error : theme.colors.secondaryDark,
        fontFamily: 'inherit',
        lineHeight: 'inherit',
        color: 'inherit',
        WebkitAppearance: 'none',
        width: '100%'
      })
    }
  }
});

function placeholder$1(styles) {
  return {
    '::-webkit-input-placeholder': styles,
    '::-moz-placeholder': styles,
    ':-ms-input-placeholder`': styles,
    '::-ms-input-placeholder`': styles
  };
}

const Textarea = themed({
  tag: 'textarea',
  defaultProps: {
    rows: 2,
    invalid: false
  },
  defaultTheme: {
    textarea: {
      py: 'xs',
      px: 'sm',
      border: 'regular',
      borderRadius: 'medium',
      css: ({
        invalid,
        theme
      }) => Object.assign({}, placeholder$1({
        color: theme.colors.secondaryText
      }), {
        borderColor: invalid ? theme.colors.error : theme.colors.secondaryDark,
        fontFamily: 'inherit',
        lineHeight: 'inherit',
        color: 'inherit',
        WebkitAppearance: 'none',
        width: '100%'
      })
    }
  }
});

const Text = themed({
  tag: 'p',
  defaultProps: {
    ellipsis: false
  },
  defaultTheme: {
    text: {
      display: 'block',
      m: 'none',
      css: ({
        ellipsis
      }) => ellipsis ? {
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
      } : {}
    }
  }
});

const Divider = themed({
  tag: 'hr',
  defaultTheme: {
    divider: {
      display: 'block',
      m: 'none',
      border: 'regular',
      borderBottom: 'none',
      borderLeft: 'none',
      borderColor: 'secondaryDark',
      css: {
        width: '100%'
      },
      variants: {
        horizontal: {
          borderTop: 'none',
          css: {
            width: 'auto'
          }
        }
      }
    }
  }
});

const Swipeable = themed({
  tag: 'div',
  defaultTheme: {
    swipeable: {
      display: 'flex',
      css: {
        overflowX: 'scroll',
        msOverflowStyle: 'none',
        WebkitRocketLauncher: '0',
        scrollSnapType: ['x mandatory', 'mandatory'],
        scrollSnapPointsX: 'repeat(100%)',
        WebkitOverflowScrolling: 'touch',
        '::-webkit-scrollbar': {
          display: 'none'
        }
      }
    }
  }
});
const SwipeableItem = themed({
  tag: 'div',
  defaultTheme: {
    swipeableItem: {
      flex: '0 0 100%',
      css: {
        scrollSnapAlign: 'center'
      }
    }
  }
});

const Tabs = themed({
  tag: 'div',
  defaultProps: {
    role: 'tablist'
  },
  defaultTheme: {
    tabs: {
      display: 'flex',
      p: 'xs',
      m: 'none',
      bg: 'primary',
      color: 'primaryText',
      boxShadow: 'subtle',
      css: {
        listStyle: 'none'
      },
      variants: {
        secondary: {
          boxShadow: 'none',
          color: 'black',
          bg: 'transparent'
        }
      }
    }
  }
});
const Tab = themed({
  tag: 'button',
  defaultProps: {
    role: 'tab',
    type: 'button',
    active: false
  },
  defaultTheme: {
    tab: {
      fontSize: 'sm',
      flex: 0,
      mr: 'md',
      px: 'md',
      py: 'xs',
      borderBottom: 'regular',
      css: props => ({
        // Reset button styling
        background: 'none',
        color: 'inherit',
        borderTop: 'none',
        borderLeft: 'none',
        borderRight: 'none',
        font: 'inherit',
        outline: 'inherit',
        // Additional styling
        transitionProperty: 'border-bottom-color',
        transitionTimingFunction: props.theme.easingFunctions.easeIn,
        transitionDuration: props.theme.transitionDurations.short,
        borderBottomColor: props.active ? props.theme.colors.secondary : props.theme.colors.primary,
        cursor: props.active ? 'default' : 'pointer'
      }),
      variants: {
        secondary: {
          borderBottom: 'bold',
          css: props => ({
            borderBottomColor: props.active ? props.theme.colors.primary : props.theme.colors.secondary
          })
        }
      }
    }
  }
});

const Box = themed({
  tag: 'div'
});

const Group = themed({
  tag: 'div',
  defaultTheme: {
    group: {
      display: 'flex',
      css: {
        // use first of type not first-child
        // details: https://github.com/emotion-js/emotion/issues/637
        '& > :first-of-type': {
          borderTopRightRadius: 0,
          borderBottomRightRadius: 0
        },
        '> :not(:first-of-type):not(:last-child)': {
          borderRadius: 0
        },
        '> :last-child': {
          borderTopLeftRadius: 0,
          borderBottomLeftRadius: 0
        }
      }
    }
  }
});

var _jsxFileName = "/home/vsts/work/1/s/src/components/Portal.tsx";
class Portal extends React__default.Component {
  constructor(props) {
    super(props);
    this.state = {
      wrapper: null
    };
  }

  componentDidMount() {
    const wrapper = document.createElement('div');
    document.body.appendChild(wrapper); // eslint-disable-next-line

    this.setState({
      wrapper
    });
  }

  componentWillUnmount() {
    const {
      wrapper
    } = this.state;

    if (wrapper) {
      document.body.removeChild(wrapper);
    }
  }

  render() {
    const {
      wrapper
    } = this.state;

    if (wrapper) {
      return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React__default.createElement(Root, _extends({}, this.props, {
        __source: {
          fileName: _jsxFileName,
          lineNumber: 29,
          columnNumber: 36
        }
      })), wrapper);
    }

    return null;
  }

}

var _jsxFileName$1 = "/home/vsts/work/1/s/src/components/ThemeProvider.tsx";
// every other reset style can be applied on Root component but not body margin

const tinyNormalizeStyles = {
  body: {
    margin: 0
  }
}; // IMPORTANT: temporary hack/workaround for not rendering styles
// when using emotion together with react-apollo after error on the server occured
// falcon-ui ThemeProvider now renders CacheProvider with always new cache provided when running on the server
// analogous to https://github.com/emotion-js/emotion/blob/master/packages/core/src/context.js#L54

const isServer = typeof document === 'undefined';
const cache = createCache();
const ThemeProvider = (_ref) => {
  let {
    theme = createTheme(),
    globalCss = tinyNormalizeStyles,
    withoutRoot = false
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, ["theme", "globalCss", "withoutRoot"]);

  return /*#__PURE__*/React__default.createElement(core.CacheProvider, {
    value: isServer ? createCache() : cache,
    __source: {
      fileName: _jsxFileName$1,
      lineNumber: 36,
      columnNumber: 3
    }
  }, /*#__PURE__*/React__default.createElement(emotionTheming.ThemeProvider, {
    theme: theme,
    __source: {
      fileName: _jsxFileName$1,
      lineNumber: 37,
      columnNumber: 5
    }
  }, /*#__PURE__*/React__default.createElement(core.Global, {
    styles: globalCss,
    __source: {
      fileName: _jsxFileName$1,
      lineNumber: 38,
      columnNumber: 7
    }
  }), withoutRoot ? rest.children : /*#__PURE__*/React__default.createElement(Root, _extends({}, rest, {
    __source: {
      fileName: _jsxFileName$1,
      lineNumber: 39,
      columnNumber: 38
    }
  }))));
};

var _jsxFileName$2 = "/home/vsts/work/1/s/src/components/Sidebar.tsx";
const SidebarInnerDOM = emotionTheming.withTheme((_ref) => {
  let {
    theme,
    side
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["theme", "visible", "side"]);

  const sidebarRef = React__default.useRef();
  React.useEffect(() => {
    const sidebar = sidebarRef.current || undefined;

    if (sidebar) {
      const transitionDuration = theme.components.sidebar.transitionDuration || theme.transitionDurations.short; // Remove Animation && Place Sidebar Offscreen

      sidebar.style.transitionDuration = '0s';
      sidebar.style.transform = `translateX(${side === 'left' ? '-100%' : '100%'})`; // Set Animation -> change the position which will trigger the animation

      requestAnimationFrame(() => {
        sidebar.style.transitionDuration = transitionDuration;
        sidebar.style.transform = 'translateX(0)';
      }); // Reset properties to the provided theme by setting them to empty strings

      requestAnimationFrame(() => {
        sidebar.style.transitionDuration = '';
        sidebar.style.transform = '';
      });
    }
  }, [side, theme.components.sidebar.transitionDuration, theme.transitionDurations.short]);
  return /*#__PURE__*/React__default.createElement("div", _extends({
    ref: sidebarRef
  }, props, {
    __source: {
      fileName: _jsxFileName$2,
      lineNumber: 29,
      columnNumber: 10
    }
  }));
});
const Sidebar = themed({
  tag: SidebarInnerDOM,
  defaultProps: {
    visible: false,
    side: 'left'
  },
  defaultTheme: {
    sidebar: {
      overflowX: 'hidden',
      display: 'flex',
      bg: 'white',
      position: 'fixed',
      css: ({
        visible,
        theme,
        side
      }) => ({
        top: 0,
        bottom: 0,
        [side]: 0,
        height: '100%',
        zIndex: theme.zIndex.sidebar,
        // eslint-disable-next-line
        transform: visible ? 'translateX(0)' : side === 'left' ? 'translateX(-100%)' : 'translateX(100%)',
        transitionProperty: 'transform',
        transitionDuration: visible ? theme.transitionDurations.short : theme.transitionDurations.standard,
        transitionTimingFunction: visible ? theme.easingFunctions.easeIn : theme.easingFunctions.easeOut
      })
    }
  }
});

const Backdrop = themed({
  tag: 'div',
  defaultProps: {
    visible: false
  },
  defaultTheme: {
    backdrop: {
      bg: 'black',
      css: ({
        visible,
        theme
      }) => ({
        display: 'flex',
        position: 'fixed',
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        height: '100%',
        width: '100%',
        transitionProperty: 'opacity',
        transitionDuration: visible ? theme.transitionDurations.short : theme.transitionDurations.standard,
        transitionTimingFunction: visible ? theme.easingFunctions.easeIn : theme.easingFunctions.easeOut,
        opacity: visible ? 0.1 : 0,
        pointerEvents: visible ? 'auto' : 'none',
        zIndex: theme.zIndex.backdrop
      })
    }
  }
});

const Avatar = themed({
  tag: 'img',
  defaultTheme: {
    avatar: {
      borderRadius: 'round',
      size: 'lg',
      css: {
        objectFit: 'contain',
        maxWidth: '100%'
      }
    }
  }
});

const Link = themed({
  tag: 'a',
  defaultTheme: {
    link: {
      css: {
        color: 'inherit',
        textDecoration: 'none',
        cursor: 'pointer'
      }
    }
  }
});

const BackgroundImage = themed({
  tag: 'div',
  defaultProps: {
    src: '',
    ratio: 1
  },
  defaultTheme: {
    backgroundImage: {
      borderRadius: 'none',
      css: ({
        src,
        ratio
      }) => ({
        backgroundImage: `url(${src})`,
        backgroundSize: 'cover',
        backgroundPosition: 'center',
        height: 0,
        paddingBottom: `${ratio * 100}%`
      })
    }
  }
});

const List = themed({
  tag: 'ul',
  defaultTheme: {
    list: {
      p: 'none',
      m: 'none',
      css: {
        listStyle: 'none'
      }
    }
  }
});
const ListItem = themed({
  tag: 'li',
  defaultTheme: {
    listItem: {
      p: 'none'
    }
  }
});

const Badge = themed({
  tag: 'div',
  defaultTheme: {
    badge: {
      bg: 'primary',
      color: 'primaryText',
      px: 'xs',
      height: 'md',
      borderRadius: 'medium',
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontSize: 'xs'
    }
  }
});

const Label = themed({
  tag: 'label',
  defaultTheme: {
    label: {
      display: 'block',
      lineHeight: 'small'
    }
  }
});

var _jsxFileName$3 = "/home/vsts/work/1/s/src/components/Icon.tsx";
const ENV = process.env.NODE_ENV;
const IconRenderer = themed({
  tag: 'svg',
  defaultProps: {
    // https://stackoverflow.com/questions/18646111/disable-onfocus-event-for-svg-element
    focusable: 'false'
  },
  defaultTheme: {
    icon: {
      size: 'lg',
      stroke: 'primary'
    }
  }
});

const IconInner = props => {
  const {
    src,
    fallback,
    theme
  } = props,
        rest = _objectWithoutPropertiesLoose(props, ["src", "fallback", "theme"]);

  const {
    icons
  } = theme; // TODO: temporary fix for https://github.com/deity-io/falcon/issues/693, remove when resolved

  if (!icons) {
    return null;
  }

  if (icons[src]) {
    const _icons$src = icons[src],
          {
      icon
    } = _icons$src,
          otherProps = _objectWithoutPropertiesLoose(_icons$src, ["icon"]);

    return /*#__PURE__*/React__default.createElement(IconRenderer, _extends({
      as: icon
    }, otherProps, rest, {
      __source: {
        fileName: _jsxFileName$3,
        lineNumber: 42,
        columnNumber: 12
      }
    }));
  }

  if (fallback) {
    return fallback;
  }

  if (ENV !== 'production') {
    console.error(`There is no icon "${src}" defined in your theme ("theme.icons"), nor has a fallback icon been defined.`);
  }

  return null;
};

const Icon = emotionTheming.withTheme(IconInner);
Icon.propTypes = {
  src: PropTypes.string.isRequired
};

var _jsxFileName$4 = "/home/vsts/work/1/s/src/components/Checkbox.tsx";

const CheckboxInnerDOM = props => {
  const {
    className,
    icon
  } = props,
        rest = _objectWithoutPropertiesLoose(props, ["className", "icon", "invalid"]);

  return /*#__PURE__*/React__default.createElement("div", {
    className: className,
    __source: {
      fileName: _jsxFileName$4,
      lineNumber: 13,
      columnNumber: 5
    }
  }, /*#__PURE__*/React__default.createElement("input", _extends({}, rest, {
    type: "checkbox",
    __source: {
      fileName: _jsxFileName$4,
      lineNumber: 14,
      columnNumber: 7
    }
  })), /*#__PURE__*/React__default.createElement("div", {
    "aria-hidden": true,
    className: "-inner-checkbox-frame",
    __source: {
      fileName: _jsxFileName$4,
      lineNumber: 15,
      columnNumber: 7
    }
  }, icon));
};

const Checkbox = themed({
  tag: CheckboxInnerDOM,
  defaultProps: {
    invalid: false,
    icon: /*#__PURE__*/React__default.createElement(Icon, {
      src: "checkboxCheckmarkIcon",
      className: "-inner-checkbox-icon"
      /* eslint-disable prettier/prettier */
      // disable prettier because it conflicts with jsx-wrap-multilines
      ,
      fallback: /*#__PURE__*/React__default.createElement("svg", {
        viewBox: "0 0 24 24",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        className: "-inner-checkbox-icon",
        fill: "none",
        focusable: "false",
        __source: {
          fileName: _jsxFileName$4,
          lineNumber: 34,
          columnNumber: 11
        }
      }, /*#__PURE__*/React__default.createElement("polyline", {
        points: "20 6 9 17 4 12",
        __source: {
          fileName: _jsxFileName$4,
          lineNumber: 43,
          columnNumber: 13
        }
      }))
      /* eslint-enable prettier/prettier */
      ,
      __source: {
        fileName: _jsxFileName$4,
        lineNumber: 28,
        columnNumber: 7
      }
    })
  },
  defaultTheme: {
    checkbox: {
      size: 'md',
      css: ({
        invalid,
        theme
      }) => ({
        display: 'inline-flex',
        position: 'relative',
        ':focus-within': {
          outline: `1px solid ${theme.colors.focus}`
        },
        // checkbox input is not visible but interactive
        input: {
          position: 'absolute',
          top: 0,
          left: 0,
          margin: 0,
          width: '100%',
          height: '100%',
          opacity: 0,
          zIndex: 1,
          ':checked + .-inner-checkbox-frame': {
            background: theme.colors.primary,
            borderColor: theme.colors.primary,
            '.-inner-checkbox-icon': {
              opacity: 1
            }
          },
          ':hover + .-inner-checkbox-frame': {
            borderColor: invalid ? theme.colors.error : theme.colors.primaryLight
          },
          ':checked:hover + .-inner-checkbox-frame': {
            background: theme.colors.primaryLight
          }
        },
        '.-inner-checkbox-icon': {
          height: '100%',
          width: '100%',
          stroke: theme.colors.white,
          opacity: 0,
          transitionProperty: 'opacity',
          transitionTimingFunction: theme.easingFunctions.easeIn,
          transitionDuration: theme.transitionDurations.short
        },
        '.-inner-checkbox-frame': {
          height: '100%',
          width: '100%',
          position: 'relative',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          cursor: 'pointer',
          borderRadius: theme.borderRadius.small,
          border: theme.borders.bold,
          borderColor: invalid ? theme.colors.error : theme.colors.secondaryDark,
          transitionProperty: 'border, background',
          transitionTimingFunction: theme.easingFunctions.easeIn,
          transitionDuration: theme.transitionDurations.short
        }
      })
    }
  }
});

var _jsxFileName$5 = "/home/vsts/work/1/s/src/components/Radio.tsx";

const RadioInnerDOM = props => {
  const {
    className,
    icon
  } = props,
        remaining = _objectWithoutPropertiesLoose(props, ["className", "icon", "invalid"]);

  const {
    themableProps,
    rest
  } = extractThemableProps(remaining);
  return /*#__PURE__*/React__default.createElement(Box, _extends({}, themableProps, {
    className: className,
    __source: {
      fileName: _jsxFileName$5,
      lineNumber: 16,
      columnNumber: 5
    }
  }), /*#__PURE__*/React__default.createElement("input", _extends({}, rest, {
    type: "radio",
    __source: {
      fileName: _jsxFileName$5,
      lineNumber: 17,
      columnNumber: 7
    }
  })), /*#__PURE__*/React__default.createElement("div", {
    className: "-inner-radio-frame",
    __source: {
      fileName: _jsxFileName$5,
      lineNumber: 18,
      columnNumber: 7
    }
  }, icon));
};

const iconFallback = /*#__PURE__*/React__default.createElement("svg", {
  viewBox: "0 0 24 24",
  className: "-inner-radio-icon",
  focusable: "false",
  __source: {
    fileName: _jsxFileName$5,
    lineNumber: 24,
    columnNumber: 3
  }
}, /*#__PURE__*/React__default.createElement("circle", {
  cx: "12",
  cy: "12",
  r: "10",
  __source: {
    fileName: _jsxFileName$5,
    lineNumber: 25,
    columnNumber: 5
  }
}));
const Radio = themed({
  tag: RadioInnerDOM,
  defaultProps: {
    invalid: false,
    icon: /*#__PURE__*/React__default.createElement(Icon, {
      className: "-inner-radio-icon",
      src: "radioCheckedIcon",
      fallback: iconFallback,
      __source: {
        fileName: _jsxFileName$5,
        lineNumber: 34,
        columnNumber: 11
      }
    })
  },
  defaultTheme: {
    radio: {
      size: 'md',
      css: ({
        theme
      }) => ({
        display: 'inline-flex',
        position: 'relative',
        cursor: 'default',
        ':focus-within': {
          outline: `1px solid ${theme.colors.focus}`
        },
        // radio input is not visible but interactive
        input: {
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          margin: 0,
          opacity: 0,
          zIndex: 1,
          cursor: 'inherit',
          ':checked + .-inner-radio-frame': {
            borderColor: theme.colors.primary,
            '.-inner-radio-icon': {
              opacity: 1,
              fill: theme.colors.primary
            }
          },
          ':hover + .-inner-radio-frame': {
            borderColor: theme.colors.primaryLight,
            '.-inner-radio-icon': {
              fill: theme.colors.primaryLight
            }
          }
        },
        '.-inner-radio-icon': {
          height: 'calc(100% - 4px)',
          width: 'calc(100% - 4px)',
          display: 'block',
          opacity: 0,
          stroke: 'none',
          fill: theme.colors.white,
          transitionProperty: 'opacity, fill',
          transitionTimingFunction: theme.easingFunctions.easeIn,
          transitionDuration: theme.transitionDurations.short
        },
        '.-inner-radio-frame': {
          height: '100%',
          width: '100%',
          position: 'relative',
          display: 'flex',
          cursor: 'pointer',
          borderRadius: theme.borderRadius.round,
          border: theme.borders.bold,
          borderColor: theme.colors.secondaryDark,
          transitionProperty: 'border, fill',
          transitionTimingFunction: theme.easingFunctions.easeIn,
          transitionDuration: theme.transitionDurations.short,
          justifyContent: 'center',
          alignItems: 'center'
        }
      })
    }
  }
});

var _jsxFileName$6 = "/home/vsts/work/1/s/src/components/NumberInput.tsx";

function triggerChange(element, value) {
  const valueSetter = Object.getOwnPropertyDescriptor(element, 'value').set;
  const prototype = Object.getPrototypeOf(element);
  const prototypeValueSetter = Object.getOwnPropertyDescriptor(prototype, 'value').set;

  if (valueSetter && prototypeValueSetter && valueSetter !== prototypeValueSetter) {
    prototypeValueSetter.call(element, value);
  } else if (valueSetter) {
    valueSetter.call(element, value);
  }

  element.dispatchEvent(new Event('change', {
    bubbles: true
  }));
}

class NumberInputInnerDOM extends React__default.Component {
  constructor(...args) {
    super(...args);
    this.inputRef = void 0;

    this.onChange = e => {
      this.setState({});

      if (this.props.onChange) {
        this.props.onChange(e);
      }
    };

    this.mountInputRef = el => {
      this.inputRef = el;
      this.setState({});
    };

    this.stepUp = () => {
      if (!this.inputRef) {
        return;
      }

      const currentValue = +this.inputRef.value;
      let nextValue = currentValue + this.props.step;

      if (nextValue > this.props.max) {
        nextValue = this.props.max;
      }

      triggerChange(this.inputRef, nextValue);
    };

    this.stepDown = () => {
      if (!this.inputRef) {
        return;
      }

      const currentValue = +this.inputRef.value;
      let nextValue = currentValue - this.props.step;

      if (nextValue < this.props.min) {
        nextValue = this.props.min;
      }

      triggerChange(this.inputRef, nextValue);
    };
  }

  canIncrease() {
    if (!this.inputRef) {
      return false;
    }

    const currentValue = +this.inputRef.value;
    return currentValue < this.props.max;
  }

  canDecrease() {
    if (!this.inputRef) {
      return false;
    }

    const currentValue = +this.inputRef.value;
    return currentValue > this.props.min;
  }

  render() {
    const _this$props = this.props,
          {
      className,
      disabled,
      value,
      min,
      max,
      decreaseText,
      increaseText
    } = _this$props,
          remaining = _objectWithoutPropertiesLoose(_this$props, ["className", "invalid", "disabled", "value", "min", "max", "decreaseText", "increaseText"]);

    const {
      themableProps,
      rest
    } = extractThemableProps(remaining);
    return /*#__PURE__*/React__default.createElement(Box, _extends({}, themableProps, {
      className: className,
      __source: {
        fileName: _jsxFileName$6,
        lineNumber: 97,
        columnNumber: 7
      }
    }), /*#__PURE__*/React__default.createElement("button", {
      type: "button",
      onClick: this.stepDown,
      "aria-label": decreaseText,
      className: "-inner-input-step-down-element",
      disabled: disabled || !this.canDecrease(),
      __source: {
        fileName: _jsxFileName$6,
        lineNumber: 98,
        columnNumber: 9
      }
    }, /*#__PURE__*/React__default.createElement(Icon, {
      src: "numberInputDown",
      fallback: "\u2212",
      __source: {
        fileName: _jsxFileName$6,
        lineNumber: 105,
        columnNumber: 11
      }
    })), /*#__PURE__*/React__default.createElement("input", _extends({
      ref: this.mountInputRef,
      disabled: disabled,
      min: min,
      max: max,
      value: value,
      type: "number",
      onChange: this.onChange
    }, rest, {
      __source: {
        fileName: _jsxFileName$6,
        lineNumber: 108,
        columnNumber: 9
      }
    })), /*#__PURE__*/React__default.createElement("button", {
      type: "button",
      onClick: this.stepUp,
      "aria-label": increaseText,
      className: "-inner-input-step-up-element",
      disabled: disabled || !this.canIncrease(),
      __source: {
        fileName: _jsxFileName$6,
        lineNumber: 119,
        columnNumber: 9
      }
    }, /*#__PURE__*/React__default.createElement(Icon, {
      src: "numberInputUp",
      fallback: "+",
      __source: {
        fileName: _jsxFileName$6,
        lineNumber: 126,
        columnNumber: 11
      }
    })));
  }

}

const NumberInput = themed({
  tag: NumberInputInnerDOM,
  defaultProps: {
    invalid: false,
    min: Number.NEGATIVE_INFINITY,
    max: Number.POSITIVE_INFINITY,
    step: 1,
    increaseText: 'Increase Quantity',
    decreaseText: 'Decrease Quantity'
  },
  defaultTheme: {
    numberInput: {
      display: 'inline-flex',
      alignItems: 'center',
      height: 'lg',
      css: ({
        theme,
        invalid
      }) => ({
        input: {
          flex: 'none',
          width: theme.spacing.lg,
          height: '100%',
          appearance: 'none',
          MozAppearance: 'textfield',
          fontStyle: 'inherit',
          textAlign: 'center',
          border: theme.borders.regular,
          borderRadius: theme.borderRadius.medium,
          borderColor: invalid ? theme.colors.error : theme.colors.secondaryDark,
          boxShadow: 'none',
          '::-webkit-outer-spin-button,::-webkit-inner-spin-button': {
            appearance: 'none'
          },
          ':focus': {
            outline: 'none',
            borderColor: invalid ? theme.colors.error : theme.colors.secondary
          }
        },
        '.-inner-input-step-down-element, .-inner-input-step-up-element': {
          height: '100%',
          flex: 'none',
          width: theme.spacing.lg,
          border: 'none',
          outline: 'none',
          appearance: 'none',
          transitionProperty: 'transform, background',
          transitionTimingFunction: theme.easingFunctions.easeIn,
          transitionDuration: theme.transitionDurations.short,
          background: theme.colors.secondaryDark,
          color: theme.colors.secondaryText,
          borderRadius: theme.borderRadius.round,
          fontWeight: theme.fontWeights.bold,
          fontSize: 'inherit',
          cursor: 'pointer',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          transform: 'scale(0.8)',
          lineHeight: 1,
          ':hover': {
            background: theme.colors.secondary
          },
          ':disabled': {
            opacity: '0.5'
          }
        },
        '.-inner-input-step-down-element': {
          marginRight: theme.spacing.xs,
          ':active': {
            transform: 'scale(0.6)'
          }
        },
        '.-inner-input-step-up-element': {
          marginLeft: theme.spacing.xs,
          ':active': {
            transform: 'scale(1)'
          }
        }
      })
    }
  }
});

const Select = themed({
  tag: 'select',
  defaultProps: {
    invalid: false
  },
  defaultTheme: {
    select: {
      py: 'xs',
      px: 'sm',
      border: 'regular',
      borderRadius: 'medium',
      css: ({
        theme,
        invalid
      }) => ({
        display: 'block',
        fontFamily: 'inherit',
        lineHeight: 'inherit',
        color: 'inherit',
        borderColor: invalid ? theme.colors.error : theme.colors.secondaryDark,
        width: '100%',
        position: 'relative',
        background: `url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJmZWF0aGVyIGZlYXRoZXItY2hldnJvbi1kb3duIj48cG9seWxpbmUgcG9pbnRzPSI2IDkgMTIgMTUgMTggOSI+PC9wb2x5bGluZT48L3N2Zz4=) 99% 50% no-repeat ${theme.colors.white};`,
        WebkitAppearance: 'none',
        MozAppearance: 'none',
        appearance: 'none',
        cursor: 'pointer',
        ':disabled': {
          opacity: 0.5,
          cursor: 'not-allowed'
        },
        '::-ms-expand': {
          display: 'none'
        }
      })
    }
  }
});
const Option = themed({
  tag: 'option',
  defaultTheme: {
    option: {
      fontSize: 'sm',
      css: {
        fontFamily: 'inherit'
      }
    }
  }
});

const Breadcrumbs = themed({
  tag: 'ul',
  defaultTheme: {
    breadcrumbs: {
      p: 'none',
      m: 'none',
      display: 'flex',
      flexWrap: 'wrap',
      css: {
        listStyle: 'none'
      }
    }
  }
});
const Breadcrumb = themed({
  tag: 'li',
  defaultTheme: {
    breadcrumb: {
      display: 'flex',
      alignItems: 'center',
      css: ({
        theme
      }) => ({
        '::after': {
          content: '""',
          color: 'inherit',
          paddingLeft: theme.spacing.xs,
          paddingRight: theme.spacing.xs,
          display: 'block'
        },
        ':last-child': {
          pointerEvents: 'none',
          color: theme.colors.primary,
          '::after': {
            display: 'none'
          }
        }
      })
    }
  }
});

const Details = themed({
  tag: 'details',
  defaultProps: {
    open: false
  },
  defaultTheme: {
    details: {
      display: 'flex',
      flexDirection: 'column',
      css: ({
        theme,
        open
      }) => ({
        '> :not(summary, style)': {
          display: open ? 'block' : 'none',
          flex: open ? '1' : 0
        },
        '> summary::-webkit-details-marker': {
          display: 'none'
        },
        '> summary:after': {
          display: 'block',
          content: open ? '"-"' : '"+"',
          marginLeft: theme.spacing.sm,
          fontSize: theme.fontSizes.md,
          lineHeight: 0.6,
          fontWeight: theme.fontWeights.bold,
          color: theme.colors.secondaryText
        }
      })
    }
  }
});
const Summary = themed({
  tag: 'summary',
  defaultTheme: {
    summary: {
      fontSize: 'sm',
      py: 'xs',
      px: 'sm',
      mb: 'xs',
      bg: 'secondaryLight',
      lineHeight: 'small',
      borderRadius: 'medium',
      css: {
        userSelect: 'none',
        cursor: 'pointer',
        display: 'flex',
        justifyContent: 'space-between',
        position: 'relative'
      }
    }
  }
});
const DetailsContent = themed({
  tag: 'article',
  defaultTheme: {
    detailsContent: {
      py: 'xs',
      pl: 'xs'
    }
  }
});

const Menu = themed({
  tag: List,
  defaultTheme: {
    menu: {
      p: 'none',
      m: 'none',
      bg: 'primary',
      color: 'primaryText',
      css: {
        display: 'flex',
        flexDirection: 'column',
        listStyle: 'none',
        position: 'relative'
      }
    }
  }
});
const MenuItem = themed({
  tag: ListItem,
  defaultTheme: {
    menuItem: {
      fontSize: 'sm',
      fontWeight: 'bold',
      display: 'flex',
      color: 'primaryText',
      css: ({
        theme
      }) => ({
        cursor: 'pointer',
        userSelect: 'none',
        listStyle: 'none',
        ':not(:last-child)': {
          borderBottom: theme.borders.regular,
          borderColor: theme.colors.secondaryDark
        },
        ':hover': {
          background: theme.colors.primaryLight,
          borderColor: theme.colors.secondaryLight
        }
      })
    }
  }
});

var _jsxFileName$7 = "/home/vsts/work/1/s/src/components/Navbar.tsx";
const Navbar = themed({
  tag: 'ul',
  defaultTheme: {
    navbar: {
      p: 'none',
      m: 'none',
      bgFullWidth: 'primary',
      color: 'primaryText',
      css: {
        display: 'flex',
        listStyle: 'none',
        position: 'relative'
      }
    }
  }
});
const MenuItemContext = /*#__PURE__*/React__default.createContext({});

const MenuItemInnerDOM = (_ref) => {
  let {
    onMouseEnter,
    onMouseLeave,
    onClick
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["onMouseEnter", "onMouseLeave", "onClick"]);

  const [isOpen, setIsOpen] = React.useState(false);
  return /*#__PURE__*/React__default.createElement(MenuItemContext.Provider, {
    value: {
      isOpen
    },
    __source: {
      fileName: _jsxFileName$7,
      lineNumber: 30,
      columnNumber: 5
    }
  }, /*#__PURE__*/React__default.createElement(ListItem, _extends({}, props, {
    onMouseEnter: e => {
      if (onMouseEnter) onMouseEnter(e);
      setIsOpen(true);
    },
    onMouseLeave: e => {
      setIsOpen(false);
      if (onMouseLeave) onMouseLeave(e);
    },
    onClick: e => {
      setIsOpen(false);
      if (onClick) onClick(e);
    },
    __source: {
      fileName: _jsxFileName$7,
      lineNumber: 31,
      columnNumber: 7
    }
  })));
};

const NavbarItem = themed({
  tag: MenuItemInnerDOM,
  defaultTheme: {
    navbarItem: {
      fontSize: 'sm',
      display: 'flex',
      color: 'primaryText',
      css: ({
        theme
      }) => ({
        cursor: 'pointer',
        userSelect: 'none',
        listStyle: 'none',
        ':hover': {
          background: theme.colors.secondary,
          color: theme.colors.secondaryText
        }
      })
    }
  }
});

const NavbarItemMenuInnerDOM = props => /*#__PURE__*/React__default.createElement(MenuItemContext.Consumer, {
  __source: {
    fileName: _jsxFileName$7,
    lineNumber: 74,
    columnNumber: 3
  }
}, ({
  isOpen
}) => /*#__PURE__*/React__default.createElement(Box, _extends({}, props, {
  display: isOpen ? 'block' : 'none',
  __source: {
    fileName: _jsxFileName$7,
    lineNumber: 75,
    columnNumber: 22
  }
})));

const NavbarItemMenu = themed({
  tag: NavbarItemMenuInnerDOM,
  defaultProps: {
    role: 'menu'
  },
  defaultTheme: {
    navbarItemMenu: {
      p: 'sm',
      bg: 'secondary',
      color: 'secondaryText',
      boxShadow: 'subtle',
      css: {
        position: 'absolute',
        top: '100%',
        left: 0,
        right: 0
      }
    }
  }
});

var _jsxFileName$8 = "/home/vsts/work/1/s/src/components/Dropdown.tsx";

const getHtmlChildren = el => Array.from(el.children).filter(child => child instanceof HTMLElement);

const DropdownContext = /*#__PURE__*/React__default.createContext({});

const DropdownInnerDOM = (_ref) => {
  let {
    children,
    onChange,
    id
  } = _ref,
      rest = _objectWithoutPropertiesLoose(_ref, ["children", "onChange", "id"]);

  const [open, setOpen] = React.useState(false);

  const onChangeAndClose = value => {
    if (onChange) onChange(value);
    setOpen(false);
  };

  const menu = React.useRef(null);
  const label = React.useRef(null);
  const [selectedIndex, selectIndex] = React.useState(-1);
  const onKeyDown = React.useCallback(event => {
    if (menu.current) {
      const options = getHtmlChildren(menu.current);
      let preventDefault = true;

      switch (event.keyCode) {
        // up
        case 38:
          {
            selectIndex(s => Math.max(0, s - 1));
            break;
          }
        // down

        case 40:
          {
            selectIndex(s => Math.min(s + 1, options.length));
            break;
          }
        // escape

        case 27:
          {
            setOpen(false);
            if (label.current) label.current.focus();
            break;
          }

        default:
          {
            preventDefault = false;
          }
      }

      if (preventDefault) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  }, []);
  React.useEffect(() => {
    if (menu.current) {
      const options = getHtmlChildren(menu.current);
      const selected = options[selectedIndex];

      if (selected) {
        const selectedButton = selected.getElementsByTagName('button')[0];
        if (selectedButton) selectedButton.focus();
      }
    }
  }, [selectedIndex]);
  React.useEffect(() => {
    if (!open) selectIndex(-1);
  }, [open]);
  return /*#__PURE__*/React__default.createElement(DropdownContext.Provider, {
    value: {
      open,
      setOpen,
      onChange: onChangeAndClose,
      menu,
      label,
      id
    },
    __source: {
      fileName: _jsxFileName$8,
      lineNumber: 86,
      columnNumber: 5
    }
  }, /*#__PURE__*/React__default.createElement(Box, _extends({
    id: id,
    "aria-labelledby": id && `${id}-label`,
    onBlur: event => {
      // Only trigger close if no inner element has focus either; https://stackoverflow.com/a/47563344/8521718
      if (!event.currentTarget.contains(event.relatedTarget)) setOpen(false);
    },
    onKeyDown: onKeyDown,
    "aria-haspopup": "listbox",
    position: "relative"
  }, rest, {
    __source: {
      fileName: _jsxFileName$8,
      lineNumber: 87,
      columnNumber: 7
    }
  }), children));
};

const Dropdown = themed({
  tag: DropdownInnerDOM,
  defaultTheme: {
    dropdown: {
      display: 'flex',
      borderRadius: 'medium',
      border: 'regular',
      borderColor: 'secondaryDark',
      css: ({
        theme
      }) => ({
        userSelect: 'none',
        position: 'relative',
        ':hover, :focus': {
          borderColor: theme.colors.primary
        }
      })
    }
  }
});

const DropdownLabelInnerDOM = (_ref2) => {
  let {
    children
  } = _ref2,
      rest = _objectWithoutPropertiesLoose(_ref2, ["children"]);

  const {
    open,
    id,
    setOpen,
    label
  } = React.useContext(DropdownContext);
  const toggle = React.useCallback(() => {
    setOpen(exp => !exp);
  }, [setOpen]);
  return /*#__PURE__*/React__default.createElement(Box, _extends({
    as: "button",
    id: id && `${id}-label`,
    type: "button",
    onClick: toggle,
    ref: label
  }, rest, {
    __source: {
      fileName: _jsxFileName$8,
      lineNumber: 132,
      columnNumber: 5
    }
  }), /*#__PURE__*/React__default.createElement(Box, {
    flex: "1",
    __source: {
      fileName: _jsxFileName$8,
      lineNumber: 133,
      columnNumber: 7
    }
  }, children), /*#__PURE__*/React__default.createElement(Icon, {
    src: open ? 'dropdownArrowUp' : 'dropdownArrowDown',
    fallback: open ? '' : '',
    __source: {
      fileName: _jsxFileName$8,
      lineNumber: 134,
      columnNumber: 7
    }
  }));
};

const DropdownLabel = themed({
  tag: DropdownLabelInnerDOM,
  defaultTheme: {
    dropdownLabel: {
      display: 'flex',
      py: 'xs',
      px: 'sm',
      fontSize: 'sm',
      justifyContent: 'space-between',
      css: {
        width: '100%',
        cursor: 'pointer',
        border: 'none',
        background: 'none',
        color: 'inherit'
      }
    }
  }
});

const DropdownMenuInnerDOM = props => {
  const {
    open,
    id,
    menu
  } = React.useContext(DropdownContext);
  return open ? /*#__PURE__*/React__default.createElement(Box, _extends({
    as: "ul",
    ref: menu,
    "aria-controls": id,
    "aria-labelledby": id && `${id}-label`,
    role: "listbox",
    tabIndex: -1,
    display: open ? 'block' : 'none'
  }, props, {
    __source: {
      fileName: _jsxFileName$8,
      lineNumber: 163,
      columnNumber: 5
    }
  })) : null;
};

const DropdownMenu = themed({
  tag: DropdownMenuInnerDOM,
  defaultTheme: {
    dropdownMenu: {
      m: 'none',
      p: 'none',
      borderRadius: 'medium',
      boxShadow: 'subtle',
      bg: 'white',
      css: ({
        theme
      }) => ({
        position: 'absolute',
        listStyle: 'none',
        top: 'calc(100% + 1px)',
        left: 0,
        right: 0,
        zIndex: theme.zIndex.dropDownMenu
      }),
      variants: {
        above: {
          css: {
            top: 'auto',
            bottom: 'calc(100% + 1px)'
          }
        }
      }
    }
  }
});

const DropdownMenuItemInnerDOM = (_ref3) => {
  let {
    children
  } = _ref3,
      props = _objectWithoutPropertiesLoose(_ref3, ["children"]);

  const {
    onChange,
    label
  } = React.useContext(DropdownContext);
  const select = React.useCallback(e => {
    if (onChange) onChange(props.value);
    if (e) e.stopPropagation();
    if (label) label.current.focus();
  }, [onChange, props.value, label]);
  return /*#__PURE__*/React__default.createElement(Box, _extends({
    as: "li",
    role: "option"
  }, props, {
    __source: {
      fileName: _jsxFileName$8,
      lineNumber: 219,
      columnNumber: 5
    }
  }), /*#__PURE__*/React__default.createElement(Box, {
    as: "button",
    type: "button",
    tabIndex: -1,
    onClick: select,
    __source: {
      fileName: _jsxFileName$8,
      lineNumber: 220,
      columnNumber: 7
    }
  }, children));
};

const DropdownMenuItem = themed({
  tag: DropdownMenuItemInnerDOM,
  defaultProps: {
    value: undefined
  },
  defaultTheme: {
    dropdownMenuItem: {
      css: ({
        theme
      }) => ({
        '> button': {
          width: '100%',
          padding: theme.spacing.xs,
          textAlign: 'left',
          border: 'none',
          background: 'none',
          color: 'inherit',
          cursor: 'pointer'
        },
        ':hover, :focus': {
          background: `${theme.colors.primaryLight}`
        }
      })
    }
  }
});

Object.defineProperty(exports, 'withTheme', {
  enumerable: true,
  get: function () {
    return emotionTheming.withTheme;
  }
});
exports.Avatar = Avatar;
exports.Backdrop = Backdrop;
exports.BackgroundImage = BackgroundImage;
exports.Badge = Badge;
exports.Box = Box;
exports.Breadcrumb = Breadcrumb;
exports.Breadcrumbs = Breadcrumbs;
exports.Button = Button;
exports.Checkbox = Checkbox;
exports.Details = Details;
exports.DetailsContent = DetailsContent;
exports.Divider = Divider;
exports.Dropdown = Dropdown;
exports.DropdownLabel = DropdownLabel;
exports.DropdownMenu = DropdownMenu;
exports.DropdownMenuItem = DropdownMenuItem;
exports.FlexLayout = FlexLayout;
exports.GridLayout = GridLayout;
exports.Group = Group;
exports.H1 = H1;
exports.H2 = H2;
exports.H3 = H3;
exports.H4 = H4;
exports.Icon = Icon;
exports.IconRenderer = IconRenderer;
exports.Image = Image;
exports.Input = Input;
exports.Label = Label;
exports.Link = Link;
exports.List = List;
exports.ListItem = ListItem;
exports.Menu = Menu;
exports.MenuItem = MenuItem;
exports.Navbar = Navbar;
exports.NavbarItem = NavbarItem;
exports.NavbarItemMenu = NavbarItemMenu;
exports.NumberInput = NumberInput;
exports.Option = Option;
exports.Portal = Portal;
exports.Radio = Radio;
exports.RangeInput = RangeInput;
exports.Root = Root;
exports.Select = Select;
exports.Sidebar = Sidebar;
exports.Summary = Summary;
exports.Swipeable = Swipeable;
exports.SwipeableItem = SwipeableItem;
exports.Tab = Tab;
exports.Table = Table;
exports.Tabs = Tabs;
exports.Tbody = Tbody;
exports.Td = Td;
exports.Text = Text;
exports.Textarea = Textarea;
exports.Th = Th;
exports.Thead = Thead;
exports.ThemeProvider = ThemeProvider;
exports.Tr = Tr;
exports.createTheme = createTheme;
exports.extractBreakpointBlockThemingProps = extractBreakpointBlockThemingProps;
exports.extractThemableProps = extractThemableProps;
exports.filterOutNonBreakpointBlockThemingProps = filterOutNonBreakpointBlockThemingProps;
exports.gridSizes = gridSizes;
exports.mapBreakpointBlockThemingPropsToBaseThemmingProps = mapBreakpointBlockThemingPropsToBaseThemmingProps;
exports.mapNegativeSpacings = mapNegativeSpacings;
exports.mappings = mappings;
exports.mergeThemes = mergeThemes;
exports.mergeThemingProps = mergeThemingProps;
exports.propsMappingKeys = propsMappingKeys;
exports.themablePropsKeys = themablePropsKeys;
exports.themed = themed;
//# sourceMappingURL=falcon-ui.cjs.js.map
