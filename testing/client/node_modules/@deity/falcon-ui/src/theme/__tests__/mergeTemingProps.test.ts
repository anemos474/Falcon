import { baseTheme } from '../baseTheme';
import { mergeThemingProps } from '../themed';

describe('mergeThemingProps', () => {
  const theme = {
    ...baseTheme,
    components: {}
  };

  // TODO: introduce abstraction for responsive props mapping, to be able to test only merging, property mapping should be tested separately

  describe('component inline props level', () => {
    it('when no responsive prop nor breakpoint block prop defined then props should not be changed', () => {
      const result = mergeThemingProps({ theme, bg: { md: 'error' } });

      expect(result).toStrictEqual({ backgroundColor: { md: theme.colors.error } });
    });

    it('when responsive prop with no breakpoints and no breakpoint block prop defined then props should not be changed', () => {
      const result = mergeThemingProps({ theme, bg: 'black', color: 'primary' });

      expect(result).toStrictEqual({
        backgroundColor: theme.colors.black,
        color: theme.colors.primary
      });
    });

    it('when responsive prop with breakpoints defined', () => {
      const result = mergeThemingProps({ theme, bg: { md: 'black', lg: 'white' }, color: 'primary' });

      expect(result).toStrictEqual({
        backgroundColor: { md: theme.colors.black, lg: theme.colors.white },
        color: theme.colors.primary
      });
    });

    it('when breakpoint block property defined then should be converted into responsive prop', () => {
      const result = mergeThemingProps({ theme, md: { bg: 'black' }, color: 'primary' });

      expect(result).toStrictEqual({
        backgroundColor: { md: theme.colors.black },
        color: theme.colors.primary
      });
    });

    it('when different responsive prop with breakpoints and breakpoint block property defined then styles should be merged', () => {
      const result = mergeThemingProps({
        theme,
        md: { bg: 'black' },
        borderColor: { md: 'error', lg: 'white' },
        color: 'primary'
      });

      expect(result).toStrictEqual({
        backgroundColor: { md: theme.colors.black },
        borderColor: { md: theme.colors.error, lg: theme.colors.white },
        color: theme.colors.primary
      });
    });

    it('when the same prop is defined via responsive prop and breakpoint block then responsive prop should have precedence', () => {
      const result = mergeThemingProps({ theme, md: { color: 'black' }, color: 'primary' });

      expect(result).toStrictEqual({
        color: theme.colors.primary
      });
    });

    it('when the same prop is defined via responsive prop and breakpoint block then responsive prop should have precedence', () => {
      const result = mergeThemingProps({ theme, md: { color: 'black' }, color: { xs: 'primary', lg: 'error' } });

      expect(result).toStrictEqual({
        color: { xs: theme.colors.primary, lg: theme.colors.error }
      });
    });

    it('when props are defined via responsive prop and breakpoint block then only the same props should have precedence', () => {
      const result = mergeThemingProps({
        theme,
        md: { color: 'black', borderColor: 'error' },
        color: { xs: 'primary', lg: 'error' }
      });

      expect(result).toStrictEqual({
        color: { xs: theme.colors.primary, lg: theme.colors.error },
        borderColor: { md: theme.colors.error }
      });
    });
  });

  it('should merge props when defining props on defaultTheme and inline levels', () => {
    const result = mergeThemingProps({
      theme,
      defaultTheme: {
        testComponent: { bg: 'black' }
      },
      color: 'primary'
    });

    expect(result).toStrictEqual({
      backgroundColor: theme.colors.black,
      color: theme.colors.primary
    });
  });

  it('should merge props when defining props on theme and inline levels', () => {
    const result = mergeThemingProps({
      theme: {
        ...theme,
        components: {
          testComponent: {
            bg: 'black'
          }
        }
      },
      defaultTheme: {
        testComponent: {}
      },
      color: 'primary'
    });

    expect(result).toStrictEqual({
      backgroundColor: theme.colors.black,
      color: theme.colors.primary
    });
  });

  // TODO: write more test cases
});
