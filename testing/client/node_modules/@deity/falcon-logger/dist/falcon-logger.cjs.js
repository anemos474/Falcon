'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var pino = _interopDefault(require('pino'));
var symbols = require('pino/lib/symbols');

const levelToSeverity = level => {
  switch (level) {
    case 'trace':
    case 'debug':
      return 'DEBUG';

    case 'info':
      return 'INFO';

    case 'warn':
      return 'WARNING';

    case 'error':
      return 'ERROR';

    case 'fatal':
      return 'CRITICAL';

    default:
      return 'DEFAULT';
  }
};

let isAppSet = false;
const logger = pino({
  name: 'falcon-logger',
  formatters: {
    level: (level, number) => ({
      level: number,
      severity: levelToSeverity(level)
    })
  }
});
/**
 * Sets the log level for the logger instance
 * @param level Required log level
 * @returns {void}
 */

logger.setLogLevel = level => {
  logger.level = level;
};
/**
 * Sets the "app" key to every log message via the root logger instance.
 * It can be called only once, preferably at the very beginning of your application.
 * @param name Application name
 * @returns {void}
 */


logger.setApp = name => {
  if (isAppSet) {
    logger.warn('logger.setApp() can be called only once.');
    return;
  } // @ts-ignore: Tweaking internal Pino settings


  logger[symbols.chindingsSym] += `,"app":"${name}"`;
  isAppSet = true;
};
/**
 * Initializes an extra sub-logger instance for the provided module name
 * and adds "module" key to every log message automatically.
 * Handy for defining sub-loggers for your nested modules.
 * In conjunction with `falcon-pretty` formatter - it will render an additional "[my-module]" section in the log message output.
 * @example
 * logger.getFor("my-module").info("Calling my-module...");
 * @param moduleName Module name
 * @param extra map with values that will be added to each logger call automatically
 * @returns {Logger} Module-specific Logger instance
 */


logger.getFor = (moduleName, extra = {}) => logger.child(Object.assign({
  module: moduleName
}, extra));
/**
 * Measures the timing for the provided callback.
 * If your log level is set to trace - Logger will produce the following log message:
 * "TRACE: My time (XX ms)"
 * @param label Log label
 * @param fn Function to trace the execution time of
 * @returns {Promise<T>} `fn` result
 */


logger.traceTime = function traceTime(label, fn) {
  // using `function()` statement to preserve the context in case of "getFor" call
  if (!this.isLevelEnabled('trace')) {
    return fn();
  }

  const startTime = Date.now();
  return fn().finally(() => {
    const duration = Date.now() - startTime;
    this.trace(`${label} (${duration}ms)`);
  });
};

module.exports = logger;
//# sourceMappingURL=falcon-logger.cjs.js.map
