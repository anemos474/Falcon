#!/usr/bin/env node
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = _interopDefault(require('fs'));
var args = _interopDefault(require('args'));
var split = _interopDefault(require('split2'));
var pump = _interopDefault(require('pump'));
var readableStream = require('readable-stream');
var chalk = _interopDefault(require('chalk'));
var jmespath = _interopDefault(require('jmespath'));
var CONSTANTS = require('pino-pretty/lib/constants');
var bourne = _interopDefault(require('@hapi/bourne'));
var getSource = _interopDefault(require('get-source'));
var utils = require('pino-pretty/lib/utils');

const LOGGER_KEYS = [...CONSTANTS.LOGGER_KEYS, 'module', 'app'];

const nocolor = input => input;

const plain = {
  default: nocolor,
  60: nocolor,
  50: nocolor,
  40: nocolor,
  30: nocolor,
  20: nocolor,
  10: nocolor,
  message: nocolor,
  random: nocolor,
  error: nocolor
};
const ctx = new chalk.constructor({
  enabled: true,
  level: 3
});
const randomColorDictionary = {};
const randomColors = [ctx.green, ctx.yellow, ctx.magenta, ctx.hex('00FF00'), ctx.hex('9932CC'), ctx.hex('A52A2A'), ctx.hex('1E90FF'), ctx.hex('ADFF2F'), ctx.redBright];

const randomColor = input => {
  if (!(input in randomColorDictionary)) {
    const color = randomColors.shift();
    randomColors.push(color);
    randomColorDictionary[input] = color;
  }

  return randomColorDictionary[input](input);
};

const colored = {
  default: ctx.white,
  60: ctx.bgRed,
  50: ctx.red,
  40: ctx.yellow,
  30: ctx.green,
  20: ctx.blue,
  10: ctx.grey,
  message: ctx.cyan,
  random: randomColor,
  error: ctx.red
};

const colorizeLevel = (level, colorizer) => {
  if (Number.isInteger(+level)) {
    return level in CONSTANTS.LEVELS ? colorizer[level](CONSTANTS.LEVELS[level]) : colorizer.default(CONSTANTS.LEVELS.default);
  }

  const levelNum = CONSTANTS.LEVEL_NAMES[level.toLowerCase()] || 'default';
  return colorizer[levelNum](CONSTANTS.LEVELS[levelNum]);
};

const plainColorizer = level => {
  return colorizeLevel(level, plain);
};

plainColorizer.message = plain.message;
plainColorizer.default = plain.default;
plainColorizer.random = plain.random;
plainColorizer.error = plain.error;

const coloredColorizer = level => {
  return colorizeLevel(level, colored);
};

coloredColorizer.message = colored.message;
coloredColorizer.default = colored.default;
coloredColorizer.random = colored.random;
coloredColorizer.error = colored.error;
/**
 * Factory function get a function to colorized levels. The returned function
 * also includes a `.message(str)` method to colorize strings.
 * @param {bool} [useColors=false] When `true` a function that applies standard
 * terminal colors is returned.
 *
 * @returns {Function} `function (level) {}` has a `.message(str)` method to
 * apply colorization to a string. The core function accepts either an integer
 * `level` or a `string` level. The integer level will map to a known level
 * string or to `USERLVL` if not known.  The string `level` will map to the same
 * colors as the integer `level` and will also default to `USERLVL` if the given
 * string is not a recognized level name.
 */

var colors = ((useColors = false) => useColors ? coloredColorizer : plainColorizer);

const defaultColorizer = colors();
const jsonParser = input => {
  try {
    return {
      value: bourne.parse(input, {
        protoAction: 'remove'
      })
    };
  } catch (err) {
    return {
      err
    };
  }
};
const prettifyModule = ({
  log,
  colorizer = defaultColorizer
}) => {
  if (log.module) {
    return `[${colorizer.random(log.module)}]`;
  }

  return undefined;
};
const prettifyGraphQLErrorLog = ({
  log,
  ident,
  eol,
  colorizer = defaultColorizer
}) => {
  const {
    path,
    extensions
  } = log;
  let result = `${eol}`;

  if (extensions.code) {
    result += `GraphQL Error Code: ${colorizer.error(extensions.code)}${eol}`;
  }

  if (path) {
    let pathString = '';
    path.forEach(item => {
      const limiter = pathString.length ? '.' : '';

      if (Number.isInteger(item)) {
        pathString += `[${item}]`;
      } else {
        pathString += `${limiter}${item}`;
      }
    });
    result += `Path: ${colorizer.error(pathString)}${eol}${eol}`;
  }

  const stack = extensions && extensions.exception && extensions.exception.stacktrace;

  if (stack && stack.length > 1) {
    const codeLine = stack[1]; // Highlighting the actual code line

    stack[1] = colorizer.error(codeLine);
    const codeSnippet = readSourceFromStack({
      colorizer,
      stack,
      setLineNumber: true,
      paddingLines: 5
    });

    if (codeSnippet.length) {
      result += `${codeSnippet.join(eol)}${eol}${eol}`;
    }

    const joinedLines = utils.internals.joinLinesWithIndentation({
      input: stack.join(eol),
      ident,
      eol
    });
    result += `${ident}${joinedLines}${eol}`;
  }

  return `${result}${eol}`;
};
const prettifyGraphQLParsingErrorLog = ({
  log,
  colorizer,
  eol = '\n'
}) => {
  const {
    body,
    locations
  } = log;
  const [currentLocation] = locations;
  return `${colorSection({
    output: body,
    colorizer,
    line: currentLocation.line - 1,
    position: currentLocation.column,
    paddingLines: 5
  }).join(eol)}${eol}`;
};
const prettifyObject = ({
  log,
  ident = '    ',
  eol = '\n',
  skipKeys = [],
  errorLikeKeys = CONSTANTS.ERROR_LIKE_KEYS,
  excludeLoggerKeys = true
}) => utils.prettifyObject({
  input: log,
  ident,
  eol,
  skipKeys: [...LOGGER_KEYS, ...skipKeys],
  errorLikeKeys,
  excludeLoggerKeys
});
const prettifyErrorLog = ({
  log,
  messageKey = CONSTANTS.MESSAGE_KEY,
  colorizer,
  ident = '    ',
  eol = '\n',
  errorLikeKeys = CONSTANTS.ERROR_LIKE_KEYS,
  errorProperties = []
}) => {
  const {
    stack
  } = log;
  let result = '';

  if (stack) {
    const codeSnippet = readSourceFromStack({
      colorizer,
      stack: stack.split(eol),
      setLineNumber: true,
      paddingLines: 5
    });

    if (codeSnippet.length) {
      result += `${eol}${codeSnippet.join(eol)}${eol}${eol}`;
    }
  }

  const joinedLines = utils.internals.joinLinesWithIndentation({
    input: stack,
    ident,
    eol
  });
  result += `${ident}${joinedLines}${eol}`;

  if (errorProperties.length > 0) {
    const excludeProperties = LOGGER_KEYS.concat(messageKey, 'type', 'stack');
    let propertiesToPrint;

    if (errorProperties[0] === '*') {
      // Print all sibling properties except for the standard exclusions.
      propertiesToPrint = Object.keys(log).filter(key => excludeProperties.includes(key) === false);
    } else {
      // Print only sepcified properties unless the property is a standard exclusion.
      propertiesToPrint = errorProperties.filter(key => excludeProperties.includes(key) === false);
    }

    for (let i = 0; i < propertiesToPrint.length; i += 1) {
      const key = propertiesToPrint[i];
      if (key in log === false) continue;

      if (utils.isObject(log[key])) {
        // The nested object may have "logger" type keys but since they are not
        // at the root level of the object being processed, we want to print them.
        // Thus, we invoke with `excludeLoggerKeys: false`.
        const prettifiedObject = prettifyObject({
          log: log[key],
          errorLikeKeys,
          excludeLoggerKeys: false,
          eol,
          ident
        });
        result = `${result}${key}: {${eol}${prettifiedObject}}${eol}`;
        continue;
      }

      result = `${result}${key}: ${log[key]}${eol}`;
    }
  }

  return result;
};
const readSourceFromStack = ({
  colorizer,
  stack,
  setLineNumber = false,
  paddingLines = 0
}) => {
  if (!stack || stack.length < 2) {
    return [];
  }

  const match = stack[1].match(/\((.+):(\d+):(\d+)\)/);

  if (!match) {
    return [];
  }

  const {
    1: filePath,
    2: codeLine,
    3: codeColumn
  } = match;
  const line = Number.parseInt(codeLine, 10);
  const column = Number.parseInt(codeColumn, 10);
  const file = getSource(filePath);
  const codeLines = [];
  codeLines.push(...colorSection({
    colorizer,
    line: line - 1,
    output: file.text,
    position: column,
    setLineNumber,
    paddingLines
  }));
  codeLines.unshift(`File: ${colorizer.error(file.path)}`);
  return codeLines;
};

const colorSection = ({
  output,
  line,
  position,
  colorizer,
  setLineNumber = false,
  paddingLines = 0
}) => {
  const lines = output.split('\n');
  const totalLines = lines.length;
  let topLine = line;
  let bottomLine = line;
  let longestLine = 1;
  const codeLines = [];

  if (paddingLines) {
    // keeping line numbers within the file range
    topLine = Math.max(topLine - paddingLines, 1);
    bottomLine = Math.min(bottomLine + paddingLines, totalLines);
  }

  for (let i = topLine; i <= bottomLine; i++) {
    const currentLine = lines[i];
    longestLine = Math.max(longestLine, currentLine.length);

    if (i === line) {
      codeLines.push(colorizer.error(currentLine));

      if (position) {
        codeLines.push(colorizer.error(`${' '.repeat(position - 1)}^`));
      }
    } else {
      codeLines.push(colorizer.message(currentLine));
    }
  }

  if (setLineNumber) {
    const colWidth = bottomLine.toString().length;

    for (let i = topLine; i <= bottomLine; i++) {
      let numberedLine = codeLines.shift();
      numberedLine = ` ${i.toString().padStart(colWidth, ' ')} | ${numberedLine}`;
      longestLine = Math.max(longestLine, numberedLine.length);
      codeLines.push(numberedLine);
    }
  }

  codeLines.push('-'.repeat(longestLine));
  codeLines.unshift('-'.repeat(longestLine));
  return codeLines;
};

const colorizer = colors(true);
const messageKey = CONSTANTS.MESSAGE_KEY;
const errorLikeObjectKeys = CONSTANTS.ERROR_LIKE_KEYS;

const formatMessage = ({
  IDENT,
  EOL
}, inputData) => {
  let log;
  let line = '';

  if (!utils.isObject(inputData)) {
    const parsed = jsonParser(inputData);
    log = parsed.value;

    if (parsed.err || !utils.isObject(log)) {
      // pass through
      return inputData + EOL;
    }
  } else {
    log = inputData;
  } // Short-circuit for spec allowed primitive values.


  if ([null, true, false].includes(log)) {
    return log + EOL;
  }

  if (messageKey in log === false) return undefined;
  if (typeof log[messageKey] !== 'string') return undefined;
  line += log[messageKey] + EOL;

  if (log.type === 'Error' && (log.stack || log.extensions)) {
    let prettifiedErrorLog = '';

    if (log.stack) {
      prettifiedErrorLog = prettifyErrorLog({
        log,
        messageKey,
        colorizer,
        errorLikeKeys: errorLikeObjectKeys,
        errorProperties: [],
        ident: IDENT,
        eol: EOL
      });
    } else if (log.extensions) {
      prettifiedErrorLog = prettifyGraphQLErrorLog({
        log,
        colorizer,
        ident: IDENT,
        eol: EOL
      });
    }

    line += prettifiedErrorLog;
  } else {
    const skipKeys = typeof log[messageKey] === 'string' ? [messageKey] : undefined;
    const prettifiedObject = prettifyObject({
      log,
      skipKeys,
      errorLikeKeys: errorLikeObjectKeys,
      eol: EOL,
      ident: IDENT
    });
    line += prettifiedObject;
  }

  return line;
};

var minimal = (({
  IDENT,
  EOL
}) => inputData => {
  try {
    return formatMessage({
      IDENT,
      EOL
    }, inputData);
  } catch {
    return typeof inputData === 'string' ? inputData : JSON.stringify(inputData);
  }
});

const defaultOptions = {
  colorize: chalk.supportsColor,
  crlf: false,
  errorLikeObjectKeys: CONSTANTS.ERROR_LIKE_KEYS,
  errorProps: '',
  levelFirst: false,
  messageKey: CONSTANTS.MESSAGE_KEY,
  timestampKey: CONSTANTS.TIMESTAMP_KEY,
  translateTime: 'SYS:yyyy-mm-dd HH:MM:ss.l',
  useMetadata: false,
  outputStream: process.stdout
};
const falconPrettyFactory = options => {
  const opts = Object.assign({}, defaultOptions, options);
  const EOL = opts.crlf ? '\r\n' : '\n';
  const IDENT = '    ';
  const {
    messageKey
  } = opts;
  const {
    timestampKey
  } = opts;
  const {
    errorLikeObjectKeys
  } = opts;
  const errorProps = opts.errorProps.split(',');
  const ignoreKeys = opts.ignore ? new Set(opts.ignore.split(',')) : undefined;
  const colorizer = colors(opts.colorize);
  const {
    search
  } = opts;

  if (opts.minimal) {
    return minimal({
      IDENT,
      EOL
    });
  }

  const formatMessage = inputData => {
    let log;

    if (!utils.isObject(inputData)) {
      const parsed = jsonParser(inputData);
      log = parsed.value;

      if (parsed.err || !utils.isObject(log)) {
        // pass through
        return inputData + EOL;
      }
    } else {
      log = inputData;
    } // Short-circuit for spec allowed primitive values.


    if ([null, true, false].includes(log)) {
      return `${log}\n`;
    }

    if (search && !jmespath.search(log, search)) {
      return undefined;
    }

    if (ignoreKeys) {
      log = Object.keys(log).filter(key => !ignoreKeys.has(key)).reduce((res, key) => {
        res[key] = log[key];
        return res;
      }, {});
    }

    const prettifiedLevel = utils.prettifyLevel({
      log,
      colorizer
    });
    const prettifiedMessage = utils.prettifyMessage({
      log,
      messageKey,
      colorizer
    });
    const prettifiedMetadata = utils.prettifyMetadata({
      log
    });
    const prettifiedTime = utils.prettifyTime({
      log,
      translateFormat: opts.translateTime,
      timestampKey
    });
    const prettifiedModule = prettifyModule({
      log,
      colorizer
    });
    let line = '';

    if (opts.levelFirst && prettifiedLevel) {
      line = `${prettifiedLevel}`;
    }

    if (prettifiedTime && line === '') {
      line = `${prettifiedTime}`;
    } else if (prettifiedTime) {
      line = `${line} ${prettifiedTime}`;
    }

    if (!opts.levelFirst && prettifiedLevel) {
      if (line.length > 0) {
        line = `${line} ${prettifiedLevel}`;
      } else {
        line = prettifiedLevel;
      }
    }

    if (opts.useMetadata && prettifiedMetadata) {
      line = `${line} ${prettifiedMetadata}`;
    }

    if (prettifiedModule) {
      line = `${line} ${prettifiedModule}`;
    }

    if (line.endsWith(':') === false && line !== '') {
      line += ':';
    }

    if (prettifiedMessage) {
      line = `${line} ${prettifiedMessage}`;
    }

    if (line.length > 0) {
      line += EOL;
    }

    if (log.type === 'Error' && (log.stack || log.extensions || log.body)) {
      let prettifiedErrorLog = '';

      if (log.body && log.locations) {
        prettifiedErrorLog = prettifyGraphQLParsingErrorLog({
          log,
          colorizer,
          ident: IDENT,
          eol: EOL
        });
      } else if (log.stack) {
        prettifiedErrorLog = prettifyErrorLog({
          log,
          messageKey,
          colorizer,
          errorLikeKeys: errorLikeObjectKeys,
          errorProperties: errorProps,
          ident: IDENT,
          eol: EOL
        });
      } else if (log.extensions) {
        prettifiedErrorLog = prettifyGraphQLErrorLog({
          log,
          colorizer,
          ident: IDENT,
          eol: EOL
        });
      }

      line += prettifiedErrorLog;
    } else {
      const skipKeys = typeof log[messageKey] === 'string' ? [messageKey] : undefined;
      const prettifiedObject = prettifyObject({
        log,
        skipKeys,
        errorLikeKeys: errorLikeObjectKeys,
        eol: EOL,
        ident: IDENT
      });
      line += prettifiedObject;
    }

    return line;
  };

  return inputData => {
    try {
      return formatMessage(inputData);
    } catch {
      return typeof inputData === 'string' ? inputData : JSON.stringify(inputData);
    }
  };
};

args.option(['c', 'colorize'], 'Force adding color sequences to the output').option(['f', 'crlf'], 'Append CRLF instead of LF to formatted lines').option(['m', 'minimal'], 'Use "minimal"').option(['e', 'errorProps'], 'Comma separated list of properties on error objects to show (`*` for all properties)', '').option(['l', 'levelFirst'], 'Display the log level as the first output field').option(['k', 'errorLikeObjectKeys'], 'Define which keys contain error objects (`-k err,error`)', 'err,error').option('messageKey', 'Highlight the message under the specified key', CONSTANTS.MESSAGE_KEY).option(['a', 'timestampKey'], 'Display the timestamp from the specified key', CONSTANTS.TIMESTAMP_KEY).option(['t', 'translateTime'], 'Display epoch timestamps as UTC ISO format or according to an optional format string (default ISO 8601)').option(['s', 'search'], 'Specify a search pattern according to jmespath').option(['i', 'ignore'], 'Ignore one or several keys: (`-i time,hostname`)', 'severity');
args.example('cat log | logger-pretty', 'To prettify logs, simply pipe a log file through').example('cat log | logger-pretty --messageKey fooMessage', "To highlight a string at a key other than 'msg', use").example('cat log | logger-pretty -a fooTimestamp', "To display timestamp from a key other than 'time', use").example('cat log | logger-pretty -t', 'To convert Epoch timestamps to ISO timestamps use the -t option').example('cat log | logger-pretty -t "SYS:yyyy-mm-dd HH:MM:ss"', 'To convert Epoch timestamps to local timezone format use the -t option with "SYS:" prefixed format string').example('cat log | logger-pretty -l', 'To flip level and time/date in standard output use the -l option').example('cat log | logger-pretty -s "msg == \'hello world\'"', "Only prints messages with msg equals to 'hello world'").example('cat log | logger-pretty -i pid,hostname', "Prettify logs but don't print pid and hostname");
const opts = args.parse(process.argv);
const pretty = falconPrettyFactory(opts);
const falconPrettyTransport = new readableStream.Transform({
  objectMode: true,

  transform(chunk, enc, cb) {
    const line = pretty(chunk.toString());
    if (line === undefined) return cb();
    cb(null, line);
  }

});
pump(process.stdin, split(), falconPrettyTransport, process.stdout); // https://github.com/pinojs/pino/pull/358

if (!process.stdin.isTTY && !fs.fstatSync(process.stdin.fd).isFile()) {
  process.once('SIGINT', function noOp() {});
}
//# sourceMappingURL=index.js.map
